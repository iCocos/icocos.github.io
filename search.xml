<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[cocos2d-x lua —— 元表metatable]]></title>
    <url>%2F2018%2F10%2F14%2Fcocos2d-x-lua-%E2%80%94%E2%80%94-%E5%85%83%E8%A1%A8metatable%2F</url>
    <content type="text"><![CDATA[Lua表关于Lua表的介绍，这里有一段出自网络的介绍： Lua的表本质其实是个类似HashMap的东西，其元素是很多的Key-Value对.如果尝试访问了一个表中并不存在的元素时，就会触发Lua的一套查找机制，也是凭借这个机制，才能够实现“面向对象”的。 那么有时候我们可能会遇到这样的一段代码： myTable = {} print(myTable.A) --这里试图打印myTable并不存在的成员A 执行结果：nil 输出为nil的原因很简单，myTable中并没有A这个成员，这符合我们平时对HashMap的认知。但对于Lua表，如果myTable有元表，情况就不同了。 Lua元表 元表像是一个备用查找表，说白了假设表A的元表是B，那么如果在A中找不到的东西就会尝试在B中去找。 在Lua中，metatable是被译作元表，Lua 中的每个值都可以用一个 metatable。这个 metatable 就是一个原始的 Lua table ，它用来定义原始值在特定操作下的行为。 一个 metatable 可以控制一个对象做数学运算操作、比较操作、连接操作、取长度操作、取下标操作时的行为，metatable 中还可以定义一个函数，让 userdata 作垃圾收集时调用它。对于这些操作，Lua 都将其关联上一个被称作事件的指定健。 当 Lua 需要对一个值发起这些操作中的一个时，它会去检查值中 metatable 中是否有对应事件。如果有的话，键名对应的值（元方法）将控制 Lua 怎样做这个操作。 #####metatable通过其包含的函数来给所挂接的table定义一些特殊的操作，包括: __add: 定义所挂接table的加法操作 __mul: 定义乘法操作 __div: 定义除法操作 __sub: 定义减法操作 __unm: 定义负操作, 即: -table的含义 __tostring: 定义当table作为tostring()函式之参数被呼叫时的行为(例如: print(table)时将呼叫tostring(table)作为输出结果) __concat: 定义连接操作(“..”运算符) __index: 定义当table中不存在的key值被试图获取时的行为 __newindex: 定义在table中产生新key值时的行为 这里主要说一下_index__index：如果A的元表是B，那么如果访问了一个A中不存在的成员，就会访问查找B中有没有这个成员。这个过程大体是这样，但却不完全是这样，实际上，即使将A的元表设置为B，而且B中也确实有这个成员，返回结果仍然会是nil，原因就是B的index元方法没有赋值。按照我的理解，index方法是用来确定一个表在被作为元表时的查找方法 father = { house=1 } son = { car=1 } setmetatable(son, father) --把son的metatable设置为father print(son.house) 输出的结果是nil，但如果把代码改为 father = { house=1 } father.__index = father -- 把father的__index方法指向自己 son = { car=1 } setmetatable(son, father) print(son.house) 输出的结果为1，符合预期。 在上述例子中，访问son.house时，son中没有house这个成员，但Lua接着发现son有元表father，于是此时father被当做元表来查找，此时，Lua并不是直接在father中找名为house的成员，而是调用father的index方法，如果index方法为nil，则返回nil，如果是一个表（上例中father的index方法等于自己，就是这种情况），那么就到index方法所指的这个表中查找名为house的成员，于是，最终找到了house成员。 注：index方法除了可以是一个表，还可以是一个函数，如果是一个函数，index方法被调用时将返回该函数的返回值。 相信到这里，应该已经很好理解了。 总结一句就是：index是:当我们访问一个表中的元素不存在时，则会触发去寻找index元方法，如果不存在，则返回nil，如果存在，则返回结果。补充 _newindex：当给你的表中不存在的值进行赋值时，lua解释器则会寻找__newindex元方法，发现存在该方法，则执行该方法进行赋值，注意，是使用rawset来进行赋值，至于原因，后面会讲到。 rawget是为了绕过index而出现的，直接点，就是让index方法的重写无效。 Lua查找一个表元素时的规则（出自网络） 1.在表中查找，如果找到，返回该元素，找不到则继续 2.判断该表是否有元表，如果没有元表，返回nil，有元表则继续 3.判断元表有没有index方法，如果index方法为nil，则返回nil；如果index方法是一个表，则重复1、2、3；如果index方法是一个函数，则返回该函数的返回值 参考链接：https://blog.csdn.net/wangbin_jxust/article/details/12108189]]></content>
  </entry>
  <entry>
    <title><![CDATA[cocos2dx——项目启动流程与跨平台原理]]></title>
    <url>%2F2018%2F09%2F14%2Fcocos2dx%E2%80%94%E2%80%94%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B8%8E%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[最近大部分空余时间都在开始学习cocos2d游戏开发相关技术，作为一个游戏行业菜鸟级别的选手，我觉得基础很重要，所以我决定从cocos2dx启动流程和快平台原理开始！ 注:这里只针对Lua做相关介绍，为什么是Lua，有过cocos2dx经验的朋友应该都知道Lua小，快，简单，而且比较大众化，而C++就不多多说了，大部分程序员都有畏惧心理，当然也有一些C++比较好，或者有独特爱好和专研朋友！ 关于其他平台基本上的流程和原理其实是一样的，可以直接参考！ 什么是Lua 百科: Lua 是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。 Lua由标准C编写而成，几乎在所有操作系统和平台上都可以编译，运行。Lua并没有提供强大的库，这是由它的定位决定的。所以Lua不适合作为开发独立应用程序的语言。 Lua 有一个同时进行的JIT项目，提供在特定平台上的即时编译功能。 很多应用程序、游戏使用LUA作为自己的嵌入式脚本语言，以此来实现可配置性、可扩展性。这其中包括魔兽世界、博德之门、愤怒的小鸟、QQ三国、VOCALOID3、太阳神三国杀、游戏王ygocore等。 Cocos2d-lua，其实只是Cocos2d引擎添加了Lua绑定的版本。Cocos2d这里就不解释了，懒得拷贝，只是关于cocos创建和使用的时候需要注意的是 cocos new TestProj -d Desktop/ -l lua，这里的引擎其实是同一套，只是创建工程时提供了不同语言的桥接层 使用C++语言和Cocos2d-x引擎进行开发时，我们写的代码是直接调用引擎的API的，因为引擎也是用C++语言编写，不需要进行语言转换 使用Lua语言和Cocos2d-x引擎进行开发时，我们写的代码通过LuaEngine执行，而LuaEngine封装了Cocos2d-x引擎的API，所以就相当于使用Lua脚本在调用Cocos2d-x的API了 各个平台的入口iOS#import &lt;UIKit/UIKit.h&gt; int main(int argc, char *argv[]) { NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init]; int retVal = UIApplicationMain(argc, argv, nil, @&quot;AppController&quot;); [pool release]; return retVal; } Mac OS#import &lt;Cocoa/Cocoa.h&gt; int main(int argc, char *argv[]) { return NSApplicationMain(argc, (const char **)argv); } Linuxint main(int argc,char *argv) { AppDelegate app; return Application::getInstance()-&gt;run(); } Androidvoid cocos_android_app_init(JNIENV* env) { appDelegate.reset(new AppDelegate()); //新版本 : AppDelegate *pAppDelegate = new AppDelegate(); } Android启动流程概述 配置文件Manifest AppActivity onCreate super.onCreate onLoadNativeLibraries System.loadLibrary(libName); 触发cocos_android_app_init（在main.cpp）中 再由库执行调用对应的Lua代码 …… 由于笔者一直着力于iOS平台，所以这里以iOS为例，其他平台可参考：1. main函数入口iOSApp中打开程序，加载完动态库，和一些必备的初始化和准备(rebase, bind,SetUp)之后,会回到main函数开始执行真正的程序代码 int main(int argc, char *argv[]) { @autoreleasepool { return UIApplicationMain(argc, argv, nil, @&quot;AppController&quot;); } } Main函数里面会调用UIApplicationMain， UIApplicationMain会一路走完这些流程 + 根据principalClassName传递的类名创建UIApplication对象 + 创建UIApplication代理对象，给UIApplication对象设置代理 + 开启主运行时间循环，处理事件，保持程序一直运行 + 加载info.plist，判断下是否指定了main，如果指定了，就会去加载 我们可以看到这里设置的代理是AppController，然后看看AppController 2. 代理对象AppControllerAppController里面有个 didFinishLaunchingWithOptions，这个是程序加载完毕的监听方法 - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { cocos2d::Application *app = cocos2d::Application::getInstance(); // Initialize the GLView attributes app-&gt;initGLContextAttrs(); cocos2d::GLViewImpl::convertAttrs(); // Override point for customization after application launch. // Add the view controller&apos;s view to the window and display. window = [[UIWindow alloc] initWithFrame: [[UIScreen mainScreen] bounds]]; // Use RootViewController to manage CCEAGLView _viewController = [[RootViewController alloc]init]; _viewController.wantsFullScreenLayout = YES; // Set RootViewController to window if ( [[UIDevice currentDevice].systemVersion floatValue] &lt; 6.0) { // warning: addSubView doesn&apos;t work on iOS6 [window addSubview: _viewController.view]; } else { // use this method on ios6 [window setRootViewController:_viewController]; } [window makeKeyAndVisible]; [[UIApplication sharedApplication] setStatusBarHidden:true]; // IMPORTANT: Setting the GLView should be done after creating the RootViewController cocos2d::GLView *glview = cocos2d::GLViewImpl::createWithEAGLView((__bridge void *)_viewController.view); cocos2d::Director::getInstance()-&gt;setOpenGLView(glview); //run the cocos2d-x game scene app-&gt;run(); return YES; } 前面分别：获取Director，GLView设置GLView，最后执行run 3. run cocos2d delegate我们看看run方法里面，这里的run方法很关键， int Application::run() { if (applicationDidFinishLaunching()) { [[CCDirectorCaller sharedDirectorCaller] startMainLoop]; } return 0; } 有个applicationDidFinishLaunching，其实这里cocos2d默认的代理，在class中 4. cocos2d配置，lua加载这里在coco2d的代理中，可以看到一堆的初始化配置和加载，然后就开始获取并执行脚本lua(通过lua脚本显示并处理Scene逻辑) bool AppDelegate::applicationDidFinishLaunching() { // set default FPS Director::getInstance()-&gt;setAnimationInterval(1.0 / 60.0f); // register lua module auto engine = LuaEngine::getInstance(); ScriptEngineManager::getInstance()-&gt;setScriptEngine(engine); lua_State* L = engine-&gt;getLuaStack()-&gt;getLuaState(); lua_module_register(L); register_all_packages(); LuaStack* stack = engine-&gt;getLuaStack(); stack-&gt;setXXTEAKeyAndSign(&quot;2dxLua&quot;, strlen(&quot;2dxLua&quot;), &quot;XXTEA&quot;, strlen(&quot;XXTEA&quot;)); //register custom function //LuaStack* stack = engine-&gt;getLuaStack(); //register_custom_function(stack-&gt;getLuaState()); #if CC_64BITS FileUtils::getInstance()-&gt;addSearchPath(&quot;src/64bit&quot;); #endif FileUtils::getInstance()-&gt;addSearchPath(&quot;src&quot;); FileUtils::getInstance()-&gt;addSearchPath(&quot;res&quot;); if (engine-&gt;executeScriptFile(&quot;main.lua&quot;)) { return false; } return true; } 原生集成补充如果你是直接在原生嵌入而不是夸平台会看到这里其实是创建并返回Scene bool AppDelegate::applicationDidFinishLaunching() { // initialize director auto director = Director::getInstance(); auto glview = director-&gt;getOpenGLView(); if(!glview) { glview = GLViewImpl::create(&quot;Fiction_Single&quot;); director-&gt;setOpenGLView(glview); } // turn on display FPS // director-&gt;setDisplayStats(true); // set FPS. the default value is 1.0/60 if you don&apos;t call this director-&gt;setAnimationInterval(1.0f / 60); register_all_packages(); //SpriteFrameCache::getInstance()-&gt;removeSpriteFrames(); //SpriteFrameCache::getInstance()-&gt;removeUnusedSpriteFrames(); // create a scene. it&apos;s an autorelease object // 初始化与运行主场景 auto scene = GameMainLayer::MainScene(); // 初始化与运行主场景 director-&gt;runWithScene(scene); return true; } 游戏逻辑就可以从这个Scene中的init函数开始，添加UI层，添加事件监听器，添加游戏层等等…如果我们有一些统计、资源管理器等，也可以在AppDelegate的applicationDidFinishLaunching函数中来进行。 5. Lua脚本初始化再来看”main.lua”，这个时候我们就开始开发查看main.lua文件 从MyApp开始，初始化，然后执行run运行程序 cc.FileUtils:getInstance():setPopupNotify(false) require &quot;config&quot; require &quot;cocos.init&quot; local function main() require(&quot;app.MyApp&quot;):create():run() end local status, msg = xpcall(main, __G__TRACKBACK__) if not status then print(msg) end 这里很重要的一个方法是run(),run()方法是设置启动View， 6. 指定Scene如果想指定启动，而不是使用默认的Scene， local function main() require(“app.MyApp”):create():run(“StartScene”)end 默认不设置会选择MainScene，如果仔细再AppBase里面会看到这样一行代码 function AppBase:ctor(configs) self.configs_ = { viewsRoot = &quot;app.views&quot;, modelsRoot = &quot;app.models&quot;, defaultSceneName = &quot;MainScene&quot;, } ..... 7. 根据脚本指定Scene，上面说了，如果没有设置就会试着用默认的Scene，run里面的逻辑就是去真正指定Scene， -- 创建完对象之后，就到了这一步 function AppBase:run(initSceneName) initSceneName = initSceneName or self.configs_.defaultSceneName self:enterScene(initSceneName) -- 如果没有指定第一个Scene，则第一个Scene为MainScene end -- 生成并进入第一个Scene function AppBase:enterScene(sceneName, transition, time, more) local view = self:createView(sceneName) -- 前去生成View view:showWithScene(transition, time, more) -- 因为MainScene继承自ViewBase类，这里就吊用ViewBase的方法了 return view end 建议仔细读一下AppBase，ViewBase！ 8. 自定义Scene(StartScene)这个时候就会首先从StartScene开始， local StartScene = class(&quot;StartScene&quot;, cc.load(&quot;mvc&quot;).ViewBase) function StartScene:onCreate() display.newSprite(&quot;HelloWorld.png&quot;) :move(display.center) :addTo(self) cc.Label:createWithSystemFont(&quot;cocos2dx Run StartScene&quot;, &quot;Arial&quot;, 60) :move(display.cx, display.cy + 200) :addTo(self) end return StartScene 然后后面步骤就是从StartScene开始，写脚本代码，处理UI，网络和逻辑等，到这里就基本上完成cocos2dx Lua启动流程，其他C++,JS原理和流程其实都差不多, 只是执行的方法或者代码不一样而已 总结其实关于coocs2dx之前的版本我不了解，就我目前了解到的，其实就是由通用程序入口到跨平台程序入口 基本的流程如下 初始化Director 新建GLView，然后进行一些设置 新建Scene 使用Director运行这个场景 bool AppDelegate::applicationDidFinishLaunching()//程序入口 -&gt; 跨平台程序入口 { auto director = Director::getInstance(); auto glview = director-&gt;getOpenGLView(); if(!glview) { glview = GLViewImpl::create(&quot;my test&quot;); director-&gt;setOpenGLView(glview); } //初始化、资源适配、屏幕适配、运行第一个场景... glview-&gt;setDesignResolutionSize(); auto scene = Hellow::scene(); director-&gt;runWithScene(scene); return scene; } 通过上面我们其实可以知道，cocos2d_lua_bindings库提供了Lua对Cocos2d引擎的绑定，相当于通过注册Module的方式对Cocos2d引擎提供的（相关的）API进行了一次封装（把常用的功能封装成一个函数newScene）。 相对于Cocos2d-x C++工程来说，Cocos2d-x生成的Lua语言工程提供了对Cocos2d引擎的Lua语言封装。将Cocos2d引擎API绑定到对应的Lua语言函数，在调用到这些函数时，会执行对应的Cocos2d引擎API, 其实最终还是调用的C++代码和对应的引擎代码。 跨平台原理 AppDelegate 作为跨平台程序入口，在这之上做了另一层的封装，封装了不同平台的不同实现。比如我们通常认为一个程序是由 main 函数开始运行，那我们就去找寻，我们看到了在 proj.linux 目录下存在 main.cpp 文件。 在main.cpp 中 CCApplication::sharedApplication()–&gt;run(); 这一句看起，这一句标志着， cocos2d-x 程序正式开始运行. 定位到 sharedApplication() 方法的实现，在CCAplication类中我们可以看到从 sharedApplication() 方法，在调用 run() 方法，在这之前，我们需要调用到它的构造函数，否则不能运行，这就是为什么在 CCApplication::sharedApplication()–&gt;run(); 之前，我们首先有语句 AppDelegate app; 创建 AppDelegate 变量的原因是 AppDelegate 是 CCApplication 的子类，在创建子类对象的时候，调用其构造函数的同时，父类构造函数也会执行，然后就将 AppDelegate 的对象赋给了 CCApplication 的静态变量，而在 AppDelegate 之中我们实现了 applicationDidFinishLaunching方法，所以在 CCApplication 中 run 方法的开始处调用的就是 AppDelegate 之中的实现。 我们在此方法中我们初始化了一些变量，创建了第一个 CCScene 场景等，之后的控制权，便全权交给了CCDirector::sharedDirector()–&gt;mainLoop(); 方法了。 在cocos2d-x的文件夹下，有一个platform文件夹，里面存放了跨平台的封装接口。 当前目录下有CCApplicationProtocol.h头文件，子目录有win32,Android,IOS三个文件夹，里面分别存放跨平台需要的函数，其中包括CCApplication。 而AppDelegate 类则是继承自CCApplication。CCApplication又继承自CCApplicationProtocol。 在CCApplicationProtocol中定义了applicationDidFinishLaunching虚方法,由CCApplication 继承， AppDelegate 实现的。以此实现了跨平台。 为了充分发挥硬件性能，手机游戏通常使用Native App开发模式，这就造成开发商要为iOS 和Android平台用户开发不同的应用，无论是产品迭代还是运行维护都非常麻烦。 Cocos2d-x在iOS，Android等移动平台之上，封装了一层C++接口，从而屏蔽了平台的差异性，通过平台宏来控制使用哪个平台的代码，向开发者提供C++接口调用。这些接口主要包括UI、事件和网络，封装UI主要是使用OpenGL ES的接口来写UI，封装事件和网络，均是使用C++接口对原生接口进行一层封装。 具体更多启动相关细节，可以参考这里 https://www.jianshu.com/p/781d835c88c9 http://www.cocos2d-x.org/docs/cocos2d-x/zh/about/learn.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS——请求依赖多种解决方案]]></title>
    <url>%2F2018%2F08%2F23%2FiOS%E2%80%94%E2%80%94%E8%AF%B7%E6%B1%82%E4%BE%9D%E8%B5%96%E5%A4%9A%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[iOS开发中如何解决网络请求的依赖关系(同时应用于业务层) 比如：一个(或多个)接口的请求需要依赖于另一个(或多个)网络请求的结果？ 目录 操作依赖 – NSOperation 逻辑判断 – if/else 线程同步 – 组队列 线程同步 – 阻塞任务 线程同步 – 信号量机制 操作依赖 – NSOperationNSOperation 操作依赖和优先级（不适用，异步网络请求并不是立刻返回，无法保证回调时再开启下一个网络请求） 1234567891011121314151617181920// Do any additional setup after loading the view, typically from a nib.//创建队列NSOperationQueue *queue=[[NSOperationQueue alloc] init];//创建操作NSBlockOperation *operation1=[NSBlockOperation blockOperationWithBlock:^()&#123; NSLog(@"执行第1次操作，线程：%@",[NSThread currentThread]);&#125;];NSBlockOperation *operation2=[NSBlockOperation blockOperationWithBlock:^()&#123; NSLog(@"执行第2次操作，线程：%@",[NSThread currentThread]);&#125;];NSBlockOperation *operation3=[NSBlockOperation blockOperationWithBlock:^()&#123; NSLog(@"执行第3次操作，线程：%@",[NSThread currentThread]);&#125;];//添加依赖[operation1 addDependency:operation2];[operation2 addDependency:operation3];//将操作添加到队列中去[queue addOperation:operation1];[queue addOperation:operation2];[queue addOperation:operation3]; 逻辑判断 – if/else上一个网络请求的响应回调后，下一网络请求的才开始执行 1234567891011121314NSString *urlString = @"http://www.icocos.cn"; AFHTTPSessionManager *manger =[AFHTTPSessionManager manager]; [manger GET:urlString parameters:nil progress:^(NSProgress * _Nonnull downloadProgress) &#123; &#125; success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123; NSLog(@"成功"); ///////////////////////////////////////////// // TODO： 执行下一个请求 /////////////////////////////////////////////&#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123; NSLog(@"%@",error);&#125;]; 但是这样会存在一个概率性的问题，就会有可能根本拿不到结果，或者由于网络慢和用户操作之间的关系导致不可预料的问题。 线程同步 – 组队列（dispatch_group）dispatch_group是GCD(Grand Central Dispatch)中的一组方法，他有一个组的概念，可以把相关的任务归并到一个组内来执行，通过监听组内所有任务的执行情况来做相应处理。 1.dispatch_group_async 将代码块dispatch_block_t block放入队列dispatch_queue_t queue中执行；并和调度组dispatch_group_t group相互关联；如果提交到dispatch_queue_t queue中的block全都执行完毕会调用dispatch_group_notify并且dispatch_group_wait会停止等待； 2.dispatch_group_enter(group)、dispatch_group_leave(group) 和内存管理的引用计数类似，我们可以认为group也持有一个整形变量(只是假设)，当调用enter时计数加1，调用leave时计数减1，当计数为0时会调用dispatch_group_notify并且dispatch_group_wait会停止等待； 3.dispatch_group_notify 当关联到dispatch_group_t上的dispatch_group_async任务执行完毕或者是关联在上面的dispatch_group_enter、dispatch_group_leave成对出现了。参数中的dispatch_block_t block会被提交到dispatch_queue_t queue中执行。 4.dispatch_group_wait 和dispatch_group_notify功能类似(多了一个dispatch_time_t参数可以设置超时时间)，在group上任务完成前，dispatch_group_wait会阻塞当前线程(所以不能放在主线程调用)一直等待；当group上任务完成，或者等待时间超过设置的超时时间会结束等待； 5……….. 1234567891011121314151617181920212223bashdispatch_queue_t dispatchQueue = dispatch_queue_create(&quot;icocos.queue.next&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_queue_t globalQueue = dispatch_get_global_queue(0, 0); dispatch_group_t dispatchGroup = dispatch_group_create(); dispatch_group_async(dispatchGroup, dispatchQueue, ^()&#123; dispatch_async(globalQueue, ^&#123; sleep(5); NSLog(@&quot;请求任务一完成&quot;); &#125;); &#125;); dispatch_group_async(dispatchGroup, dispatchQueue, ^()&#123; dispatch_async(globalQueue, ^&#123; sleep(8); NSLog(@&quot;请求任务二完成&quot;); &#125;); &#125;); dispatch_group_notify(dispatchGroup, dispatch_get_main_queue(), ^()&#123; NSLog(@&quot;notify：请求任务都完成了&quot;); &#125;);&#125; 线程同步 –阻塞任务（dispatch_barrier）：一个dispatch barrier 允许在一个并发队列中创建一个同步点。当在并发队列中遇到一个barrier, 他会延迟执行barrier的block,等待所有在barrier之前提交的blocks执行结束。 这时，barrier block自己开始执行。 之后， 队列继续正常的执行操作。 调用这个函数总是在barrier block被提交之后立即返回，不会等到block被执行。当barrier block到并发队列的最前端，他不会立即执行。相反，队列会等到所有当前正在执行的blocks结束执行。到这时，barrier才开始自己执行。所有在barrier block之后提交的blocks会等到barrier block结束之后才执行。 dispatch_barrier_async函数的作用 1.实现高效率的数据库访问和文件访问 2.避免数据竞争 1234567891011121314151617181920/* 创建并发队列 */dispatch_queue_t concurrentQueue = dispatch_queue_create("test.concurrent.queue", DISPATCH_QUEUE_CONCURRENT);/* 添加两个并发操作A和B，即A和B会并发执行 */dispatch_async(concurrentQueue, ^()&#123; NSLog(@"请求OperationA");&#125;);dispatch_async(concurrentQueue, ^()&#123; NSLog(@"请求OperationB");&#125;);/* 添加barrier障碍操作，会等待前面的并发操作结束，并暂时阻塞后面的并发操作直到其完成 */dispatch_barrier_async(concurrentQueue, ^()&#123; NSLog(@"请求OperationBarrier!");&#125;);/* 继续添加并发操作C和D，要等待barrier障碍操作结束才能开始 */dispatch_async(concurrentQueue, ^()&#123; NSLog(@"请求OperationC");&#125;);dispatch_async(concurrentQueue, ^()&#123; NSLog(@"请求OperationD");&#125;); 线程同步 – 信号量机制（dispatch_semaphore）： 信号量： 就是一种可用来控制访问资源的数量的标识，设定了一个信号量，在线程访问之前，加上信号量的处理，则可告知系统按照我们指定的信号量数量来执行多个线程。 其实，这有点类似锁机制了，只不过信号量都是系统帮助我们处理了，我们只需要在执行线程之前，设定一个信号量值，并且在使用时，加上信号量处理方法就行了。 信号量主要有3个函数创建信号量，参数：信号量的初值，如果小于0则会返回NULL dispatch_semaphore_create（信号量值） //等待降低信号量 dispatch_semaphore_wait（信号量，等待时间） //提高信号量 dispatch_semaphore_signal(信号量) 注意，正常的使用顺序是先降低然后再提高，这两个函数通常成对使用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758- (void)getToken&#123; //以上请求的设置忽略 NSURLSessionDataTask *task = [mySession dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; if (data) &#123; NSLog(@"get Token"); //拿到token，传给request请求做参数 [self request:token]; &#125;else&#123; NSLog(@"token error:%@",error.description); &#125; &#125;]; [task resume];&#125;- (void)request:(NSString *)params&#123; //请求的设置忽略 NSURLSessionDataTask *task = [mySession dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; if (data) &#123; NSLog(@"request success"); &#125;else&#123; NSLog(@"request error:%@----",error.description); &#125; &#125;]; [task resume];&#125;// 指定调用- (IBAction)buttonPress:(UIButton *)sender&#123; //创建一个并行队列 dispatch_queue_t queque = dispatch_queue_create("GoyakodCreated", DISPATCH_QUEUE_CONCURRENT); //异步执行 dispatch_async(queque, ^&#123; dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); [self getToken:semaphore]; dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); [self request]; &#125;); NSLog(@"main thread");&#125;- (void)getToken:(dispatch_semaphore_t)semaphore&#123; //以上请求的设置忽略 NSURLSessionDataTask *task = [mySession dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; if (data) &#123; NSLog(@"get Token"); //成功拿到token，发送信号量: dispatch_semaphore_signal(semaphore); &#125;else&#123; NSLog(@"token error:%@",error.description); &#125; &#125;]; [task resume];&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>网络层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发必备理论常识：HTTP->HTTPS]]></title>
    <url>%2F2018%2F08%2F18%2F%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E7%90%86%E8%AE%BA%E5%B8%B8%E8%AF%86%EF%BC%9AHTTP-HTTPS%2F</url>
    <content type="text"><![CDATA[简介 超文本传输协议（HTTP，HyperText Transfer Protocol) 是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。 HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer） 是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 HTTPS句法类同http:体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。 TCP/IPHTTP是一个基于TCP的协议,而TCP是一种可靠的传输层协议. TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。WEB使用HTTP协议作应用层协议，以封装HTTP 文本信息，然后使用TCP/IP做传输层协议将它发到网络上。 HTTPS HTTP+加密+认证+完整性保护=HTTPS 是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 HTTPS协议的主要作用可以分为两种： 一种是建立一个信息安全通道，来保证数据传输的安全； 另一种就是确认网站的真实性。 HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。 SSL/TLS SSL：（Secure Socket Layer，安全套接字层） 位于可靠的面向连接的网络层协议和应用层协议之间的一种协议层。SSL通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯。该协议由两层组成：SSL记录协议和SSL握手协议。 TLS：（Transport Layer Security，传输层安全协议） 用于两个应用程序之间提供保密性和数据完整性。该协议由两层组成：TLS记录协议和TLS握手协议。 SSL是Netscape开发的专门用于保护Web通讯的，目前版本为3.0.最新版本的TLS 1.0是IETE（工程任务组）指定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本。两者差别极小，可以理解为SSL 3.1，它是写入了RFC的。 SSL的作用 （1）、认证用户和服务器，确保数据发送到正确的客户机和服务器； （2）、加密数据以防止数据中途被窃取； （3）、维护数据的完整性，确保数据在传输过程中不被改变。 而SSL证书指的是在SSL通信中验证通信双方身份的数字文件，一般分为服务器证书和客户端证书，我们通常说的SSL证书主要指服务器证书，SSL证书由受信任的数字证书颁发机构CA（如VeriSign，GlobalSign，WoSign等），在验证服务器身份后颁发，具有服务器身份验证和数据传输加密功能，分为扩展验证型(EV)SSL证书、组织验证型(OV)SSL证书、和域名验证型（DV）SSL证书。 CA证书 CA（Certificate Authority）是负责管理和签发证书的第三方权威机构，是所有行业和公众都信任的、认可的。 CA证书，就是CA颁发的证书，可用于验证网站是否可信（针对HTTPS）、验证某文件是否可信（是否被篡改）等，也可以用一个证书来证明另一个证书是真实可信，最顶级的证书称为根证书。除了根证书（自己证明自己是可靠），其它证书都要依靠上一级的证书，来证明自己。 HTTP&amp;HTTPS区别：简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。 https协议需要到ca申请证书或自制证书。 http的信息是明文传输，https则是具有安全性的ssl加密。 http是直接与TCP进行数据传输，而https是经过一层SSL（OSI表示层），用的端口也不一样，前者是80（需要国内备案），后者是443。 http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 HTTP&amp;HTTPS综合区别：https://blog.csdn.net/hanjianqiang2468/article/details/52605849 注意: https加密是在传输层 https报文在被包装成tcp报文的时候完成加密的过程，无论是https的header域也好，body域也罢都是会被加密的。 当使用tcpdump或者wireshark之类的tcp层工具抓包，获取是加密的内容，而如果用应用层抓包，使用Charels(Mac)、Fildder(Windows)抓包工具，那当然看到是明文的。 握手过程HTTP三次握手 HTTP（HyperText Transfer Protocol)超文本传输协议是互联网上应用最为广泛的一种网络协议。由于信息是明文传输，所以被认为是不安全的。而关于HTTP的三次握手，其实就是使用三次TCP握手确认建立一个HTTP连接。 SYN（synchronous）是TCP/IP建立连接时使用的握手信号、Sequence number（序列号）、Acknowledge number（确认号码），三个箭头指向就代表三次握手，完成三次握手，客户端与服务器开始传送数据。 第一次握手： 客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认； 第二次握手： 服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手： 客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 建立TCP连接时会发生:三次握手(three-way handshake) firefox &gt; nginx [SYN] 在么 nginx &gt; firefox [SYN, ACK] 在 firefox &gt; nginx [ACK] 知道了 为什么断开需要四次握手:关于四次握手的详细过程这里就不过多介绍，请自行百度，这里简单说一下需要执行的步骤，和为什么连接是三次，二断开时四次 关闭TCP连接时会发生:四次挥手(four-way handshake) firefox &gt; nginx [FIN] 我要关闭连接了 nginx &gt; firefox [ACK] 知道了,等我发完包先 nginx &gt; firefox [FIN] 我也关闭连接了 firefox &gt; nginx [ACK] 好的,知道了 解释原因： TCP建立连接要进行3次握手,而断开连接要进行4次,这是由于TCP的半关闭造成的,因为TCP连接是全双工的( 即数据可在两个方向上同时传递)所以进行关闭时每个方向上都要单独进行关闭,这个单方向的关闭就叫半关闭. 关闭的方法是一方完成它的数据传输后,就发送一个FIN来向另一方通告将要终止这个方向的连接.当一端收到一个FIN,它必须 通知应用层TCP连接已终止了这个方向的数据传送,发送FIN通常是应用层进行关闭的结果. 另一种解释： 这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。 补充 SYN: synchronization(同步) ACK: acknowledgement(确认:告知已收到) FIN: finish(结束) HTTPS握手： HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。具体是如何进行加密，解密，验证的，且看下图，下面的称为一次握手。 1.客户端发起HTTPS请求 2.服务端的配置 采用HTTPS协议的服务器必须要有一套数字证书，可以是自己制作或者CA证书。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用CA证书则不会弹出提示页面。这套证书其实就是一对公钥和私钥。公钥给别人加密使用，私钥给自己解密使用。 3.传送证书 这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等。 4.客户端解析证书 这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值，然后用证书对该随机值进行加密。 5.传送加密信息 这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。 6.服务段解密信息 服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。 7.传输加密后的信息 这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。 8.客户端解密信息 客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。 注意: HTTPS中整个握手过程第三方即使监听到了数据，也束手无策。 为什么HTTPS是安全的？ 在HTTPS握手的第四步中，如果站点的证书是不受信任的，会显示出现下面确认界面，确认了网站的真实性。另外第六和八步，使用客户端私钥加密解密，保证了数据传输的安全。 app与后台通信完整流程 1.建立连接：前台后台建立连接。 2.发送请求：打开连接后，app向后台发送请求。 3.发送响应：后台处理完请求后，要向app发送响应消息。 后台通过关键词：路径映射，Dispatcher分发机制等方式处理app的请求 4.断开连接：以上交互完成后可以断开连接了。 浏览器执行过程 1.首先嘛，你得在浏览器里输入要网址: 2.浏览器查找域名的IP地址 3.浏览器给web服务器发送一个HTTP请求 4.facebook服务的永久重定向响应.服务器给浏览器响应一个301永久重定向响应，这样浏览器就会问“http://www.facebook.com/” 而非“http://facebook.com/”。 5.浏览器跟踪重定向地址.浏览器知道了“http://www.facebook.com/”才是要访问的正确地址，所以它会发送另一个获取请求： 6.服务器“处理”请求.服务器接收到获取请求，然后处理并返回一个响应。 7.服务器发回一个HTML响应. 8.浏览器开始显示HTML. 9.浏览器发送获取嵌入在HTML中的对象。在浏览器显示HTML时，它会注意到需要获取其他地址内容的标签。这时，浏览器会发送一个获取请求来重新获得这些文件。 10.浏览器发送异步（AJAX）请求。]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>开发</tag>
        <tag>HTTP+HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS(OC+cocos2dx)游戏APP磁盘空间爆增(文稿与数据)]]></title>
    <url>%2F2018%2F08%2F16%2FiOS-OC-cocos2dx-%E6%B8%B8%E6%88%8FAPP%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E7%88%86%E5%A2%9E-%E6%96%87%E7%A8%BF%E4%B8%8E%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[这段时间在开发公司的新产品二次元游戏(零下记忆)，由于接触coco2dx不久，很多东西还在摸索，也没少加班，所以都没有时间整理和发文了。 但是最近(从周一开始),发现了一个特别其他的Bug，App磁盘数据报增，幸好我手机是64G的，不然估计会爆炸！ 先来张爆图！ 这个产品是在Objective-C原生架构的基础上接入cocos2dx(C++)，所以导致部分文件或者类需要使用MRC模式。 我曾尝试过 使用模拟器针对不同时段操作，计算沙盒文件大小。 借助部门同事的越狱机导包寻找导致爆增的具体文件。 多次删除App，关闭可能存在问题原因的代码。 借助内存泄漏框架自动记录，内存变化与位置。 借助Xcode自带Instrument定点查找具体位置和代码。 通过Stack Overflow查询更多可能导致的原因。 经过一次次排查，和一个个问题的处理，最终通过多次杀进程，和运行测试，终于处理完成，不过还有待优化！ 下面是具体原因和流程。清理缓存：清理cocos2dx缓存：123456789CCAnimationCache::purgeSharedAnimationCache();CCSpriteFrameCache::purgeSharedSpriteFrameCache();CCTextureCache::purgeSharedTextureCache(); CCSpriteFrameCache::sharedSpriteFrameCache()-&gt;removeUnusedSpriteFrames();CCTextureCache::sharedTextureCache()-&gt;removeUnusedTextures();CCTextureCache::sharedTextureCache()-&gt;removeAllTextures();Director::getInstance()-&gt;getTextureCache()-&gt;removeAllTextures(); 清理运行磁盘，内存或者缓存123456789101112131415161718192021222324252627282930313233343536+ (void)clearAllCache &#123; [[SDImageCache sharedImageCache] clearMemory]; [[SDImageCache sharedImageCache] clearDiskOnCompletion:nil]; // 拿到cachePath路径的下一级目录的子文件夹 // contentsOfDirectoryAtPath:error:递归 // subpathsAtPath:不递归 NSArray *subpathArray = [fileManager contentsOfDirectoryAtPath:cachePath error:nil]; // 如果数组为空，说明没有缓存或者用户已经清理过，此时直接return if (subpathArray.count == 0) &#123;#ifdef DEBUG NSLog(@"cachePath缓存清理完成");#else #endif &#125; NSError *error = nil; NSString *filePath = nil; BOOL flag = NO; for (NSString *subpath in subpathArray) &#123; filePath = [cachePath stringByAppendingPathComponent:subpath]; if ([fileManager fileExistsAtPath:cachePath]) &#123; // 删除子文件夹 BOOL isRemoveSuccessed = [fileManager removeItemAtPath:filePath error:&amp;error]; if (isRemoveSuccessed) &#123; // 删除成功 flag = YES; &#125; &#125; &#125; if (NO == flag) &#123;#ifdef DEBUG NSLog(@"已经清理了所有可以访问的文件,不可访问的文件无法删除"); // 调试阶段才打印#else #endif &#125;&#125; 记忆中此处大概处理了1-3G 内存管理通过Stack Overflow和相应代码调试最后发现： 原来是把sprite和控件都retain了，需要手动release，才能释放图片。 所以我得找到对应的cocos2dx项目代码，对创建和操作的对象进行release操作，这里比较蛋疼，得一个个找！ 处理中遇到个问题： removeTexture执行release后，不管有没有被gl释放掉，都从列表里删除。 但是如果load进来的node被addChild到场景中，应该是不需要retain的，addChild会自动retain，这里不清楚，cocos2dx引擎设计者在load里加retain是为了什么， 这里所导致的问题，几乎是使用过程中内存暴涨 环境与配置(主要原因):通过多次测试发现沙盒文件中的temp中有一堆文件stack-logs.xxxxx.index 同时控制台也打印了一大堆看不懂也搜不到的内容 结合以上几点才初步猜测可能是因为配置环境的问题，查阅资料后发现这与Xcode设置有关,具体配置原因我也不记得了，印象中是当时配置接入cocos2dx的时候，遇到了一些问题，点过了一次，但是现在想想好像当时的操作并没有什么卵用！ Edit Scheme中Diagnostics有个logging分类，下面有个Malloc Stack选项，将勾选取消。 处理完后立刻验证了一下,重装App,多次执行杀进程和实际测试用，在tmp下并没有产生那个文件stack-logs.xxxxx.index,磁盘占用也处于稳定状态,再打开手机设置查看存储空间，也很正常。 以上文稿与数据的15.7中有13M多属于App下载的资源文件。 That’s all for today.]]></content>
      <categories>
        <category>iOS游戏</category>
      </categories>
      <tags>
        <tag>iOS游戏</tag>
        <tag>磁盘管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[游戏引擎——cocos2dx入门]]></title>
    <url>%2F2018%2F08%2F09%2F%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94cocos2dx%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[简介 Cocos2d-x是一个开源的移动2D游戏框架，MIT许可证下发布的。这是一个C++ Cocos2d-iPhone项目的版本。Cocos2d-X发展的重点是围绕Cocos2d跨平台，Cocos2d-x提供的框架。手机游戏，可以写在C++或者Lua中，使用API是Cocos2d-iPhone完全兼容。Cocos2d-x项目可以很容易地建立和运行在iOS，Android，黑莓Blackberry等操作系统中。Cocos2d-x还支持Windows、Mac和Linux等桌面操作系统，因此，开发者编写的源代码很容易在桌面操作系统中编辑和调试。 cocos2dx 与 UNITY3D 一、区别: 1、COCOS2D开源,有文档支持,论坛资料庞杂博大；UNITY3D闭源,有强大的文档支持,论坛资料一样的庞杂博大。 2、COCOS2D免费；UNITY3D收费。 3、COCOS2D的跨平台,需要大量重写代码；UNITY3D的跨平台,程序员只需要选选按钮就淡定许多的搞定了。 二、拓展: 1、不同: COCOS2D拥有令人发指的可定制性；UNITY3D有一个专门为订制而写的类库。 2、相同: UNITY3D和 COCOS2D-X都是跨平台的游戏开发引擎。 特性 现代化的 C++ API 立足于 C++ 同时支持 JavaScript/Lua 作为开发语言 可以跨平台部署, 支持 iOS、Android、Windows、macOS 和 Linux 可以在 PC 端完成游戏的测试，最终发布到移动端 完善的游戏功能支持，包含精灵、动作、动画、粒子特效、场景转换、事件、文件 IO、数据持久化、骨骼动画、3D 家族成员 cocos2d是一个基于MIT协议的开源框架，用于构建游戏、应用程序和其他图形界面交互应用。可以让你在创建自己的多平台游戏时节省很多的时间。 Cocos2d-html5 ： Cocos2d-HTML5 是基于 HTML5 规范集的 Cocos2d引擎分支，具有跨平台的能力和强大的性能，是 Cocos2d 系列引擎随着互联网技术演进而产生的一个分支，该分支基于 HTML5 规范集，目标是可对游戏进行跨平台部署，Cocos2d-HTML5 采用 MIT 开源协议，设计上保持Cocos2d家族的传统架构，并可联合 Cocos2d-x JavaScript-binding 接口，最大程度地实现游戏代码在不同平台上的复用。 JSB ： Cocos2d-x JavaScript-binding 是使用 SpiderMonkey 引擎实现 C++ 接口到 JavaSciprt 的绑定方案，它可以使用 Js 快速开发游戏，以更简单的语法实现功能，并且能与 Cocos2D-HTML5 相互兼容，使同一套代码，运行两个平台，这是相比使用 Lua 实现的一个明显优势。 Cocos Studio ： Cocos Studio 是一套基于 Cocos2d-x 引擎的工具集，包括 UI编辑器，动画编辑器，场景编辑器和数据编辑器。 UI 编辑器和动画编辑器主要面向美术，而场景编辑器和数据编辑器则面向游戏策划，这四个工具合在一起构成了一套完整的游戏开发体系，帮助开发者进一步降低开发难度，提高开发效率，减少开发成本。 Cocos2d也拥有几个主要版本，包括Cocos2d-iPhone、Cocos2d-X，以及被社区普遍看好的Cocos2d-HTML5和JavaScript bindings for Cocos2d-X。 关于lua，c++，JS允许开发人员使用 C++、Javascript 及 Lua 三种语言来进行游戏开发。 支持所有常见平台，包括 iOS、Android、Windows、macOS、Linux。 运行效率： Lua 的性能在各种测试里都比 JavaScript 快不少。而移动设备上存在不支持 JIT 的情况（未越狱的 iOS 设备），Lua 对比 JavaScript 的性能优势就更明显。 安全性： 现在 cocos2d-x 使用 LuaJIT 来执行 Lua，所以可以把 Lua 代码编译为字节码再打包到游戏里。由于 LuaJIT 的字节码是高度优化过的，所以目前还没有反编译工具。而 JS 虽然也可以用字节码，但从目前的情况看还达不到 LuaJIT 的安全性。 与 C/C++ 的交互： Lua 原本就是作为嵌入式语言来设计的，所以天然和 C/C++ 很容易交互。JS 这方面是个劣势。 与 Java/Objective-C 的交互： 不管是 quick-cocos2d-x 里提供的 luaoc/luaj 模块，还是 wax, luajava 这些开源项目，都让我们可以绕过 C/C++ 层实现 Lua 和 Java/Objc 的交互。这个优势在游戏发行阶段，集成各种第三方 SDK 时绝对会节约巨量时间！！！ 游戏是非常消耗资源的每时每刻都要大量的计算， 假如有个方法 让 C语言来实现 并且把它完成的时间定义为 1个单位 的时间 那么同样的数据结构的方法在其他语言中 java 需要 8个单位 lua需要30个单位 python需要200个单位 php需要462个单位 javascript需要621个单位 所以在需要大量计算的环节，代码的结构时间复杂度比较高的 情况下用 C++（肯没直接用C快，但一定比java快）来写， 现在的CPU计算能力都还是蛮高的，所以没必要完全用C++ ，用一些其他的语言开发速度可以大大加快。 个人总结 项目不需要热更新的时候用c++ lua，c++都可以用的时候c++更熟悉的用c++ c++效率比lua高 lua项目的底层框架还是要c++搭比较好 c++老司机转其他语言比较轻松。 最终使用那种方式还是需要结合个人，语言，需求，性能综合考虑 当然，cocos2d-x 目前明显是在主推 JS 的解决方案，因为 JS 可以跨越移动设备、桌面的界限，实现一套程序跑任意平台。不过我个人认为以当前 HTML5 的发展情况，对于要强调体验的游戏来说，HTML5 还要一些时间。 网友评价：前面提到 JS 更容易面向对象，我想可能是因为大家对 Lua 还不够了解造成的错觉。实际上，Lua 和 JS 实现面向对象的机制几乎是一样的。JS 基于 prototype，Lua 基于 metatable，在我看来仅仅是名字不同而已。 从目前的市场情况来说，Lua 明显是更理性的选择：成熟、安全性高、众多大作采用。 推荐 官方文档：http://www.cocos2d-x.org/docs/cocos2d-x/zh/about/learn.html OC/Swift - C++交互与混编:http://edu.51cto.com/center/course/lesson/index?id=57316 入门实战-飞机大战游戏：http://www.maiziedu.com/course/662-9914/]]></content>
      <categories>
        <category>cocos2dx</category>
      </categories>
      <tags>
        <tag>cocos2dx</tag>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识游戏——cocos2dx初探]]></title>
    <url>%2F2018%2F06%2F15%2F%E5%88%9D%E8%AF%86%E6%B8%B8%E6%88%8F%E2%80%94%E2%80%94cocos2dx%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[前端时间一直在忙项目，也提到了关于是一个AVG游戏项目，近期由于最新需求，需要开发iOS 游戏，之前做了这么久一直没有感觉到真正游戏或者游戏开发的存在，这一次，好像真的要步入游戏开发了。 所以整理了一下。 具体概念和基本使用就不做介绍了，因为那些都太枯燥了，这里先说说整个环境搭建（以Mac为例），然后根据实际开发整理一些有意义的东西 先来看看官方http://docs.cocos.com/cocos2d-x/manual/zh/ 搭建开发环境 - iOS工具准备Cocos2d-x v3.17，下载后解压，下载参见：Cocos官网页面:http://www.cocos.com/download Xcode 9 下载后安装，下载参见：Apple官网页面;https://developer.apple.com/download/more/或者前往App Store下载 配置步骤： 打开 cocos2d-x-3.17/build/cocos2d_tests.xcodeproj 在 Xcode 顶部工具栏选择 cpp-tests iOS，iPhone 7 Plus，点击运行，项目将自动编译运行，效果如图： 如何调试(Debug) 点击代码行左侧的空白，设置断点 运行 cpp-tests 操作 App 触发断点，IDE 将卡在断点处，视图会自动变化，左侧导航栏可以查看运行堆栈，底部窗口可以查看变量的值： 这里严格来说，其实不算是环境搭建，而是下载引擎，运行官方demo而已，那么下面我们开始简单的搭建一个实际项目，并后续从零开始做一个真正的游戏 实际开发配置步骤：登录Cocos2d-x 的官网 http://www.cocos2d-x.org 点击download 下载最新的版本 点击超链接，将会下载得到一个Cocos2d-x-3.17.zip 压缩包 将下载的压缩包进行解压，打开得到的文件夹，其结构目录如下 build :多平台下的架构文件存放的目录 cocos 框架核心目录 里面存放了Cocos2d-x的核心代码。 docs：文档目录 可以使用该目录下的doxygen.config 文件创建离线文档 extensions:扩展目录 存放了一些官方的扩展 包括更多图形用户界面的控制功能 网络访问 CocosBuilder 等 external：存放扩展需要用到的物理引擎 包括box2d和chipmunk licenses: cocos2d依赖很多开源项目，所有的授权许可文件都在这个目录 plugin:plugin-x 项目目录，plugin -x 是一个可以快速接入第三方idk的框架 templates：该目录包括在不同集成环境及不同平台中创建Cocos2d-x 新项目的模板 test：测试项目 这是我们最开始用到的文件 在 cpp-tests 项目中包含所有类的用法 lua 和js 样本也在这个目录 tools： 需要用到的工具 Cocos2d-console 目录中包含了创建Cocos2d-x项目的脚本 可以针对不同的平台进行开发环境的搭建 同时 还包括将c++绑定至lua 及JavaScript 的脚本文件 Cocos2d-x的安装和配置Cocos2d-x 从2.1.4 版 之后已经不再支持使用模板来生成项目 而是使用官方提供的python 直接创建项目 也就是说Cocos2d-x 不能安装到Xcode上面，不能使用Xcode的Cocos2d-x模板一步一步的生成项目，只能使用Xcode来打开已经创建好的项目 创建项目的步骤如下： 打开终端 进入Cocos2d-x3.14 目录执行./setup.py 运行该文件用来 配置系统的一些环境变量 打开终端 执行Cocos new HelloCpp -p org.cocos2dx -l cpp -d codes 如果一切正常 则项目创建成功 关闭终端 再次进入Cocos2d-3.14目录这时候 会发现新建的codes目录 进入该目录发现新建的HelloCpp项目 进入proj.ios_mac 双击HelloCPP.xcodeproj 文件 使用快捷键（command+run）运行程序 就可以在iOS模拟器上看到经典的hello world 画面]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go基础</tag>
        <tag>cocos2dx初探</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang——groutine和channel底层机制]]></title>
    <url>%2F2018%2F06%2F12%2FGolang%E2%80%94%E2%80%94groutine%E5%92%8Cchannel%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[goroutine, channel其实可以认为是golang中runtime的一部分，当然golang的runtime还包含Garbage collection，内存分配，垃圾回收，interfaces, maps,slices等一些高级功能 并发 我们知道Golang系统默认支持原始并发(加入协程与管道)，不想其他语言一样，需要写一堆的代码，还没有几个能写好的。 Golang使用Groutine和channels实现了CSP(Communicating Sequential Processes)模型，channles负责goroutine通信。 goroutinuegoroutine是Golang实现的用户空间的轻量级的线程，有runtime调度器调度，与操作系统的thread有多对一的关系 goroutinue，本质上就是协程。但有两点不同： 1.goroutinue可以实现并行，多个协程可以在多个处理器同时跑。而协程同一时刻只能在一个处理器上跑（把宿主语言想象成单线程的就好了）。 2.goroutine之间的通信是通过channel，而协程的通信是通过yield和resume()操作。 goroutine schedulergoroutine scheduler 是Go runtime的一个重要的组成部分。他负责追踪，调度每个goroutine运行，实际上是从应用程序的process所属的thread pool中分配一个thread来执行这个goroutine。因此，和java虚拟机中的Java thread和OS thread映射概念类似，每个goroutine只有分配到一个OS thread才能运行。 ChanelChannel是Go中的一个核心类型，你可以把它看成一个管道，通过它并发核心单元就可以发送或者接收数据进行通讯(communication) 初始化 ch := make(chan Task, 3) // hchan（src/runtime/chan.go） 创建channel时在该进程的heap申请一块内存，创建一个hchan结构体，返回执行该内存的指针(ch变量本身是一个指针，在函数间传递的时候是同一个channel) channel使用一个唤醒队列保存groutine之间传递的数据，使用两个list保存goroutine(向该chan发生数据，从该chan接受数据),还有一个mutex保证操作安全 模型M是操作系统的线程，G是用户启动的goroutine，P是与调度相关的context，每个M都拥有一个P，P维护了一个能够运行的goutine队列，用于该线程执行。 发生接受数据向channel发送和从channel接收数据主要涉及hchan里的四个成员变量 buf(指向dataqsiz元素的数组)，sendx，recvx，lock(锁定保护HCHA中的所有字段) 初始化的时候hchan中buf为空，sendx，recvx为0： 向chan发生数据的时候，会对buf加锁，然后将要发生的数据copy到buf中，并sendx+1，最后释放buf的锁。 从chan接受数据的时候，会对buf加锁，然后将buf里面的数据copy到变量对应的内存，并recvx+1，最后释放buf的锁。 底层通过hchan中的buf，使用copy内存的方式通讯，达到共享内存目的 阻塞 当想已满的chan发生数据，runtime检测到对应的hchan已经满了，会通知调度器，调度器将发送至置为waiting，移除与线程M的关系，然后从P的runqueue中选择一个goroutine在线程M中执行，此时发送者处于阻塞状态，但是操作系统线程非阻塞，所以只消耗少量资源。 发送者阻塞后会创建一个自己的结构体sudog，然后放到sendq(发送阻塞列表：保存channel相关变量的指针，如发送或者接收数据的变量的地址&amp;copy) 从chan接收数据时，会通知调度器，将发送者状态设置为runnable，并且将其加入P的runqueue，等待线程执行 注意：如果接受者先运行，那么他会从一个空的chanl中取数据，这个时候会直接阻塞，通发送者阻塞一样，也会创建一个自己的结构体sudog，保存接收数据的变量的地址，但是该sudog不是放在recvq(接收阻塞列表)，当再想chan发送数据的时候，runtime辟谷没有对hchan中buf加锁，而是直接将发送的数据copy到接收者的结构体sudog对应的elem指向的内存地址 Runtimegoroutine, channel其实可以认为是golang中runtime的一部分，当然golang的runtime还包含Garbage collection，内存分配，垃圾回收，interfaces, maps,slices等一些高级功能 1.4之前，runtime还是由C语言所编写的，官方计划，1.5版本将去除C的代码，runtime将完全由Go语言来完成，不论何种方式，runtime和用户编译后的代码被linker静态链接起来，形成一个可执行文件。这个文件从操作系统角度来说是一个user space的独立的可执行文件。 从运行的角度来说，这个文件由2部分组成，一部分是用户的代码，另一部分就是runtime。runtime通过接口函数调用来管理goroutine, channel及其他一些高级的功能。从用户代码发起的调用操作系统API的调用都会被runtime拦截并处理。 总结： goroutine的调度器是在线程之上的多路复用。channel的实现是仅仅的关联在调度器之上，compiler也是紧密的和goroutine调度器关联在一起，不仅仅创建goroutine，而且也管理着stack，防止stack溢出。goroutine是一个执行的stack+一个控制的struct。调度器分配goroutine在线程上执行，当一个线程阻塞了或者调用一个非Go的函数(CGO调用)，那么调度器就会开始一个新的线程来运行其他的goroutine. 推荐文章 https://blog.csdn.net/whatday/article/details/74453089 https://blog.csdn.net/kongdefei5000/article/details/75209005 https://www.zhihu.com/question/20862617]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go基础</tag>
        <tag>groutine和channel底层机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang——Http服务初探]]></title>
    <url>%2F2018%2F06%2F07%2FGolang%E2%80%94%E2%80%94Http%E6%9C%8D%E5%8A%A1%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[这里开始之前，先来说说golang中http服务的内部机制(所有其他库都是在此基础延伸) 这里开始之前，先来说说golang中http服务中三个重要的方法(所有其他库都是在此基础延伸) func Handle func Handle(pattern string, handler Handler) Handle registers the handler for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched. func HandleFunc func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched. func ListenAndServe func ListenAndServe(addr string, handler Handler) error ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Handler is typically nil, in which case the DefaultServeMux is used. 注意： ListenAndServe是用于在指定的TCP 网络地址addr 进行监听，然后调用服务端处理程序来处理传入的连接请求。该方法有两个参数：第一个参数addr 即监听地址；第二个参数表示服务端处理程序，通常为空，这意味着服务端调用 http.DefaultServeMux 进行处理，而服务端编写的业务逻辑处理程序 http.Handle() 或 http.HandleFunc() 默认注入 http.DefaultServeMux 中 下面以三种不同的方式实现最Golang中基本的Http Server 默认方式 默认handler，处理路由注册 //===================================Http 1===================================// func Http_Server1() { http.HandleFunc(&quot;/&quot;, sayServer1) err := http.ListenAndServe(&quot;:8080&quot;, nil) if err != nil { panic(err) } } func sayServer1(w http.ResponseWriter, r *http.Request) { io.WriteString(w,&quot;sayServer1 Http Service&quot;) } 自定义方式自己实现hander，注册到max中，在注册路由 //===================================Http 2===================================// func Http_Server2() { mux := http.NewServeMux() mux.Handle(&quot;/&quot;, &amp;myHanlder{}) mux.HandleFunc(&quot;/hello&quot;, sayServer2) err := http.ListenAndServe(&quot;:8080&quot;, mux) if err != nil { panic(err) } } type myHanlder struct{} func (*myHanlder) ServeHTTP(w http.ResponseWriter, r *http.Request) { io.WriteString(w,&quot;Http Service: &quot;+ r.URL.String()) } func sayServer2(w http.ResponseWriter, r *http.Request) { io.WriteString(w,&quot;sayServer2 Http Service&quot;) } 底层拓展方式底层实现路由注册，多用户封装 //===================================Http 3===================================// var mux map[string]func(http.ResponseWriter, *http.Request) // 路由指定 func Http_Server3() { server := http.Server{ Addr:&quot;:8080&quot;, Handler:&amp;mHandler{}, ReadTimeout:5*time.Second, } 注册 mux = make(map[string]func(http.ResponseWriter, *http.Request)) mux[&quot;/hello&quot;] = sayServer3 mux[&quot;/golang&quot;] = golang err := server.ListenAndServe() if err != nil { panic(err) } } type mHandler struct {} func (*mHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) { if h,ok := mux[r.URL.String()]; ok { h(w,r) return } io.WriteString(w,&quot;Http Service Custome: &quot;+ r.URL.String()) } func sayServer3(w http.ResponseWriter, r *http.Request) { io.WriteString(w,&quot;sayServer3 Http Service&quot;) } func golang(w http.ResponseWriter, r *http.Request) { io.WriteString(w,&quot;golang Http Service&quot;) } Beego你好世界其实上面只是作为个简单的入门了解，一般实际开发中，那么做的还是不多，我们大部分都会选择使用第三方，比如PHP中的ThinkPHP，Yii，在Golang中也有几个不错的第三个可以使用，而且目前已经很成熟了，至少可以满足目前几乎大部分公司的业务需求比如beego(国人开发)，gin，dotweb，echo这些都是笔者通过技术群或者网络热门程度了解到在Golang中还不错的的库，而且使用中和非常多。 这里我简单以beego作为案例尝试下，没有什么技术含量，勿喷 下载安装(前提：配置GOPATH)go get github.com/astaxie/beego 创建文件 hello.go//================================Hello World!!===============================// package main import &quot;github.com/astaxie/beego&quot; type HomeController struct { beego.Controller } func (this *HomeController) Get() { this.Ctx.WriteString(&quot;Hello World!!&quot;) } func Http_Hello() { beego.Router(&quot;/&quot;, &amp;HomeController{}) beego.Run() } 编译运行go build -o hello hello.go ./hello 浏览效果打开浏览器并访问 http://localhost:8080 关闭http服务在go1.8中新增了一个新特性，利用Shutdown(ctx context.Context) 优雅地关闭http服务。 Shutdown 将无中断的关闭正在活跃的连接，然后平滑的停止服务。处理流程如下： 首先关闭所有的监听; 然后关闭所有的空闲连接; 然后无限期等待连接处理完毕转为空闲，并关闭; 如果提供了 带有超时的Context，将在服务关闭前返回 Context的超时错误; 利用这个特性改造一下v3版本的程序，实现一个关闭http的提示 // 主动关闭服务器 var server *http.Server func main() { // 一个通知退出的chan quit := make(chan os.Signal) signal.Notify(quit, os.Interrupt) mux := http.NewServeMux() mux.Handle(&quot;/&quot;, &amp;myHandler{}) mux.HandleFunc(&quot;/bye&quot;, sayBye) server = &amp;http.Server{ Addr: &quot;:1210&quot;, WriteTimeout: time.Second * 4, Handler: mux, } go func() { // 接收退出信号 &lt;-quit if err := server.Close(); err != nil { log.Fatal(&quot;Close server:&quot;, err) } }() log.Println(&quot;Starting v3 httpserver&quot;) err := server.ListenAndServe() if err != nil { // 正常退出 if err == http.ErrServerClosed { log.Fatal(&quot;Server closed under request&quot;) } else { log.Fatal(&quot;Server closed unexpected&quot;, err) } } log.Fatal(&quot;Server exited&quot;) } type myHandler struct{} func (*myHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) { w.Write([]byte(&quot;this is version 3&quot;)) } // 关闭http func sayBye(w http.ResponseWriter, r *http.Request) { w.Write([]byte(&quot;bye bye ,shutdown the server&quot;)) // 没有输出 err := server.Shutdown(nil) if err != nil { log.([]byte(&quot;shutdown the server err&quot;)) } } 尝试访问http://localhost:1210/bye 在控制台会得到以下提示结果，平滑关闭http服务成功: https://www.jianshu.com/p/be3d9cdc680b]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go基础</tag>
        <tag>Http服务初探</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang——文件IO处理]]></title>
    <url>%2F2018%2F06%2F03%2FGolang%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6IO%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[读写文件应该是在开发过程中经常遇到的，今天要跟大家一起分享的就是在golang的世界中，如何读写文件 读写文件应该是在开发过程中经常遇到的，今天简单看看golang的世界中，如何读写文件。 读取文件方法速度比较package main import ( &quot;bufio&quot; &quot;fmt&quot; &quot;io&quot; &quot;io/ioutil&quot; &quot;os&quot; &quot;time&quot; ) func read0(path string) string { f, err := ioutil.ReadFile(path) if err != nil { fmt.Printf(&quot;%s\n&quot;, err) panic(err) } return string(f) } func read1(path string) string { fi, err := os.Open(path) if err != nil { panic(err) } defer fi.Close() chunks := make([]byte, 1024, 1024) buf := make([]byte, 1024) for { n, err := fi.Read(buf) if err != nil &amp;&amp; err != io.EOF { panic(err) } if 0 == n { break } chunks = append(chunks, buf[:n]...) } return string(chunks) } func read2(path string) string { fi, err := os.Open(path) if err != nil { panic(err) } defer fi.Close() r := bufio.NewReader(fi) chunks := make([]byte, 1024, 1024) buf := make([]byte, 1024) for { n, err := r.Read(buf) if err != nil &amp;&amp; err != io.EOF { panic(err) } if 0 == n { break } chunks = append(chunks, buf[:n]...) } return string(chunks) } func read3(path string) string { fi, err := os.Open(path) if err != nil { panic(err) } defer fi.Close() fd, err := ioutil.ReadAll(fi) return string(fd) } func main() { file := &quot;test.log&quot; start := time.Now() read0(file) t0 := time.Now() fmt.Printf(&quot;Cost time %v\n&quot;, t0.Sub(start)) read1(file) t1 := time.Now() fmt.Printf(&quot;Cost time %v\n&quot;, t1.Sub(t0)) read2(file) t2 := time.Now() fmt.Printf(&quot;Cost time %v\n&quot;, t2.Sub(t1)) read3(file) t3 := time.Now() fmt.Printf(&quot;Cost time %v\n&quot;, t3.Sub(t2)) } 运行结果对比： Cost time 4.0105ms Cost time 11.5043ms Cost time 7.0042ms Cost time 2.4983ms Cost time 4.4925ms Cost time 11.0053ms Cost time 5.0082ms Cost time 2.9992ms Cost time 3.9866ms Cost time 15.0085ms Cost time 7.5054ms Cost time 2.5035ms Cost time 4.9989ms Cost time 14.0112ms Cost time 7.5045ms Cost time 3.508ms Cost time 3.0043ms Cost time 15.0265ms Cost time 8.9884ms Cost time 2.0036ms 静态文件//=================================== Files ===================================// func File_Server() { mux := http.NewServeMux() mux.Handle(&quot;/&quot;, &amp;fileHanlder{}) mux.HandleFunc(&quot;/hello&quot;, sayServer2) wd, err := os.Getwd() if err != nil { panic(err) } mux.Handle(&quot;/static/&quot;, http.StripPrefix(&quot;/static/&quot;, http.FileServer(http.Dir(wd)))) err = http.ListenAndServe(&quot;:8080&quot;, mux) if err != nil { panic(err) } } type fileHanlder struct{} func (*fileHanlder) ServeHTTP(w http.ResponseWriter, r *http.Request) { io.WriteString(w,&quot;Http Service: &quot;+ r.URL.String()) } func sayServer2(w http.ResponseWriter, r *http.Request) { io.WriteString(w,&quot;sayServer2 Http Service&quot;) }]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go基础</tag>
        <tag>文件操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go——Golang Response Snippets]]></title>
    <url>%2F2018%2F06%2F01%2FGo%E2%80%94%E2%80%94Golang-Response-Snippets%2F</url>
    <content type="text"><![CDATA[做过后端开发的应该都知道，我们遇到最多的就是返回数据给客户端，就和客户端要搭界面一样，重复操作着，但是却有必不可少，今天我们来简单说说Golang Response Snippets Golang Response Snippets: JSON, XML and more Taking inspiration from the Rails layouts and rendering guide, I thought it’d be a nice idea to build a snippet collection illustrating some common HTTP responses for Go web applications. Golang Response Snippets 只返回header对于一些请求而言，不需要返回任何的数据，只是返回一个header即可，大大提高了返回服务器响应速度。 先了解一下net/http包中的几个方法： //给一个key设定为响应的value. func (h Header) Set(key, value string) // WriteHeader该方法发送HTTP回复的头域和状态码。如果没有被显式调用，第一次调用Write时会触发隐式调用WriteHeader(http.StatusOK)。因此，显示调用WriterHeader主要用于发送错误状态码。 WriteHeader(int) 在使用的时候，我们可以这么做 package main import ( &quot;net/http&quot; ) func main() { http.HandleFunc(&quot;/&quot;, foo) http.ListenAndServe(&quot;:8080&quot;, nil) } func foo(w http.ResponseWriter, r *http.Request) { w.Header().Set(&quot;Server&quot;, &quot;A Go Web Server&quot;) w.WriteHeader(200) } 通过curl进行请求：curl -i localhost:8080curl -i localhost:8080 HTTP/1.1 200 OK Server: A Go Web Server Date: Mon, 29 Jan 2018 02:52:41 GMT Content-Length: 0 Content-Type: text/plain; charset=utf-8 返回文本这个不常用，但是也介绍一下而已。 用到的方法： // Write向连接中写入数据，该数据作为HTTP response的一部分。如果被调用时还没有调用WriteHeader，本方法会先调用 WriteHeader(http.StatusOK)。 //如果Header中没有&quot;Content-Type&quot;键，本方法会使用包函数DetectContentType检查数据的前512字节，将返回值作为该键的值 Write([]byte) (int, error) 返回文本实际使用方法package main import ( &quot;net/http&quot; ) func main() { http.HandleFunc(&quot;/&quot;, foo) http.ListenAndServe(&quot;:8080&quot;, nil) } func foo(w http.ResponseWriter, r *http.Request) { w.Write([]byte(&quot;I am Gopher&quot;)) } 通过curl进行请求：curl -i localhost:8080curl -i localhost:8080 HTTP/1.1 200 OK Date: Mon, 29 Jan 2018 03:02:00 GMT Content-Length: 11 Content-Type: text/plain; charset=utf-8 I am Gopher 返回JSONGo语言里的标准库”encoding/json” 转换对应表： bool类型 转换成JSON中的boolean 整型，浮点型转换成JSON中的Number 字符串转换成JSON中的字符串（&quot;&quot;而不是&apos;&apos;） 结构体转换成JSON中的Object []byte 会先base64然后转换成JSON中的字符串（&quot;&quot;而不是&apos;&apos;） map 转换成JSON中的Object interface{} 会按内部的类型进行实际转换 nil 会转换成JSON中的Null encodeing/json几乎常用的就两个方法： func Marshal(v interface{}) ([]byte, error) func Unmarshal(data []byte, v interface{}) error 顾名思义“Marshal”将Go对象进行转换成JSON，而”Unmarshal”则是将JSON转换成Go对象。 package main import ( &quot;encoding/json&quot; &quot;net/http&quot; ) // 为了对应关系可以一一对应上，我们需要手动的为结构体打上Tag，才能转换到正确的JSON // structTag还有一些其他有用的属性，比如： // omitempty 如果JSON字段为空则忽略 // - 直接忽略 type Profile struct { Name string `json:&quot;name&quot;` Hobbies []string `json:&quot;hobbies&quot;` } func main() { http.HandleFunc(&quot;/&quot;, foo) http.ListenAndServe(&quot;:8080&quot;, nil) } func foo(w http.ResponseWriter, r *http.Request) { profile := Profile{&quot;SuperWang&quot;, []string{&quot;football&quot;, &quot;programming&quot;}} js, err := json.Marshal(profile) if err != nil { http.Error(w, err.Error(), http.StatusInternalServerError) return } w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;) w.Write(js) } 有时候你想更灵活的使用JSON，这个时候就要用到json.RawMessage，多数情况下，我们不会使用到它。在JSON中，有一个字段的格式是未知的，比如可能是string，也可能是int，那么这个时候就要用到*json.RawMessage了。 不过在转换的过程中，如果我们定义的是结构体，跟Map会有一些不同，以下几点是要注意的： 结构体的成员必须是大写开头 使用Marshal时会按结构体成员的变量名做为Key Unmarshal时会自动匹配结构体成员，大小写不敏感，如果JSON中有多余字段，会直接抛弃，如果缺少某个字段，则会忽略对结构体成员赋值 通过curl进行请求：curl -i localhost:8080curl -i localhost:8080 HTTP/1.1 200 OK Content-Type: application/json Date: Mon, 29 Jan 2018 03:10:52 GMT Content-Length: 57 {&quot;name&quot;:&quot;SuperWang&quot;,&quot;hobbies&quot;:[&quot;football&quot;,&quot;programming&quot;]} 返回XML很久之前，很多人讨论xml和json孰是孰非，渐渐地xml越来越被人们遗忘。但是一些接口还是需要使用xml的，比如xmpp协议。 package main import ( &quot;encoding/xml&quot; &quot;net/http&quot; ) type Profile struct { Name string Hobbies []string `xml:&quot;Hobbies&gt;Hobby&quot;` } func main() { http.HandleFunc(&quot;/&quot;, foo) http.ListenAndServe(&quot;:8080&quot;, nil) } func foo(w http.ResponseWriter, r *http.Request) { profile := Profile{&quot;SuperWang&quot;, []string{&quot;football&quot;, &quot;programming&quot;}} x, err := xml.MarshalIndent(profile, &quot;&quot;, &quot; &quot;) if err != nil { http.Error(w, err.Error(), http.StatusInternalServerError) return } w.Header().Set(&quot;Content-Type&quot;, &quot;application/xml&quot;) w.Write(x) } 通过curl进行请求：curl -i localhost:8080 curl -i localhost:8080 HTTP/1.1 200 OK Content-Type: application/xml Date: Mon, 29 Jan 2018 03:16:00 GMT Content-Length: 129 &lt;Profile&gt; &lt;Name&gt;SuperWang&lt;/Name&gt; &lt;Hobbies&gt; &lt;Hobby&gt;football&lt;/Hobby&gt; &lt;Hobby&gt;programming&lt;/Hobby&gt; &lt;/Hobbies&gt; &lt;/Profile&gt; 返回文件通过接口，返回一张图片，一个文本文件等等，都是很常见的。 package main import ( &quot;net/http&quot; &quot;path&quot; ) func main() { http.HandleFunc(&quot;/&quot;, foo) http.ListenAndServe(&quot;:8080&quot;, nil) } func foo(w http.ResponseWriter, r *http.Request) { fp := path.Join(&quot;images&quot;, &quot;foo.png&quot;) http.ServeFile(w, r, fp) } 建一个images文件夹，放入foo.png文件，运行， 运行，浏览器输入： http://localhost:8080/ 返回HTML下面是返回一个HTML的网页。 package main import ( &quot;html/template&quot; &quot;net/http&quot; &quot;path&quot; ) type Profile struct { Name string Hobbies []string } func main() { http.HandleFunc(&quot;/&quot;, foo) http.ListenAndServe(&quot;:8080&quot;, nil) } func foo(w http.ResponseWriter, r *http.Request) { profile := Profile{&quot;SpuerWang&quot;, []string{&quot;snowboarding&quot;, &quot;programming&quot;}} fp := path.Join(&quot;templates&quot;, &quot;index.html&quot;) tmpl, err := template.ParseFiles(fp) if err != nil { http.Error(w, err.Error(), http.StatusInternalServerError) return } if err := tmpl.Execute(w, profile); err != nil { http.Error(w, err.Error(), http.StatusInternalServerError) } } 新建文件夹templates，在里面新建文件inde.html: &lt;h1&gt;Title {{ .Name }}&lt;/h1&gt; &lt;p&gt;.....&lt;/p&gt; 运行，浏览器输入： http://localhost:8080/]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go基础</tag>
        <tag>Response</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go——简单说说goroutine和channel]]></title>
    <url>%2F2018%2F05%2F29%2FGo%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E8%AF%B4%E8%AF%B4goroutine%E5%92%8Cchannel%2F</url>
    <content type="text"><![CDATA[Go 语言中的 channel 是实现 goroutine 间无锁通信的关键机制，他使得写多线程并发程序变得简单、灵活、触手可得，今天我们来简单说说goroutine和channel 引言： Go 语言中的 channel 是实现 goroutine 间无锁通信的关键机制，他使得写多线程并发程序变得简单、灵活、触手可得 channel是消息传递的机制，用于多线程环境下lock free synchronization. 它同时具备2个特性： 消息传递 同步 参考文章： https://blog.csdn.net/kongdefei5000/article/details/75209005 https://blog.csdn.net/nobugtodebug/article/details/45396507 channel channel 分类： 不带缓存 channel， 带缓存 channel 无缓冲的与有缓冲channel有着重大差别，那就是一个是同步的 一个是非同步的。 c1:=make(chan int) 无缓冲 c2:=make(chan int,1) 有缓冲 c1&lt;-1 无缓冲： 不仅仅是向 c1 通道放 1，而是一直要等有别的携程 &lt;-c1 接手了这个参数，那么c1&lt;-1才会继续下去，要不然就一直阻塞着。 有缓冲： c2&lt;-1 则不会阻塞，因为缓冲大小是1(其实是缓冲大小为0)，只有当放第二个值的时候，第一个还没被人拿走，这时候才会阻塞。 不带缓存 channel（a）创建channel make(chan type) e.g. ch := make(chan int) （b）通信方式(由于chan操作类似于Queue，为便于理解这里用EnQueue,DeQueue来描述通信操作) EnQueue: ch &lt;- typevar DeQueue: var := &lt;- ch e.g. ch &lt;- 1 v := &lt;-ch 关键： 调用channel EnQueue 操作之后被阻塞住（不管channel是否为空），直到写的数据被读取掉。 调用channel DeQueue 操作时，如果channel中有数据则被读出，如果为空则阻塞住，直到有人往里面EnQueue数据。 带缓存 channel（a）创建channel make(chan type, size) e.g. ch := make(chan int, 9) （b）通信方式 同不带缓存channel 关键： 当channel中元素小于等于channel size时，调用channel EnQueue 操作后数据被放入到缓存中（非阻塞）； 当channel满以后，如果再调用EnQueue操作就会被阻塞住直到有元素被DeQueue出来。 调用channel DeQueue 操作时，如果channel 为空则阻塞住直到有人往里面EnQueue数据，否则直接DeQueue出元素。 注意: 需要特别注意的是两者对于range操作的区别： 无缓存channel是EnQueue一个数据被range读一个； 而带缓存channel是EnQueue满之后被range整个一起拿出来用(这个机制对于用户是透明的，用户看到的还是一个一个拿出来)，或者timeout时间到之后即使channel没有满也会被range拿出来。 另外，channel 关闭之后，循环读channel操作(e.g. for v:=range channel) 读完channel中剩余数据会自动跳出循环。 参考网络介绍： 顾名思义，就是通道。通道的目的是用来传递数据。在一个通道上我们可以执行数据的发送(Send)和接受(Receive)操作。对于非缓冲的 channel 而言，Receive 方法执行时，会判断该通道上是否有值，如果没有就会等待(阻塞)，直到有一个值为止。同样，在 channel 上有值，而尚未被一个 Receiver 接受的时候，Send 方法也会阻塞，直到 Channel 变空。这样，通过一个简单的机制就可以保证 Send 和 Receive 总是在不同的时间执行的，而且只有 Send 之后才能 Receive. 这样就避免了常规的多线程编程中数据共享的问题。正如 Go 语言的文档一句话所说： Do not communicate by sharing memory; instead, share memory by communicating. 不要通过共享内存来沟通;而是通过沟通来共享内存。 在常规的多线程编程里，我们总是定义好一些类变量，如果这些变量有可能被多个线程同时访问，那么就需要加锁。这样带来了一定的编程复杂性，如果代码写的稍有bug，则会导致读/写到错误的值。 而通过 channel 来沟通，我们得到了一个更为清晰的沟通方式。两个线程(或者 goroutine)要读写相同的数据，则创建一个通道，双方通过对这个通道执行 Send / Receive 的操作来设值或取值即可，相对而言，比较不容易出错。 goroutine goroutine的并发模型定义为以下几个要点： 基于Thread的轻量级协程 通过channel来进行协程间的消息传递 只暴露协程，屏蔽线程操作的接口 goroutine原理 Golang的runtime实现了goroutine和OS thread的M:N模型，因此实际的goroutine是基于线程的更加轻量级的实现，我们便可以在Golang中大量创建goroutine而不用担心昂贵的context swtich所带来的开销。goroutine之间，我们可以通过channel来进行交互。由于go已将将所有system call都wrap到了标准库中，在针对这些systemcall进行调用时会主动标记goroutine为阻塞状态并保存现场，交由scheduler执行。所以在golang中，在大部分情况下我们可以非常安心地在goroutine中使用阻塞操作而不用担心并发性受到影响。 在操作系统的OS Thread和编程语言的User Thread之间，实际上存在3中线程对应模型，也就是：1:1，1:N，M:N。 N:1是说，多个（N）用户线程始终在一个内核线程上跑，context上下文切换确实很快，但是无法真正的利用多核。 1:1是说，一个用户线程就只在一个内核线程上跑，这时可以利用多核，但是上下文switch很慢，频繁切换效率很低。 M:N是说， 多个goroutine在多个内核线程上跑，这个看似可以集齐上面两者的优势，但是无疑增加了调度的难度。 goroutine google runtime默认的实现为M:N的模型，于是这样可以根据具体的操作类型（操作系统阻塞或非阻塞操作）调整goroutine和OS Thread的映射情况，显得更加的灵活。 在goroutine实现中，有三个最重要的数据结构，分别为G M P：G：代表一个goroutine M：代表 一个OS Thread P：一个P和一个M进行绑定，代表在这个OS Thread上的调度器 goroutine - 可以大致理解为一种轻量级的线程(或微线程)，它是一种“分配在同一个地址空间内的，能够并行执行的函数”。同时，它是轻量级的，不需要像分配线程那样分配独立的栈空间。所以理论上讲，我们可以很容易的分配很多个 goroutine, 让它们并发执行，而其开销则比多线程程序要小得多，从而可以让程序支持比较大的并发性。 goroutinue，本质上就是协程。但有两点不同： goroutinue可以实现并行，也就是说，多个协程可以在多个处理器同时跑。而协程同一时刻只能在一个处理器上跑（把宿主语言想象成单线程的就好了）。 goroutine之间的通信是通过channel，而协程的通信是通过yield和resume()操作。 那么如果有两个A,B两个协程 在放入和取出数据时都只能用int类型的数据进行通信 如 取数据 &lt;- channel 放数据 channel &lt;- 1 协程之间可以通过在通道中放入-取出数据的方式进行通信 3种优雅的Go channel用法写Go的人应该都听过Rob Pike的这句话 Do not communicate by sharing memory; instead, share memory by communicating. 相信很多朋友和我一样，在实际应用中总感觉不到好处，为了用channel而用。但以我的切身体会来说，这是写代码时碰到的场景不复杂、对channel不熟悉导致的，所以希望这篇文章能给大家带来点新思路，对Golang优雅的channel有更深的认识 ：） Fan In/Out数据的输出有时候需要做扇出／入（FanIn／Out），但是在函数中调用常常得修改接口，而且上下游对于数据的依赖程度非常高，所以一般使用通过channel进行Fan In／Out，这样就可以轻易实现类似于shell里的管道。 func fanIn(input1, input2 &lt;-chan string) &lt;-chan string { c := make(chan string) go func() { for { select { case s := &lt;-input1: c &lt;- s case s := &lt;-input2: c &lt;- s } } }() return c } 同步Goroutine两个goroutine之间同步状态，例如A goroutine需要让B goroutine退出，一般做法如下： func main() { g = make(chan int) quit = make(chan bool) go B() for i := 0; i &lt; 3; i++ { g &lt;- i } quit &lt;- true // 没办法等待B的退出只能Sleep fmt.Println(&quot;Main quit&quot;) } func B() { for { select { case i := &lt;-g: fmt.Println(i + 1) case &lt;-quit: fmt.Println(&quot;B quit&quot;) return } } } Log/* Output: 1 2 3 Main quit */ 可是了main函数没办法等待B合适地退出，所以B quit 没办法打印，程序直接退出了。然而，chan是Go里的第一对象，所以可以把chan传入chan中，所以上面的代码可以把quit 定义为chan chan bool，以此控制两个goroutine的同步 func main() { g = make(chan int) quit = make(chan chan bool) go B() for i := 0; i &lt; 5; i++ { g &lt;- i } wait := make(chan bool) quit &lt;- wait &lt;-wait //这样就可以等待B的退出了 fmt.Println(&quot;Main Quit&quot;) } func B() { for { select { case i := &lt;-g: fmt.Println(i + 1) case c := &lt;-quit: c &lt;- true fmt.Println(&quot;B Quit&quot;) return } } } Log/* Output 1 2 3 B Quit Main Quit */ 分布式递归调用在现实生活中，如果你要找美国总统聊天，你会怎么做？第一步打电话给在美国的朋友，然后他们也会发动自己的关系网，再找可能认识美国总统的人，以此类推，直到找到为止。这在Kadmelia分布式系统中也是一样的，如果需要获取目标ID信息，那么就不停地查询，被查询节点就算没有相关信息，也会返回它觉得最近节点，直到找到ID或者等待超时。 好了，这个要用Go来实现怎么做呢？ func recursiveCall(ctx context.Context, id []byte, initialNodes []*node){ seen := map[string]*node{} //已见过的节点记录 request := make(chan *node, 3) //设置请求节点channel // 输入初始节点 go func() { for _, n := range initialNodes { request &lt;- n } }() OUT: for { //循环直到找到数据 if data != nil { return } // 在新的请求，超时和上层取消请求中select select { case n := &lt;-request: go func() { // 发送新的请求 response := s.sendQuery(ctx, n, MethodFindValue, id) select { case &lt;-ctx.Done(): case msg :=&lt;-response: seen[responseToNode(response)] = n //更新已见过的节点信息 // 加载新的节点 for _, rn := range LoadNodeInfoFromByte(msg[PayLoadStart:]) { mu.Lock() _, ok := seen[rn.HexID()] mu.Unlock() // 见过了，跳过这个节点 if ok { continue } AddNode(rn) // 将新的节点送入channel request &lt;- rn } } } }() case &lt;-time.After(500 * time.Millisecond): break OUT // break至外层，否则仅仅是跳至loop外 case &lt;-ctx.Done(): break OUT } } return } 这时的buffered channel类似于一个局部queue，对需要的节点进行处理，但这段代码的精妙之处在于，这里的block操作是select的，随时可以取消，而不是要等待或者对queue的长度有认识。]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go基础</tag>
        <tag>goroutine和channel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go——函数与方法的奇妙之处]]></title>
    <url>%2F2018%2F05%2F25%2FGo%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E4%B8%8E%E6%96%B9%E6%B3%95%E7%9A%84%E5%A5%87%E5%A6%99%E4%B9%8B%E5%A4%84%2F</url>
    <content type="text"><![CDATA[有过（面向对象）编程经验的应该都知道方法或者函数，比如在C，PHP，swift，OC，Java，kotlin等都有函数或者方法的存在，或者有二者的存在，只是有些人没有太过留意，比如PHP中就有这样的现象，而iOS中除了存在方法和行数，方法还分类方法和对象方法。 有过（面向对象）编程经验的应该都知道方法或者函数，比如在C，PHP，swift，OC，Java，kotlin等都有函数或者方法的存在，或者有二者的存在，只是有些人没有太过留意，比如PHP中就有这样的现象，而iOS中除了存在方法和行数，方法还分类方法和对象方法。 那么Golang中方法和行数的本质意义其实差不多，只是定义和使用的语法不同而已。 这里我们就来说说Golang中函数与方法， 函数：行数定义func function_name( [parameter list] ) [return_types]{ body of the function } 不允许函数内嵌定义func main() { func swap(x, y string) (string, string) { return y, x } } 支持多返回值、支持命名返回值func split(sum int) (x, y int) { return } 函数只能判断是否为nilfmt.Println(add == nil) //fmt.Println(add == 1) //错误 mismatched types func(int, int) int and int) 参数视为局部变量，因此不能声明同名变量func add(a, b int) int { a := 2 } 不支持默认参数、已”_”命名的参赛也不能忽略func add(a, b int, _ bool) int { return a + b } func main() { fmt.Println(add(1,2, true)) //fmt.Println(add(1,2) // 错误：not enough arguments in call to add } 支持可变参数func test(str string, a ...int) { fmt.Println(&quot;%T, %v\n&quot;, str, a) } func main() { test(&quot;a&quot;, 1, 2, 3) } 可以在函数内定义匿名函数func main() { func (s string) { fmt.Println(s) } (&quot;hello, go!&quot;) } 闭包// This function `intSeq` returns another function, which // we define anonymously in the body of `intSeq`. The // returned function _closes over_ the variable `i` to // form a closure. func intSeq() func() int { i := 0 return func() int { i += 1 return i } } func main() { // We call `intSeq`, assigning the result (a function) // to `nextInt`. This function value captures its // own `i` value, which will be updated each time // we call `nextInt`. nextInt := intSeq() // See the effect of the closure by calling `nextInt` // a few times. fmt.Println(nextInt()) fmt.Println(nextInt()) fmt.Println(nextInt()) // To confirm that the state is unique to that // particular function, create and test a new one. newInts := intSeq() fmt.Println(newInts()) } 注意 函数的左花括号也不能另起一行 不支持函数重载 方法：方法定义func (r Recevier) function_name(){ body of the method } 定义和使用：type Vertex struct { X, Y float64 } func (v Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } func main() { v := Vertex{3, 4} fmt.Println(v.Abs()) } 下面来仔细看看官方对方法给出的一个例子package main import &quot;fmt&quot; type rect struct { width, height int } // This `area` method has a _receiver type_ of `*rect`. func (r *rect) area() int { return r.width * r.height } // Methods can be defined for either pointer or value // receiver types. Here&apos;s an example of a value receiver. func (r rect) perim() int { return 2*r.width + 2*r.height } func main() { r := rect{width: 10, height: 5} // Here we call the 2 methods defined for our struct. fmt.Println(&quot;area: &quot;, r.area()) fmt.Println(&quot;perim:&quot;, r.perim()) // Go automatically handles conversion between values // and pointers for method calls. You may want to use // a pointer receiver type to avoid copying on method // calls or to allow the method to mutate the // receiving struct. rp := &amp;r fmt.Println(&quot;area: &quot;, rp.area()) fmt.Println(&quot;perim:&quot;, rp.perim()) } 其实是利用方法求长方形的周长和面积，其中也给出了receiver作为指针和值的区别 这里也简单说下：什么时候receiver用指针 1 改变receiver的值 2 struct本身非常的大，这样拷贝的代价是很昂贵的 3 如果struct的一个method中receiver为指针，那么其他的method的receiver最好也要用指针。 方法与函数的区别在golang的世界中，一定要区分 方法和函数。 Go中没有类的概念，但是我们可以在一些类型上定义一些方法，也就是所谓的方法，跟函数不同。 方法和函数定义语法区别在于： 方法是针对对象的（有些是针对类） 函数是针对全局的（Golang中指包）， 方法前置实例接受参数，这个receiver可以是基础类型也可以是指针。 虽然Go语言没有类的概念，但它支持的数据类型可以定义对应的method(s)。本质上说，所谓的method(s)其实就是函数，只不过与普通函数相比，这类函数是作用在某个数据类型上的，所以在函数签名中，会有个receiver(接收器)来表明当前定义的函数会作用在该receiver上。]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go基础</tag>
        <tag>函数与方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言中的Array、Slice、Map和Set]]></title>
    <url>%2F2018%2F05%2F22%2FGo%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84Array%E3%80%81Slice%E3%80%81Map%E5%92%8CSet%2F</url>
    <content type="text"><![CDATA[Go语言中和其他语言一样，存在数组，Map(iOS中的字典)，但是还有一个比较特殊的Slice，他其实底层还是数组，今天我们来简单说说Go语言中的Array、Slice、Map和Set Array(数组)内部机制 在 Go 语言中数组是固定长度的数据类型，它包含相同类型的连续的元素，这些元素可以是内建类型，像数字和字符串，也可以是结构类型，元素可以通过唯一的索引值访问，从 0 开始。 数组是很有价值的数据结构，因为它的内存分配是连续的，内存连续意味着可是让它在 CPU 缓存中待更久，所以迭代数组和移动元素都会非常迅速。 数组声明和初始化通过指定数据类型和元素个数(数组长度)来声明数组。 // 声明一个长度为5的整数数组 var array [5]int 一旦数组被声明了，那么它的数据类型跟长度都不能再被改变。如果你需要更多的元素，那么只能创建一个你想要长度的新的数组，然后把原有数组的元素拷贝过去。 Go 语言中任何变量被声明时，都会被默认初始化为各自类型对应的 0 值，数组当然也不例外。当一个数组被声明时，它里面包含的每个元素都会被初始化为 0 值。 一种快速创建和初始化数组的方法是使用数组字面值。数组字面值允许我们声明我们需要的元素个数并指定数据类型： // 声明一个长度为5的整数数组 // 初始化每个元素 array := [5]int{7, 77, 777, 7777, 77777} 如果你把长度写成 …，Go 编译器将会根据你的元素来推导出长度： // 通过初始化值的个数来推导出数组容量 array := [...]int{7, 77, 777, 7777, 77777} 如果我们知道想要数组的长度，但是希望对指定位置元素初始化，可以这样： // 声明一个长度为5的整数数组 // 为索引为1和2的位置指定元素初始化 // 剩余元素为0值 array := [5]int{1: 77, 2: 777} 使用数组使用 [] 操作符来访问数组元素： array := [5]int{7, 77, 777, 7777, 77777} // 改变索引为2的元素的值 array[2] = 1 我们可以定义一个指针数组： array := [5]*int{0: new(int), 1: new(int)} // 为索引为0和1的元素赋值 *array[0] = 7 *array[1] = 77 在 Go 语言中数组是一个值，所以可以用它来进行赋值操作。一个数组可以被赋值给任意相同类型的数组： var array1 [5]string array2 := [5]string{&quot;Red&quot;, &quot;Blue&quot;, &quot;Green&quot;, &quot;Yellow&quot;, &quot;Pink&quot;} array1 = array2 注意数组的类型同时包括数组的长度和可以被存储的元素类型，数组类型完全相同才可以互相赋值，比如下面这样就不可以： var array1 [4]string array2 := [5]string{&quot;Red&quot;, &quot;Blue&quot;, &quot;Green&quot;, &quot;Yellow&quot;, &quot;Pink&quot;} array1 = array2 // 编译器会报错 Compiler Error: cannot use array2 (type [5]string) as type [4]string in assignment 拷贝一个指针数组实际上是拷贝指针值，而不是指针指向的值： var array1 [3]*string array2 := [3]*string{new(string), new(string), new(string)} *array2[0] = &quot;Red&quot; *array2[1] = &quot;Blue&quot; *array2[2] = &quot;Green&quot; array1 = array2 // 赋值完成后，两组指针数组指向同一字符串 多维数组数组总是一维的，但是可以组合成多维的。多维数组通常用于有父子关系的数据或者是坐标系数据： // 声明一个二维数组 var array [4][2]int // 使用数组字面值声明并初始化 array := [4][2]int{{10, 11}, {20, 21}, {30, 31}, {40, 41}} // 指定外部数组索引位置初始化 array := [4][2]int{1: {20, 21}, 3: {40, 41}} // 同时指定内外部数组索引位置初始化 array := [4][2]int{1: {0: 20}, 3: {1: 41}} 同样通过 [] 操作符来访问数组元素： var array [2][2]int array[0][0] = 0 array[0][1] = 1 array[1][0] = 2 array[1][1] = 3 也同样的相同类型的多维数组可以相互赋值： var array1 = [2][2]int var array2 = [2][2]int array[0][0] = 0 array[0][1] = 1 array[1][0] = 2 array[1][1] = 3 array1 = array2 因为数组是值，我们可以拷贝单独的维： var array3 [2]int = array1[1] var value int = array1[1][0] 在函数中传递数组在函数中传递数组是非常昂贵的行为，因为在函数之间传递变量永远是传递值，所以如果变量是数组，那么意味着传递整个数组，即使它很大很大很大。。。 举个栗子，创建一个有百万元素的整形数组，在64位的机器上它需要8兆的内存空间，来看看我们声明它和传递它时发生了什么： var array [1e6]int foo(array) func foo(array [1e6]int) { ... } 每一次 foo 被调用，8兆内存将会被分配在栈上。一旦函数返回，会弹栈并释放内存，每次都需要8兆空间。 Go 语言当然不会这么傻，有更好的方法来在函数中传递数组，那就是传递指向数组的指针，这样每次只需要分配8字节内存： var array [1e6]int foo(&amp;array) func foo(array *[1e6]int){ ... } 但是注意如果你在函数中改变指针指向的值，那么原始数组的值也会被改变。幸运的是 slice(切片)可以帮我们处理好这些问题，来一起看看。 Slice(切片)内部机制和基础slice 是一种可以动态数组，可以按我们的希望增长和收缩。它的增长操作很容易使用，因为有内建的 append 方法。我们也可以通过 relice 操作化简 slice。因为 slice 的底层内存是连续分配的，所以 slice 的索引，迭代和垃圾回收性能都很好。 slice 是对底层数组的抽象和控制。它包含 Go 需要对底层数组管理的三种元数据，分别是： 指向底层数组的指针 slice 中元素的长度 slice 的容量(可供增长的最大值) 创建和初始化Go 中创建 slice 有很多种方法，我们一个一个来看。 第一个方法是使用内建的函数 make。当我们使用 make 创建时，一个选项是可以指定 slice 的长度： slice := make([]string, 5) 如果只指定了长度，那么容量默认等于长度。我们可以分别指定长度和容量： slice := make([]int, 3, 5) 当我们分别指定了长度和容量，我们创建的 slice 就可以拥有一开始并没有访问的底层数组的容量。上面代码的 slice 中，可以访问3个元素，但是底层数组有5个元素。两个与长度不相干的元素可以被 slice 来用。新创建的 slice 同样可以共享底层数组和已存在的容量。 不允许创建长度大于容量的 slice： slice := make([]int, 5, 3) Compiler Error: len larger than cap in make([]int) 惯用的创建 slice 的方法是使用 slice 字面量。跟创建数组很类似，不过不用指定 []里的值。初始的长度和容量依赖于元素的个数： // 创建一个字符串 slice // 长度和容量都是 5 slice := []string{&quot;Red&quot;, &quot;Blue&quot;, &quot;Green&quot;, &quot;Yellow&quot;, &quot;Pink&quot;} 在使用 slice 字面量创建 slice 时有一种方法可以初始化长度和容量，那就是初始化索引。下面是个例子： // 创建一个字符串 slice // 初始化一个有100个元素的空的字符串 slice slice := []string{99: &quot;&quot;} nil 和 empty slice 有的时候我们需要创建一个 nil slice，创建一个 nil slice 的方法是声明它但不初始化它： var slice []int 创建一个 nil slice 是创建 slice 最基本的方法，很多标准库和内建函数都可以使用它。当我们想要表示一个并不存在的 slice 时它变得非常有用，比如一个返回 slice 的函数中发生异常的时候。 创建 empty slice 的方法就是声明并初始化一下： // 使用 make 创建 silce := make([]int, 0) // 使用 slice 字面值创建 slice := []int{} empty slice 包含0个元素并且底层数组没有分配存储空间。当我们想要表示一个空集合时它很有用处，比如一个数据库查询返回0个结果。 不管我们用 nil slice 还是 empty slice，内建函数 append，len和cap的工作方式完全相同。 使用 slice为一个指定索引值的 slice 赋值跟之前数组赋值的做法完全相同。改变单个元素的值使用 [] 操作符： slice := []int{10, 20, 30, 40, 50} slice[1] = 25 我们可以在底层数组上对一部分数据进行 slice 操作，来创建一个新的 slice： // 长度为5，容量为5 slice := []int{10, 20, 30, 40, 50} // 长度为2，容量为4 newSlice := slice[1:3] 在 slice 操作之后我们得到了两个 slice，它们共享底层数组。但是它们能访问底层数组的范围却不同，newSlice 不能访问它头指针前面的值。 计算任意 new slice 的长度和容量可以使用下面的公式： 对于 slice[i:j] 和底层容量为 k 的数组 长度：j - i 容量：k - i 必须再次明确一下现在是两个 slice 共享底层数组，因此只要有一个 slice 改变了底层数组的值，那么另一个也会随之改变： slice := []int{10, 20, 30, 40, 50} newSlice := slice[1:3] newSlice[1] = 35 改变 newSlice 的第二个元素的值，也会同样改变 slice 的第三个元素的值。 一个 slice 只能访问它长度范围内的索引，试图访问超出长度范围的索引会产生一个运行时错误。容量只可以用来增长，它只有被合并到长度才可以被访问： slice := []int{10, 20, 30, 40, 50} newSlice := slice[1:3] newSlice[3] = 45 Runtime Exception: panic: runtime error: index out of range 容量可以被合并到长度里，通过内建的 append 函数。 slice 增长slice 比 数组的优势就在于它可以按照我们的需要增长，我们只需要使用 append 方法，然后 Go 会为我们做好一切。 使用 append 方法时我们需要一个源 slice 和需要附加到它里面的值。当 append 方法返回时，它返回一个新的 slice，append 方法总是增长 slice 的长度，另一方面，如果源 slice 的容量足够，那么底层数组不会发生改变，否则会重新分配内存空间。 // 创建一个长度和容量都为5的 slice slice := []int{10, 20, 30, 40, 50} // 创建一个新的 slice newSlice := slice[1:3] // 为新的 slice append 一个值 newSlice = append(newSlice, 60) 因为 newSlice 有可用的容量，所以在 append 操作之后 slice 索引为 3 的值也变成了 60，之前说过这是因为 slice 和 newSlice 共享同样的底层数组。 如果没有足够可用的容量，append 函数会创建一个新的底层数组，拷贝已存在的值和将要被附加的新值： // 创建长度和容量都为4的 slice slice := []int{10, 20, 30, 40} // 附加一个新值到 slice，因为超出了容量，所以会创建新的底层数组 newSlice := append(slice, 50) append 函数重新创建底层数组时，容量会是现有元素的两倍(前提是元素个数小于1000)，如果元素个数超过1000，那么容量会以 1.25 倍来增长。 slice 的第三个索引参数slice 还可以有第三个索引参数来限定容量，它的目的不是为了增加容量，而是提供了对底层数组的一个保护机制，以方便我们更好的控制 append 操作，举个栗子： source := []string{&quot;apple&quot;, &quot;orange&quot;, &quot;plum&quot;, &quot;banana&quot;, &quot;grape&quot;} // 接着我们在源 slice 之上创建一个新的 slice slice := source[2:3:4] 新创建的 slice 长度为 1，容量为 2，可以看出长度和容量的计算公式也很简单： 对于 slice[i:j:k] 或者 [2:3:4] 长度： j - i 或者 3 - 2 容量： k - i 或者 4 - 2 如果我们试图设置比可用容量更大的容量，会得到一个运行时错误： slice := source[2:3:6] Runtime Error: panic: runtime error: slice bounds out of range 限定容量最大的用处是我们在创建新的 slice 时候限定容量与长度相同，这样以后再给新的 slice 增加元素时就会分配新的底层数组，而不会影响原有 slice 的值： source := []string{&quot;apple&quot;, &quot;orange&quot;, &quot;plum&quot;, &quot;banana&quot;, &quot;grape&quot;} // 接着我们在源 slice 之上创建一个新的 slice // 并且设置长度和容量相同 slice := source[2:3:3] // 添加一个新元素 slice = append(slice, &quot;kiwi&quot;) 如果没有第三个索引参数限定，添加 kiwi 这个元素时就会覆盖掉 banana。 内建函数 append 是一个变参函数，意思就是你可以一次添加多个元素，比如： s1 := []int{1, 2} s2 := []int{3, 4} fmt.Printf(&quot;%v\n&quot;, append(s1, s2...)) Output: [1 2 3 4] 迭代 sliceslice 也是一种集合，所以可以被迭代，用 for 配合 range 来迭代： slice := []int{10, 20, 30, 40, 50} for index, value := range slice { fmt.Printf(&quot;Index: %d Value: %d\n&quot;, index, value) } Output: Index: 0 Value: 10 Index: 1 Value: 20 Index: 2 Value: 30 Index: 3 Value: 40 Index: 4 Value: 50 当迭代时 range 关键字会返回两个值，第一个是索引值，第二个是索引位置值的拷贝。注意：返回的是值的拷贝而不是引用，如果我们把值的地址作为指针使用，会得到一个错误，来看看为啥： slice := []int{10, 20, 30 ,40} for index, value := range slice { fmt.Printf(&quot;Value: %d Value-Addr: %X ElemAddr: %X\n&quot;, value, &amp;value, &amp;slice[index]) } Output: Value: 10 Value-Addr: 10500168 ElemAddr: 1052E100 Value: 20 Value-Addr: 10500168 ElemAddr: 1052E104 Value: 30 Value-Addr: 10500168 ElemAddr: 1052E108 Value: 40 Value-Addr: 10500168 ElemAddr: 1052E10C value 变量的地址总是相同的因为它只是包含一个拷贝。如果想得到每个元素的真是地址可以使用 &amp;slice[index]。 如果不需要索引值，可以使用 _ 操作符来忽略它： slice := []int{10, 20, 30, 40} for _, value := range slice { fmt.Printf(&quot;Value: %d\n&quot;, value) } Output: Value: 10 Value: 20 Value: 30 Value: 40 range 总是从开始一次遍历，如果你想控制遍历的step，就用传统的 for 循环： slice := []int{10, 20, 30, 40} for index := 2; index &lt; len(slice); index++ { fmt.Printf(&quot;Index: %d Value: %d\n&quot;, index, slice[index]) } Output: Index: 2 Value: 30 Index: 3 Value: 40 同数组一样，另外两个内建函数 len 和 cap 分别返回 slice 的长度和容量。 多维 slice也是同数组一样，slice 可以组合为多维的 slice： slice := [][]int{{10}, {20, 30}} 需要注意的是使用 append 方法时的行为，比如我们现在对 slice[0] 增加一个元素： slice := [][]int{{10}, {20, 30}} slice[0] = append(slice[0], 20) 那么只有 slice[0] 会重新创建底层数组，slice[1] 则不会。 在函数间传递 slice在函数间传递 slice 是很廉价的，因为 slice 相当于是指向底层数组的指针，让我们创建一个很大的 slice 然后传递给函数调用它： slice := make([]int, 1e6) slice = foo(slice) func foo(slice []int) []int { ... return slice } Map内部机制 map 是一种无序的键值对的集合。map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。 map 是一种集合，所以我们可以像迭代数组和 slice 那样迭代它。不过，map 是无序的，我们无法决定它的返回顺序，这是因为 map 是使用 hash 表来实现的。 map 的 hash 表包含了一个桶集合(collection of buckets)。当我们存储，移除或者查找键值对(key/value pair)时，都会从选择一个桶开始。在映射(map)操作过程中，我们会把指定的键值(key)传递给 hash 函数(又称散列函数)。hash 函数的作用是生成索引，索引均匀的分布在所有可用的桶上。hash 表算法详见：July的博客—从头到尾彻底解析 hash 表算法 创建和初始化Go 语言中有多种方法创建和初始化 map。我们可以使用内建函数 make 也可以使用 map 字面值： // 通过 make 来创建 dict := make(map[string]int) // 通过字面值创建 dict := map[string]string{&quot;Red&quot;: &quot;#da1337&quot;, &quot;Orange&quot;: &quot;#e95a22&quot;} 使用字面值是创建 map 惯用的方法(为什么不使用make)。初始化 map 的长度依赖于键值对的数量。 map 的键可以是任意内建类型或者是 struct 类型，map 的值可以是使用 ==操作符的表达式。slice，function 和 包含 slice 的 struct 类型不可以作为 map 的键，否则会编译错误： dict := map[[]string]int{} Compiler Exception: invalid map key type []string 使用 map给 map 赋值就是指定合法类型的键，然后把值赋给键： colors := map[string]string{} colors[&quot;Red&quot;] = &quot;#da1337&quot; 如果不初始化 map，那么就会创建一个 nil map。nil map 不能用来存放键值对，否则会报运行时错误： var colors map[string]string colors[&quot;Red&quot;] = &quot;#da1337&quot; Runtime Error: panic: runtime error: assignment to entry in nil map 测试 map 的键是否存在是 map 操作的重要部分，因为它可以让我们判断是否可以执行一个操作，或者是往 map 里缓存一个值。它也可以被用来比较两个 map 的键值对是否匹配或者缺失。 从 map 里检索一个值有两种选择，我们可以同时检索值并且判断键是否存在： value, exists := colors[&quot;Blue&quot;] if exists { fmt.Println(value) } 另一种选择是只返回值，然后判断是否是零值来确定键是否存在。但是只有你确定零值是非法值的时候这招才管用： value := colors[&quot;Blue&quot;] if value != &quot;&quot; { fmt.Println(value) } 当索引一个 map 取值时它总是会返回一个值，即使键不存在。上面的例子就返回了对应类型的零值。 迭代一个 map 和迭代数组和 slice 是一样的，使用 range 关键字，不过在迭代 map 时我们不使用 index/value 而使用 key/value 结构： colors := map[string]string{ &quot;AliceBlue&quot;: &quot;#f0f8ff&quot;, &quot;Coral&quot;: &quot;#ff7F50&quot;, &quot;DarkGray&quot;: &quot;#a9a9a9&quot;, &quot;ForestGreen&quot;: &quot;#228b22&quot;, } for key, value := range colors { fmt.Printf(&quot;Key: %s Value: %s\n&quot;, key, value) } 如果我们想要从 map 中移除一个键值对，使用内建函数 delete(要是也能返回移除是否成功就好了，哎。。。)： delete(colors, &quot;Coral&quot;) for key, value := range colors { fmt.Println(&quot;Key: %s Value: %s\n&quot;, key, value) } 在函数间传递 map在函数间传递 map 不是传递 map 的拷贝。所以如果我们在函数中改变了 map，那么所有引用 map 的地方都会改变： func main() { colors := map[string]string{ &quot;AliceBlue&quot;: &quot;#f0f8ff&quot;, &quot;Coral&quot;: &quot;#ff7F50&quot;, &quot;DarkGray&quot;: &quot;#a9a9a9&quot;, &quot;ForestGreen&quot;: &quot;#228b22&quot;, } for key, value := range colors { fmt.Printf(&quot;Key: %s Value: %s\n&quot;, key, value) } removeColor(colors, &quot;Coral&quot;) for key, value := range colors { fmt.Printf(&quot;Key: %s Value: %s\n&quot;, key, value) } } func removeColor(colors map[string]string, key string) { delete(colors, key) } 执行会得到以下结果： Key: AliceBlue Value: #F0F8FF Key: Coral Value: #FF7F50 Key: DarkGray Value: #A9A9A9 Key: ForestGreen Value: #228B22 Key: AliceBlue Value: #F0F8FF Key: DarkGray Value: #A9A9A9 Key: ForestGreen Value: #228B22 可以看出来传递 map 也是十分廉价的，类似 slice。 SetGo 语言本身是不提供 set 的，但是我们可以自己实现它，下面就来试试： package main import( &quot;fmt&quot; &quot;sync&quot; ) type Set struct { m map[int]bool sync.RWMutex } func New() *Set { return &amp;Set{ m: map[int]bool{}, } } func (s *Set) Add(item int) { s.Lock() defer s.Unlock() s.m[item] = true } func (s *Set) Remove(item int) { s.Lock() s.Unlock() delete(s.m, item) } func (s *Set) Has(item int) bool { s.RLock() defer s.RUnlock() _, ok := s.m[item] return ok } func (s *Set) Len() int { return len(s.List()) } func (s *Set) Clear() { s.Lock defer s.Unlock() s.m = map[int]bool{} } func (s *Set) IsEmpty() bool { if s.Len() == 0 { return true } return false } func (s *Set) List() []int { s.RLock() defer s.RUnlock() list := []int{} for item := range s.m { list = append(list, item) } return list } func main() { // 初始化 s := New() s.Add(1) s.Add(1) s.Add(2) s.Clear() if s.IsEmpty() { fmt.Println(&quot;0 item&quot;) } s.Add(1) s.Add(2) s.Add(3) if s.Has(2) { fmt.Println(&quot;2 does exist&quot;) } s.Remove(2) s.Remove(3) fmt.Println(&quot;list of all items&quot;, S.List()) } 注意我们只是使用了 int 作为键，你可以自己实现用 interface{} 作为键，做成更通用的 Set，另外，这个实现是线程安全的。 总结 数组是 slice 和 map 的底层结构。 slice 是 Go 里面惯用的集合数据的方法，map 则是用来存储键值对。 内建函数 make 用来创建 slice 和 map，并且为它们指定长度和容量等等。slice 和 map 字面值也可以做同样的事。 slice 有容量的约束，不过可以通过内建函数 append 来增加元素。 map 没有容量一说，所以也没有任何增长限制。 内建函数 len 可以用来获得 slice 和 map 的长度。 内建函数 cap 只能作用在 slice 上。 可以通过组合方式来创建多维数组和 slice。map 的值可以是 slice 或者另一个 map。slice 不能作为 map 的键。 在函数之间传递 slice 和 map 是相当廉价的，因为他们不会传递底层数组的拷贝。]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go基础</tag>
        <tag>Array、Slice、Map、Set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang知识图谱]]></title>
    <url>%2F2018%2F05%2F10%2FGolang%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%2F</url>
    <content type="text"><![CDATA[一张图介绍Golang知识图谱，查漏补缺，还能装逼]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go基础</tag>
        <tag>Golang知识图谱</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go——基础学习笔记]]></title>
    <url>%2F2018%2F05%2F09%2FGo%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[iOS开发中有一个方向叫，你想工程开发，曾经也试着话时间去研究过相关的技术，熟悉使用那些相关的工具，但是毕竟没有专门实战过项目，也就只能简单的入门一下。而随着iOS开发年限的增长，和所了解到的东西，发现有不少公司或者朋友都在关注安全这一块，虽然Apple已经把安全做得很到位了，但是还是有这一块的问题存在，所以我根据个人的能力并结合网上的相关资料，简单的整理了一下，不管是作为了解，还是项目实战，或者为了面试，我都希望能有所帮助…… 07年由RRK三人主持开发，09年11月开源，12年1.0稳定版 特点 语言简单 实用，有效，高效 静态类型 编译型 开源 脚本化语法 函数式 面向对象 原始并发 协程（并发编程的管道） 垃圾回收 类型安全 内存安全 UTF8编码 移除或异常无用包 内置高性能http server 完善简便的各种库(package) 调用C很简便 跨平台 作者之一是c的作者 优势 脚本化 静态+编译-&gt;速度(相比：动态+解释) 并发(运行时系统调度和算法) 劣势 语法糖少 速度不及C 第三方库较少 环境变量 GOROOT：Go语言的当前安装目录 GOPATH：Go语言工作区的结合（工作目录） GOBIN：可执行文件目录 PATH：Go语言本身目录和Go程序生成可执行文件命令 (~/.bash_profile(单一用户),/etc/profile(全局用户) 相关目录$GOOS_$GOARCH： GOOS-操作系统，GOARCH-计算架构 工作区 src：源码文件（代码包） pkg：存放归档文件（代码包，库） bin：Go程序可执行文件 源码文件 命令源码文件（功能）：Go语言入口，声明自己属于main代码包，包含无参数声明和结果声明的main函数 库源码文件（功能）：不具备命令源码文件的两个特征 测试源码文件（辅助）：同上，但是名称为：_test.go后缀 测试函数（至少一个）：Test(功能)或Benchmark(基准或性能)前缀，参数testing.T或testing.B 基本命令 go run： 编译-临时-运行-可执行，归档文件 a：强制编译，不管是不是最新 n：打印编译需要的命令，不执行 p n：并行编译，n为并行数 a：列出被编译代码包名称（-a -v：所有涉及） work：临时工作目录路径，且不删除 x：打印编译需要的命令，执行 go build：编译代码包（库：不产生结果文件，只检查有效性。命令：生成可执行文件，结果文件） a：加入-编译所有涉及，不加入-只编译最新的 go install：编译并安装代码包或源码文件 go get：从远程代码仓库下载并安装代码包（git，Mercurial，svn，Bazaar） d：只下载不安装 fix：下载后，先执行修正动作，在安装 u：更新代码包 ds(显示指定目录的目录结构)/pds命令(显示指定代码包的以来关系) DOC godoc -http=:8800 基础总结 只有package为main的包可以包含main函数 一个可执行文件有且仅有一个main函数 import导入非main包 函数外包使用var申明和赋值全局变量 type进行结构体和接口的声明 代码实例// 当前程序的包名（package：非注释的第一行） package main // 导入其他包 import &quot;fmt&quot; // 格式 import . &quot;os&quot; // 省略 import io &quot;io&quot; // 别名 import _ &quot;time&quot; // 忽略 import ( &quot;strings&quot; ) // 常量定义 const PI = 3.14 // 全局变量声明与赋值 var name = &quot;iCocos&quot; // 一般类型的声明 type newtype int // 结构体的声明 type gostruct = struct{} // 接口的声明 type gointerface interface{} // 以上三种都可以使用组 type ( byte int8 rune int 32 文本 string ) // 由main函数作为程序入口和启动 func main() { Printf(&quot;Hello World!&quot;) } 可见性规则常量，变量，类型，接口，结构体，函数 大小写区分： 小写为private 大写为public 陆续更新 01基础学习笔记 02Go语法初识 03类型与变量 04常量与运算符 05控制语句 06数组array 07切片slice 08map 09函数function 10结构struct 11方法method 12接口interface 13反射reflection 14并发concurrency 15项目与坑]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>基础学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器配置——实战验证与补充]]></title>
    <url>%2F2018%2F05%2F05%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94%E5%AE%9E%E6%88%98%E9%AA%8C%E8%AF%81%E4%B8%8E%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[下面关于之前一些流程（Ngnix，Php，Go，Mysql）安装配置与使用的一些总结，和遇到的一个坑，其中也有关于服务器配置与部署，代码上传与发布相关内容，主要是为了熟悉整个流程…… 这里补充一下前面没有提到，但是实际操作会用到或者能提升效率的东西 安装ftp大家看到了，所有的文件操作在ssh中可以通过vim方法来实现，但是，你知道在windows中用惯了，还是喜欢看图形界面，所以在这里我安装了ftp可以远程来上传修改文件 软件：winscp（百度下载就好了） 安装vsftpdyum install vsftpd 启动/重启/关闭vsftpd服务器[root@localhost ftp]# /sbin/service vsftpd restart Shutting down vsftpd: [ OK ] Starting vsftpd for vsftpd: [ OK ] OK表示重启成功了. 这里现在就可以直接使用root及你的密码来查看了，当然这样的是超级用户，留给自己用的，要配置指定要文件夹的用户，我就在不在这里写了，大家继续百度下吧 安装Gitsudo apt-get update sudo apt-get install git]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Server</tag>
        <tag>实战验证与补充</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器配置——Go安装与配置]]></title>
    <url>%2F2018%2F05%2F04%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94Go%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[这里应该说是我此次的最初目的，当然后面接触了不少服务器配置与部署后，我发现重点不是学习Go，而且这整个过程中学到的一切，好了，其实我突然重新开始整服务器和博客，是因为想要开始好好，认认真真的学习一下Go，并将其应用到实战中…… go下载安装后上传到服务器 这里之前是可以直接使用wget安装的，但是大部分的wget地址所下载的gz包都无法解压 #解压 tar -zxvf go1.8.4.linux-amd64.tar.gz 所以一般都是选择官网的 $HOME 下面创建了一个 .export 文件写的 这些环境变量 要想立即生效的话 要么退出从新连接 要么执行下 source ~/.bashrc 执行 go env 看看 GOPATH GOROOT GOBIN 是不是自己设置的 在 $HOME/GoWorkSpec 创建了这文件目录 下面有 bin pkg src 三个子目录 src 放源码 测试代码 go http server如果你配置好了所有需要的服务与配置，并且对Go语言已经足够熟悉了，那么你一定会想用Go语言来干点撒。 没错，就是我们一开始的目的，实现服务器开发，和Php一样接收前端或者移动端的请求，进行数据的处理与返回 但是由于时间原因，而且关于go http server目前还有点早，后面会用专门的文章来说明具体的配置与实战。 感兴趣的可以看看下面的文章： https://blog.csdn.net/chenxun_2010/article/details/73862810]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Server</tag>
        <tag>Go安装与配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器配置——MySql安装与配置]]></title>
    <url>%2F2018%2F05%2F04%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94MySql%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[服务器好了之后，首先我们应该从数据库入手，因为一切没有数据交互与存储的服务器和客户端都只是娱乐，这里我们选择大部分人都熟知而且与PHP成为天和之作的Mysql，当然他和Go也一样兼容…… 安装mysqlmysql 可以管理网站用到的数据库，WordPress 和 Drupal 也都支持 mysql 数据库。所以我们的 Web 运行环境里，需要安装一个 mysql 。之前我们已经添加了资源库，所以可以直接使用 yum 命令去安装 mysql ： yum install mysql-server 安装完成后，使用 service 命令启动 mysql 服务： service mysqld start 然后我们需要简单配置一下 mysql ，默认安装以后 mysql 的 root 用户是没有密码的，对于生产环境来说，这肯定是不行的. 另外还有一些安全相关的设置，可以使用下面这行命令去配置一下，它是一个向导，问你一些问题，你要给出答案，比如是否要设置 root 用户的密码， 密码是什么等等。 mysql_secure_installation 然后根据实际情况进行配置，也可以看看下面比较常用的配置方案 Enter current password for root (enter for none): 解释：输入当前 root 用户密码，默认为空，直接回车。 Set root password? [Y/n] y 解释：要设置 root 密码吗？输入 y 表示愿意。 Remove anonymous users? [Y/n] y 解释：要移除掉匿名用户吗？输入 y 表示愿意。 Disallow root login remotely? [Y/n] n 解释：不想让 root 远程登陆吗？输入 y 表示愿意。 Remove test database and access to it? [Y/n] y 解释：要去掉 test 数据库吗？输入 y 表示愿意。 Reload privilege tables now? [Y/n] y 解释：想要重新加载权限吗？输入 y 表示愿意。]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Server</tag>
        <tag>MySql安装与配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器配置——Php安装与配置]]></title>
    <url>%2F2018%2F05%2F03%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94Php%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[由于之前学过一段时间的Php，偶尔看到一个不错的东西也会尝试一下，虽然可能最终结果和意义并不大，但是此次我还是觉决定让服务器支持Php，同时也会适当的更新一些Php的内容（能力有限，都是比较基础的内容）…… 说了服务器第一步Ngnix安装与配置之后，就要开始说说关于PHP和Go的安装与配置 配置php-fpm部分要让 nginx 能够执行 php 文件，需要去安装一下 php-fpm，它直接包含在了 CentOS 资源库里，所以直接使用 yum 命令可以安装它： yum install php-fpm 完成以后，可以检查一下 php-fpm 的运行状态，使用 service 命令： service php-fpm status 返回： php-fpm is stopped（php-fpm 已停止） 启动 php-fpm 同样可以使用 service 命令： service php-fpm start 让 nginx 可以执行 php现在我们应该就可以让 nginx 去执行 php 了。不过你需要修改一下 nginx 的配置文件，之前我们在配置虚拟主机的时候，创建了一个 nginx.ninghao.net.conf 的配置文件，需要去修改下 nginx 的这个配置文件，才能去执行 php 。使用 vim 命令去编辑它： vim /etc/nginx/conf.d/nginx.ninghao.net.conf 注意你的配置文件不一定叫 nginx.ninghao.net.conf，应该是你自己命名的配置文件。打开以后，找到下面这段字样的代码： # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \.php$ { # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #} 这是 nginx 默认给我们的用来执行 php 的配置，从 location 开始取消注释，会让这个配置生效，然后我们还得简单去修改一下： # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # location ~ \.php$ { # root html; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; } 注意 root 那里仍然是被注释掉的，还有 SCRIPT_FILENAME 后面修改了一下，把 /scripts 换成了 $document_root 。保存并退出。然后重新启动 nginx： service nginx restart 测试是否可以执行 php现在，我们已经安装了 php-fpm，并修改了 nginx 的配置文件让它可以去执行 php，下面，我们得去测试一下，可以使用 php 的 phpinfo(); 函数，方法是在你的虚拟主机根目录下面，创建一个 php 文件，命名为 phpinfo.php，然后在这个文件里输入： &lt;?php phpinfo(); ?&gt; 保存文件并退出。在浏览器里打开刚才创建的这个 php 文件。我这里应该是 http://nginx.ninghao.net/phpinfo.php。打开以后，你应该能看到像下面这样的界面，如果能，说明 nginx 已经可以执行 php 了。 配置扩展 现在，我们有了可以提供 web 服务的 nginx ，并且安装了 php-fpm ，配置了 nginx 可以让它去执行 php ，也安装了数据库管理系统。 不过在运行真正的网站的时候，我们还需要为 php 安装一些额外的扩展，比如 处理 mysql 数据库的 mysql 扩展，缓存功能的 apc 扩展，处理图像的 gd 扩展等等。安装它们同样可以使用 yum 命令。 yum install php-pecl-apc php-mysql php-gd php-mcrypt php-pear php-mbstring php-xmlrpc php-dom 上面安装了一些 php 的扩展，如果你发现在安装网站的时候提示需要安装其它的扩展，同样可以使用 yum 命令去安装。安装完成以后，需要重启一下 php-fpm ： service php-fpm restart]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Server</tag>
        <tag>Php安装与配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器配置——Nginx安装与配置]]></title>
    <url>%2F2018%2F05%2F03%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94Nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[配置完阿里控制台之后，首先我们开始配置服务器，我的服务器各种配置都需要自己重新配，这里我现在Ngnix，不要问我为什么选择他，可能是之前用过Apache，对他印象不好吧…… 前面说了关于阿里云主机操作，这里打算开始一步一步搭建和配置服务器，并且开始Go语言和后台学习，并且徐后续更新，直到后面的后台实战开发 关于域名解析，实例，和安全组相关请自行参考阿里官方教程 如何连接服务器执行环境配置 我使用的是centos6.8 64位版本，如果您不是第一次接触linux那一定知道，linux不是一个可视化界面的系统，所以要摒弃windows的操作习惯，我使用的xshell这个软件链接的服务器，连接语句是 ssh root@ip地址 地址处就是写入你的ip地址，然后回车鞋面就会自动连接，弹框提示输入密码 输入服务器的密码，点击确定即链接上了 ok，下面就可以开始配置环境了，第一步我们先配置nginx nginx安装部分想在 CentOS 系统上安装 Nginx ，你得先去添加一个资源库，像这样： vim /etc/yum.repos.d/nginx.repo 使用 vim 命令去打开 /etc/yum.repos.d/nginx.repo ，如果 nginx.repo 不存在，就会去创建一个这样的文件，打开以后按一下小 i 键，进入编辑模式，然后复制粘贴下面这几行代码，完成以后按 esc 键退出，再输入 :wq （保存并退出） [nginx] name=nginx repo baseurl=http://nginx.org/packages/centos/$releasever/$basearch/ gpgcheck=0 enabled=1 完成以后，我们就可以使用 yum 命令去安装 nginx 了，像这样： yum install nginx 安装好以后测试一下 nginx 服务： service nginx status 应该会返回： nginx is stopped （nginx 已停止） 再测试一下 nginx 的配置文件： nginx -t 应该会返回： nginx: the configuration file /etc/nginx/nginx.conf syntax is ok nginx: configuration file /etc/nginx/nginx.conf test is successful … syntax is ok，… test is successful，说明配置文件没问题，同时这个结果里你可以找到 nginx 的配置文件 nginx.conf 所在的位置。 操纵 nginx 服务操纵服务，可以使用使用 service 命令，它可以启动（start），重启（restart），或停止服务（stop），比如要启动 nginx 服务： service nginx start 服务启动以后，你就可以在浏览器上使用服务器的 IP 地址，或者指向这个地址的域名访问服务器指定的目录了。你会看到类似下面的这些文字。 Welcome to nginx! If you see this page, the nginx web server is successfully installed and working. Further configuration is required. For online documentation and support please refer to nginx.org. Commercial support is available at nginx.com. Thank you for using nginx. nginx配置部分下面来看一下为 nginx 配置虚拟主机。先进入到 nginx 配置文件目录： cd /etc/nginx/conf.d 复制这个目录里的 default.conf ，复制以后的名字可以使用你的虚拟主机名字。比如创建一个 nginx.ninghao.net 的虚拟主机。复制文件可以使用 cp 命令，像这样： cp default.conf nginx.ninghao.net.conf 再去编辑一下这个复制以后的配置文件，可以使用 vim 命令： vim nginx.ninghao.net.conf 你会看到像这样的代码： server { listen 80; server_name localhost; #charset koi8-r; #access_log /var/log/nginx/log/host.access.log main; location / { root /usr/share/nginx/html; index index.html index.htm; } ... } server_name 就是主机名，也就是跟这个虚拟主机绑定在一块儿的域名，我事先把 nginx.ninghao.net 指向了服务器，这个虚拟主机就是为它准备的，所以，server_name 后面的东西就是 nginx.ninghao.net 。 紧接着 server_name 下面可以是一个root，就是这个虚拟主机的根目录，也就是网站所在的目录。比如我们要把 nginx.ninghao.net 这个网站的文件放在/home/www/nginx.ninghao.net 下面，那么这个 root 就是这个路径。 然后去掉 location / 里面的 root 这行代码。再在 index 后面加上一种索引文件名，也就是默认打开的文件，这里要加上一个 index.php ，这样访问 nginx.ninghao.net 就可以直接打开 root 目录下面的 index.php 了。稍后我们再去安装 php 。修改之后，看起来像这样： server { listen 80; server_name nginx.ninghao.net; root /home/www/nginx.ninghao.net; #charset koi8-r; #access_log /var/log/nginx/log/host.access.log main; location / { index index.php index.html index.htm; } ... } 这个配置文件先修改到这，稍后，我们再回来继续修改一下它。保存一下，按 esc ，输入 :wp（保存并退出）。现在虚拟主机应该就可以使用了。主机的域名是 nginx.ninghao.net，访问它的时候，打开的是 /home/www/nginx.ninghao.net 这个目录里面的东西，你可以在这个目录下放点东西。 重启 nginx 或者重新加载 nginx 可以让配置文件生效。 service nginx reload 现在，打开浏览器，输入你为虚拟主机设置的域名，看看是否能打开你指定的目录里的东西。]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Server</tag>
        <tag>Nginx安装与配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器配置——阿里云主机配置与操作]]></title>
    <url>%2F2018%2F05%2F01%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94%E9%98%BF%E9%87%8C%E4%BA%91%E4%B8%BB%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[去年中旬在阿里买了一个属于自己的个性域名(笔者英文)：www.icocos.cn，虽然是CN，但是这都不是重点，重点是为了更全面的接触后台，更好的学习与实战后台开发与PHP，前天又在阿里买了个主机，打算开发玩弄一番，毕竟第一次，期间可能会遇到不少坑和不对的地方，望谅解与指出一起交流，谢谢...... 阿里云（先声明我不是来给阿里大广告的，😂😂😂😂😂😂） 阿里云主机 域名：www.icocos.cn 这里关于阿里云主机和域名的购买很简单，准备钱，一路点下去就可以了,具体操作强查看阿里文档…… 备案关于备案确实是不少人蛋疼的事情，说麻烦也没有多麻烦，说不麻烦但是搞起来又不是点几下就可以的，所以也有不少人选择了不需要备案的或者国外的主机，我当时也有这种想法，但是后来放弃了，投资嘛，自己都不舍得投资还怎么学东西，怎么提升呢！ 本案分个人备案和企业备案，具体详情阿里也有教程，或者网上也有相关教程 初始化配置在链接之前可能需要做一些配置，但是有些事必须的有些可以后面备案成功之后再做，我就是第一次弄所以一直不懂，以为需要备案以后才能操作的。 添加安全组织，允许22端口访问这里其实就是进入阿里控制台的云服务ECS，找到安全组，添加安全组，配置规则就可以. 这里只要注意 端口:22/22 授权对象：0.0.0.0/0 初步的这样就可以了，我是为了方便链接访问 然后就可以链接了 连接，并操作连接的话当然首选ssh，不要问我为什么，我也不知道，大家都用它，哈哈！ 关于SSHSSH是每一台Linux电脑的标准配置。 简单说，SSH是一种网络协议，用于计算机之间的加密登录。 如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。 最基本的用法SSH主要用于远程登录。假定你要以用户名user，登录远程主机host，只要一条简单命令就可以了。 $ ssh user@host 如果本地用户名与远程用户名一致，登录时可以省略用户名。 $ ssh host SSH的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口。 $ ssh -p 2222 user@host 上面这条命令表示，ssh直接连接远程主机的2222端口。 这里我使用的是SSH shell这个工具，Windows用什么不知道，网上应该一大堆命令行步骤 输入 ssh root@ip地址 输入yes 输入密码 就可以看到显示 [root@iZwz92qgus0ln1nx5dftjd2rZ ~]# SSH工具使用也很简单，进后点击Add Server输入ip，端口是默认22，输入root用户名，输入后台配置的密码，对了这里的密码是需要在控制台配置的 一切顺利的话可以看到一个和terminal一样的终端界面，并且已经连接成功的显示 [root@iZwz92qgus0ln1nx5dftjd2rZ ~]# 然后就可以使用命令操作主机文件了。 密码登录：Mac 客户端进入.ssh 文件夹，如果没有就创建一个.ssh文件夹mkdir ~/.ssh cd ~/.ssh/ 生成rsa秘钥：这个相信大部分人都弄过，github就需要ssh-keygen -t rsa 在该文件夹下就会产生三个文件夹：id_rsa,id_rsa.pub,know_hosts。id_rsa：存储私钥，记得只能自己看哦。别人那到这个文件就完蛋蛋咯。 id_rsa.pub:存储公钥，用来通信加密使用，有了这个人家才能确定这是你。 公钥拷贝到云主机scp id_rsa.pub root@78.129.23.45:/root/.ssh/id_rsa.pub Note:云主机上没有.ssh/文件时，你要自己建立一个。终端连接后输入ls只能看到default.pass文件，ls -a发现也是没有.ssh文件夹的，所以需要输入下面命令创建.ssh文件夹 mkdir .ssh #回车没有提示就成功再次ls -a就可以看到一个蓝色的隐藏文件夹 登录到云主机进入.ssh/文件夹cd /root/.ssh/ 将客户端公钥放入云主机识别keys文件夹中cat id_rsa.pub &gt;&gt; authorized_keys 销毁公钥rm id_rsa.pub 再次输入ssh root@ip地址就可以直接连接了，当然如果你使用工具的话就不用这么麻烦。 到这里就基本上初步，而且是很简单的实现的主机的查看与操作，具体更多操作和命令请查看相关资料，后期也会有一些配置，操作与实战，请期待]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Server</tag>
        <tag>阿里云主机配置与操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——开发者中心更新手机号码]]></title>
    <url>%2F2018%2F04%2F26%2FiOS%E2%80%94%E2%80%94%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%AD%E5%BF%83%E6%9B%B4%E6%96%B0%E6%89%8B%E6%9C%BA%E5%8F%B7%E7%A0%81%2F</url>
    <content type="text"><![CDATA[The Apple Developer 开发者中心更新手机号码 Program License Agreement has been updated……. The Apple Developer 开发者中心更新手机号码 Program License Agreement has been updated. 从而导致：1. 无法提交新APP 2. 无法编辑证书 从而造成无法继续做任何App更新，与证书相关的操作。 于是开始联系苹果技术客服（400 670 1855），但是在天朝开发者的数量你懂的，于是，不管三七二十几，拨通了放一边不管，因为我打过不下5次客服，排队时间从来没有少于半个小时了。 …… 等了近两个小时候，既然通了，叙事描述了一番，让我根据他们的说明提交对应的信息和问题的描述，然后让我们等2-3个工作日，当时我就闹过了，但是也没有办法，谁让人家是爸爸呢！ 于是在等待苹果消息的时候，不定时的进入后台刷新查看状态，同事在寻求各种大神和好友的帮助。 最后在一个群里看到了一个比较直接的解决方案，当然也比较变态，这一切都都应该是苹果的锅。具体方案是这样的：1、在修改手机号的页面，将COUNTRY / REGION一栏的国家从中国改成香港（Hong Kong） 2、修改地区会提示你修改付款信息（随便瞎填一下就行了，修改后记得点保存） 3、和原来的步骤一样，在REACHABLE AT（改手机号旁）处，点击Add More..添加手机号（如果之前添加了，建议删除重新添加） 这个时候，就可以去登录开发者中心了，如果前面几步操作无误，就不会再提示让修改手机号了，然后点击同意协议就行了！ 最后别忘了把地区改回中国！ 网上有小伙伴给出了具体原因： 因为中国的iCloud数据转到中国,更新后数据在中国保存,开发中心获取不到导致的。 当然，还有一些小伙伴也有其他的方案，由于我们已经搞定了，所以就没有尝试，如果感兴趣可以试试！ 期间如果具体遇到了问题，我相信作为一个合格的开发的，难不到你，哈哈！ 好了，今天，我们就到这里 拜了个拜……]]></content>
      <categories>
        <category>Apple</category>
      </categories>
      <tags>
        <tag>Apple</tag>
        <tag>开发者中心更新手机号码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——Xcode默认路径(Fastlane打包)]]></title>
    <url>%2F2018%2F04%2F24%2FiOS%E2%80%94%E2%80%94Xcode%E9%BB%98%E8%AE%A4%E8%B7%AF%E5%BE%84-Fastlane%E6%89%93%E5%8C%85%2F</url>
    <content type="text"><![CDATA[最近在使用fastlane的时候，发现踩了不少坑，但是大部分由于时间的原因没能即使记录下来….. 最近在使用fastlane的时候，发现踩了不少坑，但是大部分由于时间的原因没能即使记录下来 这次简单的记录了一下前两天遇到的一个坑 事情是这样的，由于公司的一个测试机不知道被谁脑残似的点点了升级，于是系统直接到11.3，从而导致我的Xcode版本不支持对应真机的调试， 于是想着网上找对应的真机包，发现并没有找到，可能是我搜索能力不行，如果你有最新的，多多分享哦。 然后我就开始升级Xcode，但是发现升级Xcode又要升级系统，麻蛋。 于是就有了下面的一路升级系统升级Xcode 9.3编译一下，发现报错，报错的位置是WCDB，于是在官方群里问了一下，发现是WCDB的一个大坑，于是github有人提出了两种方式 在 Xcode 9.3 来 Swift 4.0.3 的方法，该方法可以临时解决 WCDB 的问题。 1. 下载并安装 Swift 4.0.3 的 toolchain: https://swift.org/builds/swift-4.0.3-release/xcode/swift-4.0.3-RELEASE/swift-4.0.3-RELEASE-osx.pkg 2. 在 Xcode 中选择 Preferences -&gt; Components -&gt; Toolchains，选择 Swift 4.0.3 Release 3. Clean 并重编你的 Xcode 工程 综合考虑之后，我暂时选择放弃的那台11.3的真机调试功能，只能通过扫描安装 于是又有了下面的一路 下载并安装Xcode 9.2编译项目….. 就在下班的时候，准备打包，没过几分钟就发现，变态的fastlane报错了（这是要闹哪一出，我都打算打完包直接闪人的） 具体错误如下：+-----------------------+---------+--------+ | Used plugins | +-----------------------+---------+--------+ | Plugin | Version | Action | +-----------------------+---------+--------+ | fastlane-plugin-pgyer | 0.2.1 | pgyer | +-----------------------+---------+--------+ [14:34:34]: ---------------------------------------- [14:34:34]: --- Step: Verifying fastlane version --- [14:34:34]: ---------------------------------------- [14:34:34]: Your fastlane version 2.89.0 matches the minimum requirement of 2.89.0 ✅ [14:34:34]: ------------------------------ [14:34:34]: --- Step: default_platform --- [14:34:34]: ------------------------------ [14:34:34]: Driving the lane &apos;ios development_build&apos; 🚀 [14:34:34]: 开始打development ipa [14:34:34]: ------------------------------ [14:34:34]: --- Step: get_build_number --- [14:34:34]: ------------------------------ 。。。。。。 [14:34:34]: fastlane finished with errors Looking for related GitHub issues on fastlane/fastlane... /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane_core/lib/fastlane_core/ui/interface.rb:145:in `shell_error!&apos;: [!] Exit status of command &apos;cd /Users/icocos/Desktop/\积\木\塔\科\技/\源\码/Fiction_iOS &amp;&amp; agvtool what-version -terse&apos; was 1 instead of 0. (FastlaneCore::Interface::FastlaneShellError) xcode-select: error: tool &apos;agvtool&apos; requires Xcode, but active developer directory &apos;/Library/Developer/CommandLineTools&apos; is a command line tools instance from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane_core/lib/fastlane_core/ui/ui.rb:17:in `method_missing&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/helper/sh_helper.rb:80:in `sh_control_output&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/helper/sh_helper.rb:12:in `sh&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/actions/get_build_number.rb:28:in `run&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/runner.rb:257:in `block (2 levels) in execute_action&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/actions/actions_helper.rb:50:in `execute_action&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/runner.rb:236:in `block in execute_action&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/runner.rb:231:in `chdir&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/runner.rb:231:in `execute_action&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/runner.rb:157:in `trigger_action_by_name&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/fast_file.rb:148:in `method_missing&apos; from Fastfile:10:in `updateProjectBuildNumber&apos; from Fastfile:45:in `block (2 levels) in parsing_binding&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/lane.rb:33:in `call&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/runner.rb:49:in `block in execute&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/runner.rb:45:in `chdir&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/runner.rb:45:in `execute&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/lane_manager.rb:57:in `cruise_lane&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/command_line_handler.rb:36:in `handle&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/commands_generator.rb:108:in `block (2 levels) in run&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1@global/gems/commander-fastlane-4.4.6/lib/commander/command.rb:178:in `call&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1@global/gems/commander-fastlane-4.4.6/lib/commander/command.rb:153:in `run&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1@global/gems/commander-fastlane-4.4.6/lib/commander/runner.rb:476:in `run_active_command&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane_core/lib/fastlane_core/ui/fastlane_runner.rb:75:in `run!&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1@global/gems/commander-fastlane-4.4.6/lib/commander/delegates.rb:15:in `run!&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/commands_generator.rb:333:in `run&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/commands_generator.rb:42:in `start&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/cli_tools_distributor.rb:107:in `take_off&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/bin/fastlane:20:in `&lt;top (required)&gt;&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/bin/fastlane:23:in `load&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/bin/fastlane:23:in `&lt;main&gt;&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/bin/ruby_executable_hooks:15:in `eval&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/bin/ruby_executable_hooks:15:in `&lt;main&gt;&apos; xcode-select: error: tool &apos;agvtool&apos; requires Xcode, but active developer directory &apos;/Library/Developer/CommandLineTools&apos; is a command line tools instance xcode-select: error: tool &apos;xcodebuild&apos; requires Xcode, but active developer directory &apos;/Library/Deve 我尝试着杀进程，重启电脑，升级fastlane，然而并没有什么卵用 于是网上到处寻找答案：按照stack中的方案一，卸载fastlane重新安装，捣鼓了一会打算重新打包的时候，还是这个错，我就很奇怪了， 然后，我整理了一下思路 Xcode9.2直接升级到9.3，升级和运行fasrlane，再次安装9.2，于是有了两个Xcode，当时我就蒙圈了 就根据具体问题网上找到了一个重置默认Xcode的方式： sudo xcode-select --switch /Applications/Xcode\ 9.2.app/Contents/Developer 以上错误是因为安装了 xcode , 但并不是系统默认的位置, 所以可以使用以下命令把 xcode 的路径修改为你安装的位置即可 switch后面部分就是安装的 xcode 的自定义路径. 再次运行fastlane，发现成功了，当时我真想扇自己两耳光. 这问题貌似并没有撒难度，只是当时急着上线，有点脑残了，耗费了我将近4个小时，然后悄悄的回家了， 到家已是2点多……]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Xcode默认路径（Fastlane打包的尴尬）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——3-rf一把无形的双刃剑]]></title>
    <url>%2F2018%2F04%2F20%2FiOS%E2%80%94%E2%80%943-rf%E4%B8%80%E6%8A%8A%E6%97%A0%E5%BD%A2%E7%9A%84%E5%8F%8C%E5%88%83%E5%89%91%2F</url>
    <content type="text"><![CDATA[今天我就遇到一个奇葩的问题，上一次编译并打包成功和这一次报错之间就一个上厕所的时间….. 大部分情况下，在项目报错的时候 很多人会选择clean再次编译 退出xcode重新编译 清楚drivedata重新编译 重启电脑重新编译 今天我就遇到一个奇葩的问题，上一次编译并打包成功和这一次报错之间就一个上厕所的时间。 具体错误ld: file too small (length=0) file &apos;/Users/icocos/Library/Developer/Xcode/DerivedData/Fiction_iOS-ccljhnehuyrphfbjlldfaqmstvub/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/RxSwift.build/Objects-normal/arm64/Just.o&apos; for architecture arm64 clang: error: linker command failed with exit code 1 (use -v to see invocation) 以上错误来自RXSwift。 查看git仓库，但是一句代码也没改，连一个空格都没有动 于是我就按照上面的走了一遍，发现并没有什么卵用,于是我在想:最后在一个群里有位大佬给了一个方案： rm -rf $HOME/Library/Developer/Xcode/DerivedData/* rm -rf $HOME/Library/Caches/com.apple.dt.Xcode/* rm -rf &quot;$(getconf DARWIN_USER_CACHE_DIR)/org.llvm.clang/ModuleCache&quot; 既然真的成功了。我们暂且把它叫做3rf。 关于rf这里有一个圈内的笑话：]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>3-rf一把无形的双刃剑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——奇葩需求QQ号与QQ群添加与跳转]]></title>
    <url>%2F2018%2F04%2F18%2FiOS%E2%80%94%E2%80%94%E5%A5%87%E8%91%A9%E9%9C%80%E6%B1%82QQ%E5%8F%B7%E4%B8%8EQQ%E7%BE%A4%E6%B7%BB%E5%8A%A0%E4%B8%8E%E8%B7%B3%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[最近在做一个新的二次元游戏App，说真的第一次做游戏一开始有点压力，但是后面了解到用到的技术其实跟游戏没有太多关系，就巴拉巴拉的开始写了，但是由于只有一个人，项目赶着上线，再加上之前需求的不明确和中途的调整，导致期间也浪费了不少时间，最近在实现最后一个功能的时候遇到了点问题，一开始是我想的太复杂了，后面群里一问，网上一了解，发现：MMP，这么简单，说多了都是尿，于是记录了这一切…….. 前言 本文的起因： 新项目，一个人纯swift开发，有个小功能第一次遇到，就是在用户中心有一行显示（群号+点击加群）文案，点击这一行拉起QQ App，如果QQ APP所登录的QQ已经加入了QQ号就直接到群聊页面，如果没有就跳到加群页面，可以点击申请加群。 注意： 这里其实是打开QQ后，使用QQ来去打开了一个网页。下面上代码： 一下是朋友提供的OC代码- (NSURL*)getQQQunUrl { NSString *qq_number = @&quot;??&quot; NSString* urlStr = [NSString stringWithFormat:@&quot;mqqapi://card/show_pslcard?src_type=internal&amp;version=1&amp;uin=%@&amp;key=%@&amp;card_type=group&amp;source=external&quot;, qq_number, @&quot;44a6e01f2dab126f87ecd2ec7b7e66ae259b30535fd0c2c25776271e8c0ac08f&quot;]; return [NSURL URLWithString:urlStr]; } 调用方式：NSURL* url = [self getQQqunUrl]; if ([[UIApplication sharedApplication] canOpenURL:url]) { [[UIApplication sharedApplication] openURL:url]; } 这是我最终Swift的实现方式func getQQQunUrl() -&gt; String { let qq_number = &quot;??&quot; let url_str = &quot;mqqapi://card/show_pslcard?src_type=internal&amp;version=1&amp;uin=\(qq_number)&amp;key=44a6e01f2dab126f87ecd2ec7b7e66ae259b30535fd0c2c25776271e8c0ac08f&amp;card_type=group&amp;source=external&quot; return url_str } 调用方式：let urlString = self.getQQQunUrl() if let url = URL(string: urlString) { //根据iOS系统版本，分别处理 if #available(iOS 10, *) { UIApplication.shared.open(url, options: [:], completionHandler: { (success) in }) } else { UIApplication.shared.openURL(url) } } 只要替换以上QQ好就可以，看着代码是不是很简单，算了不说了，我都想静一静…… 来看看效果图： 加群之前的效果 加群之后的效果 QQ号调整最近又有一个新的需求，由于需求比较相似，于是我直接在这里追加了。 需要处理QQ号的跳转，点击直接打开QQ调用网页版加号或者聊天页面 其实功能并没有任何难度在，其实寻找对应的链接，替换内部信息就可以。 一下只提供OC和Swift的关键代码： OC的实现方式//qqNumber就是你要打开的QQ号码， 也就是你的客服号码。 NSString *qqNumber=@&quot;QQ号&quot;; if ([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@&quot;mqq://&quot;]]) { UIWebView *webView = [[UIWebView alloc] initWithFrame:CGRectZero]; NSURL * url=[NSURL URLWithString:[NSString stringWithFormat:@&quot;mqq://im/chat?chat_type=wpa&amp;uin=%@&amp;version=1&amp;src_type=web&quot;,qqNumber]]; NSURLRequest *request = [NSURLRequest requestWithURL:url]; webView.delegate = self; [webView loadRequest:request]; [self.view addSubview:webView]; } Swift的实现方式// 打开Url class func openOuterUrl(_ url: String) { if let url = URL(string: url) { //根据iOS系统版本，分别处理 if UIApplication.shared.canOpenURL(url) { //根据iOS系统版本，分别处理 if #available(iOS 10, *) { UIApplication.shared.open(url, options: [:], completionHandler: { (success) in }) } else { UIApplication.shared.openURL(url) } } } } class func getQQUrl() -&gt; String { let url_str = &quot;mqq://im/chat?chat_type=wpa&amp;uin=\(self.getQQ())&amp;version=1&amp;src_type=web&quot; return url_str } 参考链接iOS调用QQ客户端,发起临时会话IOS APP中打开指定qq聊天界面]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>QQ号与QQ群添加与调整功能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——重整iOS技术（Fastlane完整打包流程）]]></title>
    <url>%2F2018%2F03%2F09%2FiOS%E2%80%94%E2%80%94%E9%87%8D%E6%95%B4iOS%E6%8A%80%E6%9C%AF%EF%BC%88Fastlane%E5%AE%8C%E6%95%B4%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[自从去年中旬电脑被我整挂了之后，大部分插件和脚本配置都失效了，重新安装也试了好几次，最近上班要上线了，不得不重新整理和配置一下，还好没有遇到什么坑…… 前言 项目即将进入阶段，每次都要点击那么多，频繁的打包脑子都要晕了，习惯了之前一行命令就搞定的我，只能花一个晚上加班整回之前的Fastlane。 本文采用的方案是：Fastlane + 蒲公英 + ……。 关于具体发布状态可以在这里（app-store, package, ad-hoc, enterprise, development）改，当然后面会结合App store发布最近本文内容，同时支持jenkins或者其他持续集成系统. Fastlane安装Fastlane是一套使用Ruby写的自动化工具集，用于iOS和Android的自动化打包、发布等工作，可以节省大量的时间。 安装过程如下： 1.检查Ruby版本，需要2.0及以上版本。在终端输入以下命令确认：ruby -v 需要注意的是需要将gem的source改为https://gems.ruby-china.org/。如何检查?在终端输入以下命令: gem sources 结果应为： *** CURRENT SOURCES *** https://gems.ruby-china.org/ 2.检查Xcode命令行工具是否安装。在终端输入以下命令：xcode-select --install 如果没有安装会进行安装。如果已经安装了则会提示： xcode-select: error: command line tools are already installed, use &quot;Software Update&quot; to install updates 3.安装Fastlanesudo gem install fastlane --verbose 如果出现以下错误： ERROR: While executing gem ... (Errno::EPERM) Operation not permitted - /usr/bin/rougify 则输入以下命令： sudo gem install -n /usr/local/bin fastlane 4.检查Fastlane是否正确安装。输入以下命令：fastlane --version 可以看到Fastlane版本信息，我的是2.85.0。 蒲公英的Fastlane插件安装打开终端，进入你的项目工程的根目录，输入以下命令： fastlane add_plugin pgyer 出现 Plugin &apos;fastlane-plugin-pgyer&apos; was added to &apos;./fastlane/Pluginfile&apos; It looks like fastlane plugins are not yet set up for this project. fastlane will create a new Gemfile at path &apos;Gemfile&apos; This change is necessary for fastlane plugins to work Should fastlane modify the Gemfile at path &apos;Gemfile&apos; for you? (y/n) 输入y按回车，出现 Installing plugin dependencies... Successfully installed plugins 便是安装成功了。 Fastlane配置1.打开终端，进入你的项目工程的根目录，输入以下命令：fastlane init 中间会让你输入苹果开发者账号的账号和密码，之后会在你项目工程的目录下生成一个fastlane文件夹，里面有Fastlane的配置文件，一个是Appfile文件，一个是Fastfile文件(如果要上传AppStore的话还有Deliverfile文件)。Appfile保存苹果开发者的相关信息、项目的相关信息等。Fastfile是运行脚本。 2.编辑Fastfile文件有时候一天需要打好几个包，为了区分，我们这里实现一个递增build号的功能。 (1)修改项目工程配置 修改Build Settings中的Versioning配置，Current Project Version随便填一个，Versioning System选择Apple Generic。 修改Info.plist File路径 (2)定义一个递增build号的函数，添加到Fastfile中def updateProjectBuildNumber currentTime = Time.new.strftime(&quot;%Y%m%d&quot;) build = get_build_number() if build.include?&quot;#{currentTime}.&quot; # =&gt; 为当天版本 计算迭代版本号 lastStr = build[build.length-2..build.length-1] lastNum = lastStr.to_i lastNum = lastNum + 1 lastStr = lastNum.to_s if lastNum &lt; 10 lastStr = lastStr.insert(0,&quot;0&quot;) end build = &quot;#{currentTime}.#{lastStr}&quot; else # =&gt; 非当天版本 build 号重置 build = &quot;#{currentTime}.01&quot; end puts(&quot;*************| 更新build #{build} |*************&quot;) # =&gt; 更改项目 build 号 increment_build_number( build_number: &quot;#{build}&quot; ) end 实现自动打包的完整Fastfile如下：可以直接拷贝修改# 定义fastlane版本号 ---- 修改 fastlane_version &quot;2.85.0&quot; # 定义打包平台 default_platform :ios def updateProjectBuildNumber currentTime = Time.new.strftime(&quot;%Y%m%d&quot;) build = get_build_number() if build.include?&quot;#{currentTime}.&quot; # =&gt; 为当天版本 计算迭代版本号 lastStr = build[build.length-2..build.length-1] lastNum = lastStr.to_i lastNum = lastNum + 1 lastStr = lastNum.to_s if lastNum &lt; 10 lastStr = lastStr.insert(0,&quot;0&quot;) end build = &quot;#{currentTime}.#{lastStr}&quot; else # =&gt; 非当天版本 build 号重置 build = &quot;#{currentTime}.01&quot; end puts(&quot;*************| 更新build #{build} |*************&quot;) # =&gt; 更改项目 build 号 increment_build_number( build_number: &quot;#{build}&quot; ) end #指定项目的scheme名称 ---- 修改 scheme=&quot;Fiction_iOS&quot; #蒲公英api_key和user_key ---- 修改 api_key=&quot;264c007c340157969a5e4da77637e60f&quot; user_key=&quot;3fdffa475f545097333473b980765ce1&quot; # 任务脚本 platform :ios do lane :development_build do|options| branch = options[:branch] puts &quot;开始打development ipa&quot; updateProjectBuildNumber #更改项目build号 # 开始打包 gym( #输出的ipa名称 output_name:&quot;#{scheme}_#{get_build_number()}&quot;, # 是否清空以前的编译信息 true：是 clean:true, # 指定打包方式，Release 或者 Debug configuration:&quot;Release&quot;, # 指定打包所使用的输出方式，目前支持app-store, package, ad-hoc, enterprise, development export_method:&quot;development&quot;, # 指定输出文件夹 output_directory:&quot;./fastlane/build&quot;, ) puts &quot;开始上传蒲公英&quot; # 开始上传蒲公英 pgyer(api_key: &quot;#{api_key}&quot;, user_key: &quot;#{user_key}&quot;) end end 注意：蒲公英的 api_key 和 user_key，开发者在自己账号下的 账号设置-API信息 中可以找到。打其它类型的包的方法与development类似，可自定义一个新的lane实现。 打包发布 在终端输入 fastlane development_build 便会进行自动打包并上传蒲公英了。 下面以执行流程 下面以执行结果 再来三张：入口，选项与结果]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>重整iOS技术（Fastlane完整打包流程）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS游戏——关于马甲包与审核]]></title>
    <url>%2F2018%2F01%2F26%2FiOS%E6%B8%B8%E6%88%8F%E2%80%94%E2%80%94%E5%85%B3%E4%BA%8E%E9%A9%AC%E7%94%B2%E5%8C%85%E4%B8%8E%E5%AE%A1%E6%A0%B8%2F</url>
    <content type="text"><![CDATA[最近因为工作的原因，博客与公众号停了近一个月，网站也没有及时更新，实在抱歉！当初也不知道哪里来的冲动，脑子一热就离开了多年的城市@广州，去了一个鸟都不拉屎的地方@东莞（有点夸张了，老铁！）。本以为是一个新的开始，本以为可以进入一个新的台阶，没料想，半年之久就遍体鳞伤的回到的这个梦想最开始的地方，其中的心酸就不便多说了，当然也让我学到了不少东西，认识了不少朋友和牛人……今天我们来聊的话题是：甲包与审核…… 引言：离开东莞之后，来到广州的一家新公司（创业公司），开始从事小说类游戏开发，说来也惭愧，以前不怎么玩游戏，最多偶尔玩一下近期比较火的游戏，也没有从事过任何游戏开发的工作，有几次有朋友看到我的英文名@iCocos都会问我，你之前事做游戏开发吗？当时我也只能无奈的解释一下： iCocos的含义是 i+ Coco + s = 苹果 + Cocoa Touch + s 取这个名字的原因是，一直以来都是从事iOS开发，而且对这一块比较喜欢，也很喜欢苹果的产品！ 接触iOS行业也有近四年多，第一次有幸进入游戏这个行业，以前很多同行（非游戏行业）朋友，包括我，一听到游戏行业和游戏开发就觉得很可怕。工资高，加班多——这是是很多人对游戏的行业的最初认识。 背景 项目启动不久，就接到公司内部关于游戏马甲包的整个对接与提审任务，后续也会一直负责这个任务，因为之前是由总部的一个多年Android开发并且有过一些iOS开发经验的同事负责，后面我进来之后iOS这一块也就有我对接处理了，当然其实有很多，我处理的只是其中一两个！ 因为之前上架过不少次，当时还是挺有自信的，但是经过了解和沟通之后发现其实并不是相信中的那么简单。 我还专门花时间在网上，群里，各大论坛和学习网站寻找相关的资料，希望能有一点帮忙！ 其中提到最多的就是关于审核的问题，而且这边同事也说了关于马甲包的审核，通过与否基本上靠运气，而且概率非常低！ 关于马甲包那么说了这么多，什么是马甲包呢？ 马甲APP指的是为了让认识你的人猜不到,在常用的用户名外再注册的其他名字的APP。 马甲APP与真实APP的区别是什么?相同的地方是什么? 应用名称不一样。 关键词不一样。 应用图标。不一样。 应用截图。可以一样,也可以不一样,不做要求。 开屏图片。最好不一样。 其余的,比如主APP的一些品牌因素,最好去掉。因为马甲是要用来做坏事的,当然不能让人察觉咯。 以上出自网络：关于为什么要做马甲APP? 马甲APP怎么做? 马甲APP需要事项? 可以查看下面网络来源说明: 什么是马甲APP？怎么用马甲APP导流 对接事项一直以来我们做的APP一般都是这几种情况： 从零开始发一个完整的项目，然后提审上线。 接手一个已经开发到一部分或者已经上线的迭代项目，然后提审上线。 接手一个审核被拒，根据苹果给出的条款修改内容，然后提审上线 有一些外包或者项目和公司比较特殊的情况 但是正因为是马甲包，所以比较例外，例外在哪里呢？ 我拿不到源码，改不了App内部的任何界面与效果 我只要修改提审内容信息，然后向渠道回到进度 审核几率非常低，而且经常要切换Apple账户处理 …… 操作流程所以在处理之前我这边其实大概根据之前的上线经验整理了一下具体的对接事项和具体步骤： 使用（或新）apple账号 apple developer生成并下载证书（开发与发布） apple developer创建一个Bundle ID apple developer添加设备ID apple developer创建并下载描述文件（开发与发布） itnues connect 创建一个对应ID的app 将证书导入到电脑钥匙串，右健对应证书到处P12 修改IAP支付信息（这种一般都是根据ID，不然会很麻烦） 提交或者修改App Icon，宣传图，应用名称,关键词,应用图标,文件等App和公司信息 将证书，描述文件，P12（+密码）和ID对应版本号ipa提供商 让他们根据重新出包，并提供新的ipa包 确认测试通过，并确认提审信息后，重新上传ipa 提交审核（使用手动发布模式）…… 跟渠道那边及时反馈进度 审核没通过则重新以上步骤（不用换账号还好，换账号是最虐心的！！！） 审核通过则先完成以下两个步骤再点击：发布： 1、通知CP切换到正式区服 2、通知我这边让后端把支付方式切换到第三方支付 最后注意一点： 有时候可能会涉及到SDK的处理，这个就要母包提前就准备好，并且根据实际需求替换对应的参数就可以由于这里已经涉及到SDK开发与集成的基础，已经不属于马甲包的范围 提审信息以下是我提供的数据证书与App提审信息证书与ipa信息 App提审信息 其实整个流程差不多就这么写，这里就不每一步网上都有对应的教程，而且很简单（傻瓜式），当然在整个过程也有可能遇到不少问题，这个就要根据个人经验和学习能力临时应变处理了，所以我就不一一介绍了。 补充：Android流程与注意事项以下是Android同事整理的流程与步骤，可能比较简洁，但是实际并没有这么简单，毕竟Android不像苹果那么多限制，仅供参考，具体流程还是要根据实际执行 反编译 母包 并且 集成了渠道sdk的demo 打开两者 反编译之后的目录进行资源替换 lib里面的so文件 smali源码 res的图片、value里面的资源 manifest的activity、权限等等，包名后面添加对应渠道的名字 注意：(除了3011,其他的渠道包还要修改appId、clientKey、clientId) 在eclipse新建一个同包名的项目， 拷贝修改后母包的res覆盖进去， 修改冲突ids(游戏母包也要修改)， 编译得到apk， 再反编译这个apk， 拿到包名对应下面的R$xxxx.smail覆盖到母包里面 后面就是提交apk或者发包的内容了 最后 那么说了这么多，好像里面学不到什么东西，我为什么还要写这篇文章呢？ 其实一开始不太想写，也确实没有太多有用的东西，但是我觉得写了还是会有一些用的！ 太久没有写博客和公众号了，有点手痒（哈哈！！！） 个人习惯，几乎接触第一次的领域，项目，技术都会简单记录一下 方便后面打算或者会负责此类任务的人，了解整个流程，也欢迎交流学习 最后一点其实也是最重要的，拒审多次，需求有经验的前辈，指点迷津！]]></content>
      <categories>
        <category>Games</category>
      </categories>
      <tags>
        <tag>Games</tag>
        <tag>关于马甲包与审核</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回顾与展望：梦想之路！]]></title>
    <url>%2F2017%2F12%2F31%2F%E5%9B%9E%E9%A1%BE%E4%B8%8E%E5%B1%95%E6%9C%9B%EF%BC%9A%E6%A2%A6%E6%83%B3%E4%B9%8B%E8%B7%AF%EF%BC%81%2F</url>
    <content type="text"><![CDATA[又是一次跨年之夜，又是一次年终总结。过去就一直有写总结回顾自己的成长，和往年一样，今年依旧是一个人坐在电脑旁，回顾着这一年中所经历与发生的一切！2017发生了很多事情，我也从中学到了很多，我开始更加地了解自己。…… 又是一次跨年之夜，又是一次年终总结。 过去就一直有写总结回顾自己的成长，和往年一样， 今年依旧是一个人坐在电脑旁，回顾着这一年中所经历与发生的一切！ 2017发生了很多事情，我也从中学到了很多，我开始更加地了解自己。 今年让我成长最大的就是： 发现了自己不足，不管是技术，还是人际关系。 脱离单身狗部队！ 实现了第一个小目标！ 下面我将从这一年来的各个方面总结一番，可能有点多，但是很有意义。 2017 @Swift2017@Swift——中国开发者大会（第二站） 会议时间：2017年5月13日-5月14日， 地址：深圳凯宾斯基酒店， 人数：400人 嘉宾：18人，其中8位国外，8位国内。 第一天所有外国嘉宾的演讲时间，第二天是国内大牛的演讲时间！ 记得第一站是去年在北京举行，当时项目太赶，就没有去，今年有幸能参加此次大会，并且收获真心不少。因此这里稍微整理了一下这两天最大的感触，和所学到的东西！ 2017 @Swift 中国开发者大会英语能力 交友 技术 英语为什么这里我把英语能力放在最前面，肯定是有原因的。 开会第一天所有都是老外，所有人都直接用英语讲，几乎听不太懂，所以导致很多东西根本没有听到重点与细节 会后交流，与提问，人家都能听懂，甚至都能提出自己的问题与观点，甚至还能通嘉宾进行更多更加升入的交流与讨论，而我却只能翻译或者发呆 技术的学习，几乎所有的最好，最新的技术资料都是从英文开始的，当你开始看中文翻译资料或者开始研究的时候，人家已经换了一种技术 后期的规划问题，出国旅游，出国发展（有点长远，当然也不是没有可能的），或者有机会接触外国朋友。 总结：针对程序员，哪怕只有一点基础的，技术这种东西都可以慢慢学，或者在实际项目中提高，如果你英文不好很多事情真的很难进行下去，除非你没有什么长远的目标或者没有自己个人的规划。 交友经过这次会议之后，看到了很多牛人，也认识了不少牛人之后才知道自己的渺小，才知道自己原来离期望中太远太远。 最有名的Swift框架RXSwift的作者 Google工程师 腾讯，美团，礼物说，阿里等一些非常厉害的架构师，同时也是技术迷 不少技术书籍的作者，其中有一位是我非常喜欢的巧哥@唐巧 不同公司的技术主管，开发人员，初入门的程序员 两天的会议中认识到了不少来自去全国各地参会者，也结下了不少好友！ 总结：永远不要觉得自己多牛逼，当你真的看到牛人之后你就会发现，其实自己真的很low，哪怕你做过再多项目，写过再多代码，不思考，不提升依然是个菜鸟。 技术主题就是Swift：iOS，后台肯定是重心 Swift实现AI，智能，机器学习，树莓派的结合，后期的转行。 实现属于自己的东西，小的方向比如小框架，静态或者动态库，大的话其中有人自己写了一个Swift转H5的编译器 App性能的提升，多线程，锁，MVVM, 自动化（测试，脚本） 包括开发，集成，测试，发布，维护需要有一套完成的规范与流程。 总之，程序员是一个需要时刻保持学习的职业，不学你就将被淘汰，不管学习技术，管理，社交，英语或者学习别人成功或失败的经验 未来的路还很长，希望一路上的坎坷能让我足够强大。 脱离单身狗部落今年终于不再被称之为单身狗了，对象是我高中同学，也是大学在处的女友， 因为毕业之后，发生了一些事情，也商量了一下，彼此奋斗。 于是一分开就是几年，再次相处之时，已经不再是年轻的的那种冲动， 更多的是成家立业，还有共同努力的梦想！ 于是，见了家长，并且预计两年左右成事……. 梦想之旅东莞梦想之路6月份的时候，一次偶然的计划接触到了一一五（广东一一五科技股份有限公司），并通过某些方式去了解更多关于此公司！ 开始是通过百度，知乎，微信或者QQ群，还有部分已经离职的朋友那里了解，一一五福利非常不错，而且挺大的，适合稳定发展！ 后面以一种尝试的形态投了一份简历，没想到既然真约我面试，而且面试了两轮以后，既然过了， 当时也确实想了很久，才最终决定离开这个梦想最开始的地方，去到了那个荒凉之地（个人半年来的体验） 其实，我原本可以留在广州，在一一五广州分部上班的，但是我也不记得当时是什么样的心态。 要说福利其实并没有说比广州要好多少，现在想想，又让我想起了那句话：to young to sinple 广州最好的两个基友一起吃饭的时候，说得最多的就是，让他不要去东莞，或者再多了解一下，但是并没有听进去什么！ 其实关于去东莞，去一一五，并没有什么后悔可言，即使没有长待，但是这半年我真的学到了很多东西。 不管在技术，学习能力，还是对一些大公司或者进大公司的看法，都有了一些重新的认识！ 同时结交了几个不错的朋友，并且结识了几位厉害的牛人！ 而且这几个月里面，通过各种努力，与计划，实现了我一直以来的第一个不算小的小目标！ 买了人生的第一辆爱车，虽然期间也发生了很多事情。 但是总算，不愧奋斗了这么多年！ 重回梦想之地从一一五离职之后，两天不到就收拾东西，回到了我一开始的梦想之地：广州！ 很多人都有问两个问题！ 为什么要离开一一五？那公司不是还不错吗？ 为什么不去深圳，却要来（去）广州？ 首先第一个问题，我就不方便详细回答了，也不想做过多的说明与评价，想了解更多关于115，可以百度或者私聊！ 那么至于我为什么要去广州？这里其实综合考虑了很久，可能个人看法或者对不同城市的体验不同！ 个人对广州确实怀有几分留恋，不管是因为他是我一开始的梦想之地，还是这几年来在广州所经历和所发生的一切， 我都觉得广州比较适合我，或者适合我未来的日子，适合我去实现自己的梦想！ 于是，我来广州后休息了几天，然后找了几天工作之后，拿到了一份理想的offer，可能只是短短的几个小时的聊天和了解。 但是我想说，既然选择了，我就相信这个公司，这个产品，这个团队。 我坚信，我，我们，我们的团队一定可以把这件事情做好，甚至以此去实现自己的梦想！ 未来的展望为了更加美好的2018 坚定一个最最基本的目标，而不是多大多宏伟，因为我觉得路需要一步一步走，太快了，你总会跌遍体鳞伤！ 说说我接下来的规划（我只谈短期3-5年）： 学习英语，不管是自学还是报班这都是现阶段挺重要的任务,同时也会长期的坚持下去。 深入Swift学习并进行项目实战优化，同时去了解Swift实现后台开发。 对PHP实战后台开发进一步的提升，完善个人网站个人博客，公众号。 iOS深挖：深入解析Max OS X &amp; iOS操作系统， 逆向工程 挖掘iOS音视频技术，并进行实战之旅！ 学习Python，了解机器学习等技术 学习RN基础，并进行实战开发与总结。 解决个人终身大事！ 梦想的城市，新的公司，新的项目，新的学习目标，新的梦想之旅！ 岁月不居，时节如流 我们共同走过的这一轮365天 或振奋人心，或略显伤感，或温暖如初 都是难忘的经历、记忆的珍藏……]]></content>
      <categories>
        <category>iCocos</category>
      </categories>
      <tags>
        <tag>iCocos</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——Swift 4.0 适配实战总结（Xcode9）]]></title>
    <url>%2F2017%2F11%2F27%2FiOS%E2%80%94%E2%80%94Swift-4-0-%E9%80%82%E9%85%8D%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93%EF%BC%88Xcode9%EF%BC%89%2F</url>
    <content type="text"><![CDATA[iOS的小伙伴有没有觉得今年特别与众不同，是因为iPhone X出来了吗？是的，但是不仅仅是因为iPhone X的面世。 还有 Xcode 9无线调试，Swift 4升级适配，iPhone X适配，前面介绍了iPhone X适配总结，这里整理一下Swift 4.0升级与适配处理….. 前言ios开发中，适配越来越多了： Xcode适配 Swift升级适配 iPhone适配 其中Xcode没有太多东西可说，最重要的是iPhone适配，尤其是最新的iPhone X的适配。 iPhone X的适配之前有整理过一篇文章根据实际进行总结iPhone X适配实战总结， 这里主要介绍一下最新版Swift 4适配，并简单的说一下关于Xcode9特性与适配的问题 关于Swift新特性可以参考这里：http://www.jianshu.com/p/f35514ae9c1a Xcode 9 中同时集成了 Swift 3.2 和 Swift 4。 Swift 3.2 完全兼容 Swift 3.1，并会在过时的语法或函数上报告警告。 Swift 3.2 具有 Swift 4 的一些写法，但是性能不如 Swift 4。 Swift 3.2 和 Swift 4 可以混合编译，可以指定一部分模块用 Swift 3.2 编译，一部分用 Swift 4 编译。 迁移到 Swift 4 后能获得 Swift 4 所有的新特性，并且性能比 Swift 3.2 好。 当 Xcode 正式版发布后，现有的 Swift 代码可以直接升级到 Swift 3.2 而不用做任何改动，也可以后续再迁移到 Swift 4。或者直接迁移到 Swift 4 也可以，Swift 4 相比 Swift 3 的 API 变化还是不大的，很多第三方库都可以直接用 Swift 4 编译。Swift 1 到 2 和 Swift 2 到 3 的迁移的痛苦在 3 到 4 的迁移上已经大大改善了。 适配关于Swift 4适配中OC与Swift混编的坑比较多 查看当前版本 当前环境 Mac OS 10.12.6 XCode 9.1 当前Swift版本 3.2 一键升级这一特性非常6，印象中是swift2的时候出来的，具体时间也忘了。 然后勾选需要转换的 target （pod 引用不用勾选），Next 然后选择转换选项，Next 这两个选项是关于 swift 的 @objc 推断特性的，如果使用了 swift4.0 显式的 @objc 属性，能减少整体代码的大小。此时我们选 Minimize Inference（recommend） Minimize Inference（recommend） 根据静态推断，仅在需要的地方添加@objc属性。使用此选项后，需要按照Completing a Swift 4 minimize inference migration来完成转换。 Match Swift 3 Behavior 在编译器隐式推断的任何地方向代码添加一个@objc属性。这个选项不会改变你的二进制文件的大小，因为被Swift 3隐式推断在所有的地方都添加了显式的@objc属性。 修改错误+细节 完成上面之后，不会发现当前版本确实编程的Swift 4，但是好像跑步起来，到处报错。 对，毕竟是工具，不可能那么人性化，有些地方还是需要人工进行专门的适配 问题一：编译不通过如果项目中之前有class和extension，有些也给OC调用。在OC的代码中，我们通过#import “ModuleName-Swift.h”导入了Swift文件。如果是Swift3.2，一切都能正常工作，但是在Swift4.0上，编译通不过了。 如果你看了Swift 4特性的话应该知道 swift4.0 最大的特性之一就是 @objc 修饰符的变化了，它主要处理 OC 和 swift 混编时一些方法的调用以及属性获取问题，swift4.0 将在 swift3.x 中一些隐式类型推断的特性去除以后，需要我们来手动管理 @objc 修饰符。 具体解决方案： 一：在OC中调用一个Swift4.0类的方法（包括实例方法、static方法、class方法），你需要： 在该Swift4.0类前加上修饰符@objc 该Swift4.0类必须继承NSObject(否则，无法在前面加上修饰符@objc。当然，这里指的是普通类，@objc也是可以修饰UI开头的一系列UIKit框架下的UI类，只是修饰了这些类，不会产生什么影响) 在需要调用的方法前加上修饰符@objc 二：在OC中调用一个Swift4.0扩展的属性（包括实例属性、static属性、class属性）、方法（包括实例方法、static方法、class法），你有如下两种选择方式： 在该Swift4.0扩展前加上修饰符@objc(这样的话，该扩展下的所有的属性、方法，都可被OC调用)。 在需要的属性、方法前直接加上@objc修饰，也可达到目的。 注意一点：swift3 使用 #selector 指定的方法，只有当方法权限为 private 时需要加 @objc 修饰符，swift4.0 都要加 @objc 修饰符swift4.0 不再允许重载 extension 中的方法(包括instance、static、class方法) 问题二：运行时找不到属性如果你有一个Swift类继承自UIViewController，OC中调用或者操作这个类[viewController valueForKey:@”userName”]这一KVC方法去获取这个自定义UIViewController中的iconURL这一属性的属性值。 这种方式，编译时是无法检查出问题的。但是在运行时，问题就来了，找不到这个属性。因为这个属性没有暴露给OC来进行调用。 解决方案： 仅需要在自定义的UIViewController类中给需要暴露给OC调用的属性前加上@objc修饰符便可。如此一来，在OC代码中就能访问到这个属性。 (注意：这里可不像上面提到的extension一样，在这个已定义的UIViewController类前面加上@objc修饰符没有任何意义)。 编译警告 swift 中编译的警告 “#selector” 参数指定的实例方法必须使用 @objc 修饰，因为swift4中弃用了 @objc属性推断。 Objective-C 编译时警告 在 OC 中调用的 swift 方法，在 swift 中需要追加 @objc 修饰，swift4 废弃了该类型推断。 关于编译时也是直接增加@objc即可运行时警告运行时警告会打印在控制台： ***Swift runtime: ClassName.swift:lineInFile:columnInLine: entrypoint -[ClassName methodName] generated by implicit @objc inference is deprecated and will be removed in Swift 4; add explicit @objc to the declaration to emit the Objective-C entrypoint in Swift 4 and suppress this message 同样：想要修复运行时警告，需要添加 @objc 修饰符到对应的方法或者符号。 运行时警告的常见原因: 在 OC 中使用 SEL 在 swift 中使用了 perform methods 在 OC 中使用了 performSelector methods 使用了 @IBOutlet 或者 @IBAction NSAttributedStringKeyswift3.x public init(string str: String, attributes attrs: [AnyHashable : Any]? = nil) swift4.0 public init(string str: String, attributes attrs: [NSAttributedStringKey : Any]? = nil) String废弃charactersswift 3 var count = string.characters.count error &apos;characters&apos; is deprecated: Please use String or Substring directly swift 4 count = string.count 废弃addingPercentEscapesswift 3 var url = @&quot;http://www.example.com?username=姓名&quot; url = url.addingPercentEscapes(using: String.Encoding.utf8)! error &apos;addingPercentEscapes(using:)&apos; is unavailable: Use addingPercentEncoding(withAllowedCharacters:) instead, which always uses the recommended UTF-8 encoding, and which encodes for a specific URL component or subcomponent since each URL component or subcomponent has different rules for what characters are valid. swift 4 uri = uri.addingPercentEncoding(withAllowedCharacters: CharacterSet.urlQueryAllowed)! 废弃substring(to:)swift 3 let index = tagText.index(tagText.startIndex, offsetBy: MPMultipleStyleListItemTagMaxLength) // 警告：&apos;substring(to:)&apos; is deprecated: Please use String slicing subscript with a &apos;partial range upto&apos; operator. let b = tagText.substring(to: index) Swift 4 let a = tagText.prefix(upTo: index) //a 的类型是 Substring，不是 String pod 引用添加以下内容到 Podfile。 post_install do |installer| installer.pods_project.targets.each do |target| if [&apos;WTCarouselFlowLayout&apos;, &apos;XSLRevenue&apos;, &apos;OHHTTPStubs/Swift&apos;].include? target.name target.build_configurations.each do |config| config.build_settings[&apos;SWIFT_VERSION&apos;] = &apos;3.2&apos; end end end end 系统方法UITableViewDelegate 协议方法名变更，没有错误提示： // swift3.x func tableView(_ tableView: UITableView, heightForRowAtIndexPath indexPath: IndexPath) -&gt; CGFloat // swift4.0 func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat Xcode 9关于Xcode 9适配其实并没有太多可说的地方，具体可参考苹果官方Session,但是我相信有一点是很多开发都非常喜欢的特性：无线调试 好处： 不用经常买线，不用担心接口或者插口坏了 不用担心忘记带线，无法调试 不用每次都插着才能调试（嘿，测试的MM，我给你装个最新的包，你接好了） … 要求 必须是Xcode9-beta以上 iPhone系统需iOS11以上 操作 在Xcode9-beta菜单的Window选项中选择Devices and Simulators 通过连接线让你的Mac识别到你的iPhone 在Devices and Simulators面板的左侧Connected菜单中选择连接的设备 在顶部的Devices和Simulators选项中选择Devices(这里其实默认就是选择了Devices)， 勾选Connect via network选项。 关于Xcode无线调试可参考下面地址 WWDC17惊喜——Xcode9无线调试https://icocos.github.io/2017/06/13/WWDC17%E6%83%8A%E5%96%9C%E2%80%94%E2%80%94Xcode9%E6%97%A0%E7%BA%BF%E8%B0%83%E8%AF%95/ 总结Swift3.2到Swift4.0的改变(只是我项目中遇到的)： Swift4.0中对于扩展的属性(包括实例属性、static属性、class属性)，都只能使用get方法，不可使用set方法 Swift4.0中不再允许复写扩展中的方法(包括实例方法、static方法、class方法) 编译期与运行时警告处理，添加 @objc 修饰符到对应的方法或者符号。 swift3使用#selector指定的方法，只有当方法权限为private时需要加@objc修饰符，现在全都要加@objc修饰符 字体方面的一些重命名 NSFontAttributeName重命名为NSAttributedStringKey.font、 NSForegroundColorAttributeName重命名为NSAttributedStringKey.foregroundColor、 NSStrikethroughStyleAttributeName重命名为NSAttributedStringKey.strikethroughStyle、 size(withAttributes:)方法重命名为size(withAttributes:)) … 官方参考资料 《Swift Language Programming (Swift 4.0)》 WWDC 2017 Session 402 《What’s New in Swift》 WWDC 2017 Session 212 《What’s New in Foundation》 WWDC 2017 Session 102 《Platforms State of the Union》]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift 4.0 适配实战总结（Xcode9）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native搭建与初始化项目]]></title>
    <url>%2F2017%2F11%2F21%2FReact-Nativec%E6%90%AD%E5%BB%BA%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[一年以前就听说React Native很火，很多移动端同学也都开始学习了，由于工作和各方面的原因，我一直与之无缘，最近有朋友说面试了几个公司，其中有两家公司要求会React Native，当时我也很奇怪，我咋地就一次没遇到过呢？而且公司对这方面都没有过要求，也没有这方面的开发，即使如此，但是还是激起了我去学习研究一下React Native的欲望，打算从零开始搞一个简单的App，总结并分析里面的一些实现，技术细节，还有关联技术…… 关于React Native是什么，有什么用，为什么会这么火这里就不多介绍了，相信你在网上随便一搜文章一大把。 这里主要介绍怎么从零开始入门React Native，并开发一个简单可用的App 准备工作 Mac OS X Xcode 8 HomeBrew:/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; Node.js: brew install nvm nvm install version/ nvm install stable nvm not found - export NVM_DIR=~/.nvm source $(brew –prefix nvm)/nvm.sh watchmain :监视文件修改、触发操作brew install watchman flow:语法检测器brew install flow React Nativenpm install -g react-native-cli 具体安装和下载步骤这里就不多说了，那属于准备工作，本文主要实战开发 安装结果 从源码一步一步解析它的实现原理 http://www.jianshu.com/p/5cc61ec04b39 创建项目执行下面开始创建项目 react-native init Hello 时间比较长，耐心等待 遇到的问题：中间可能会出现一些问题，其中提供一个出现最多的解决方案（这个问题我也遇到了，试了好几次都没有成功，每一次都好几个小时，以为是我的网络问题） 每次执行完react-native init Hello，就会出现下面的效果，然后一直卡在不动 在Stack Overflow找到了一个解决方案，目前问题已经解决了 vim ~/.npmrc registry = https://registry.npm.taobao.org 一开始只有：registry=http://registry.cnpmjs.org 根据实际结果应该是天朝网络的问题（你懂的…） 安装完成后命令行结果 执行以下： react-native run-ios / react-native run-android 这里主要以iOS为例 执行完之后你会看到进行一些加载和依赖的检测 然后会弹出一个新的窗口进行，扫描和加载准备工作， 最后会直接启动模拟器并提示 BUILD SUCCESS iOS执行结果： 没错，就是这么丑…… 关于Android配置相对iOS麻烦一点，具体过程可以参考下面Android Studio 这里安装的时候选择自定义，且勾选： SDK 安装下面部分想要下载的SDK，其中SDK Tools中有一个需要选的：Android SDk Build-Tools 23.0.1（这个必须选，另外可以增加其他的） 配置环境HOME 添加环境变量 其他插件工具和之前一样 权限问题期间如果遇到权限问题，可以直接修改文件夹或者文件对应权限 项目目录结果 后面会针对项目目录进行介绍与分析，并开始界面初始化，数据，逻辑相关处理，去完成第一个简单可用的React Native App]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
        <tag>React Native搭建与初始化项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——遇到的最奇葩的Bug]]></title>
    <url>%2F2017%2F11%2F20%2FiOS%E2%80%94%E2%80%94%E9%81%87%E5%88%B0%E7%9A%84%E6%9C%80%E5%A5%87%E8%91%A9%E7%9A%84Bug%2F</url>
    <content type="text"><![CDATA[我司有两个App，一个115，一个是115组织，每个人分别负责不同的模块，最近除了适配iPhone X，还处理一些遗留的问题（Bug），并跟进一些开发的需求。但是最近，前几天测试很强硬的跟我反馈的了一个Bug，说这个问题一定要想办法处理掉…………。 先来看看看具体的问题 这是具体出现这个奇葩Bug的现象（已打开图层）， 由于App实际效果现场暂时无法出现，所以抱歉，只能给出当时截图的图层调试效果 事情是这样的:我司有两个App，一个115，一个是115组织，每个人分别负责不同的模块，最近除了适配iPhone X，还处理一些遗留的问题（Bug），并跟进一些开发的需求。但是最近，前几天测试很强硬的跟我反馈的了一个Bug，说这个问题一定要想办法处理掉…… 测试反馈的具体问题： 底部TabBar条中多出一个Item。 115组织有（非常小概率）这样的现象，但是115没有出现过。 无法复现，但是出现之后就无法消失 ，只能结束进程。 根据上面测试人员反馈的问题，之前有专门负责模块的人有尝试处理过此问题，后面老大和大家也一起查找和分析过此问题，但是并没有实际验证并解决此问题…… 解决过程… 由于最近在开始适配iPhone X，公司仅有的一部测试机没有在我们总部现场，还在北京的分部，所以在我们进行适配后，测试人员无法验证问题，于是只能借用这边的Mac设置使用模拟器进行测试验证…… 就在某一天中午，iPhone X现在测试人员在群里说了一句： 这个Bug又出现了，并符上了截图。 而且此Bug在过去的一段时间里，测试人员也有反馈过，只是概率非常低，当我们再次进行验证调试的时候，且始终无法再现了，最终都以失败告终…… 这次终于有现场了，什么也不说，我停下了手上的所有工作，做到现场设备前开始调试，希望能解决这个一直以来存在的问题…… 由于之前在上一家公司遇到过一次这样的问题，但是当时的解决方案是： 没有使用之前的TabBar，并且部分代码都重写整理了，才处理次问题，但实际上并没有从根本解决这个Bug，后面由于项目太赶，也就没有管那么多了。但是这次可能不一样，就目前公司项目之庞大，肯定是没办法重写了，只能想办法找出具体问题，毕竟别人家的项目正常（或者我们另一个项目正常），这就是Bug，是Bug就要像办法解。 下面是我整个解决问题的过程 一：乱点一顿开始调试模式以后，我回到实际效果界面，随便点了几下界面（当时测试说了一句：一来就破坏现场，我……）,发现以下问题： 本来只有四个Item的（有文字和图片），但是现在貌似有五组文字，其中一组文字偏移了不少 重复的那组文字，在第一个Item对应标题的坐下角 重复的问题和对应的区域无法点击，或者点击相应的就是第一个Item的效果 重复的为文字是刚好是App上一个版本的第一个Item文字对应的标题文案， 出现之后，无论怎么操作都无法消失（即使退到了后台），只能杀掉进程 二：图层分析然后我们开启了图层调试模式，并仔细分析了一下，下面是具体效果 由此我们得出了一下结论 TabBar有五个Item， 异常的那个在图层的位置属于第三个 异常的那个在宽高貌似和其他四个相反（躺着的） 异常的那个原始X和Y值都是0 异常的那个只有问题没有图片 得到这些信息之后，我保留了一份效果并记录下来的这个信息 三：代码找到我找到的TabBarController，发现没有自定义的Tabar，使用的系统的tabBar，经过查找也没有发现有对应TabBarController和TabBar的分类，最终到唯一设置TabBarController对应控制器和相关标题文案，图的代码 //事务 self.oneVC = [[OneViewController alloc] init]; self.oneVC.title = NSLocalizedString(@&quot;事务&quot;, nil); self.oneVC.tabBarItem = [[UITabBarItem alloc] initWithTitle:NSLocalizedString(@&quot;事务+&quot;, nil) image:... selectedImage:...]; //提醒 self.twoVC = [[LifeMainViewController alloc] init]; self.twoVC.tabBarItem = [[UITabBarItem alloc] initWithTitle:NSLocalizedString(@&quot;提醒&quot;,nil) image:... selectedImage:...]; //我聊 self.three = [[ChatMainViewController alloc] init]; self.three.title = NSLocalizedString(@&quot;消息&quot;, nil); self.three.tabBarItem = [[UITabBarItem alloc] initWithTitle:NSLocalizedString(@&quot;我聊&quot;,nil) image:... selectedImage:...]; //组织 self.fourVC = [[UIStoryboard storyboardWithName:@&quot;Groups&quot; bundle:nil] instantiateViewControllerWithIdentifier:@&quot;COMainOfficeViewController&quot;]; self.fourVC.tabBarItem = [[UITabBarItem alloc] initWithTitle:NSLocalizedString(@&quot;组织&quot;,nil) image:... selectedImage:...]; self.viewControllers = @[[[UINavigationController alloc] initWithRootViewController:self.oneVC], //115 [[UINavigationController alloc] initWithRootViewController:self.twoVC], //提醒 [[UINavigationController alloc] initWithRootViewController:self.threeVC], //我聊 [[UINavigationController alloc] initWithRootViewController:self.fourVC]]; //组织 以上是所有TabBarController设置TabBar,Item，对应控制，标题，图片的代码（由于关系代码隐私，部分代码做了特殊处理）。 这段我仔细看了不下三遍，看来看去还是看不出任何问题,但是又感觉和我们之前使用的方式有撒不同的地方，差了一下另一个项目的对应代码，好像没有什么区别，只是那边自定义了一个TabBar. 四：根据错位文案全局查找由于上面错位Item的标题文案并不是我们设置的那四个Item的文案，只是同样是个Item，只有标题，没有图片而且是躺着的Item。 于是我全局搜索：“115组织”，发现马上有一百多个地方，当时我就懵逼了，也懒得吐槽。。。。。。。 直接查看这一百多个含有“115组织”文案的地方，并且根据类名从可能性高到底看，看完之后我们眼睛都在打转，也没有发现什么可用信息，只是熟悉了一遍代码…… 五：网上寻找答案于是我开始在进苹果官方论坛并查找相关的苹果文档资料，然后github，stackoverflow，百度，微博，贴吧，论坛，知乎等地方都搜了一遍相关资料，开始并没有找到什么根本问题，并且在几个比较值得发布的技术群里提出的请教….. 最后在stackoverflow中发现了一个问题： how to change uiviewcontroller title independent of tabbar item title 仔细看了一下下面的回答，虽然不是问题和答案不是和我们的这个问题相关，但是我们从这里找到了灵感。 从上面的实际效果和结论我们知道 多了一个Item 只有标题没有问题 位置在初始位置（0，0） 再回到上面的代码，我们发现只有第一个（事务）和第三个（我聊）使用的VC.title //事务 self.oneVC = [[OneViewController alloc] init]; self.oneVC.title = NSLocalizedString(@&quot;事务&quot;, nil); self.oneVC.tabBarItem = [[UITabBarItem alloc] initWithTitle:NSLocalizedString(@&quot;事务+&quot;, nil) image:... selectedImage:...]; //我聊 self.three = [[ChatMainViewController alloc] init]; self.three.title = NSLocalizedString(@&quot;消息&quot;, nil); self.three.tabBarItem = [[UITabBarItem alloc] initWithTitle:NSLocalizedString(@&quot;我聊&quot;,nil) image:... selectedImage:...]; 在要说区别就是组织使用的是StoryBard加载的控制器。 于是我开始猜想，难道真的在这里，但是为撒只有第一个有Bug，第三个没有Bug呢？ 六：群聊问答就在沉思和与同事讨论的时候，我之前在群里提过的问题，有人几个回答了，但是一开始都是让我直接搜索错位Bug显示对应的标题文案，仔细查看对应代码，检查tabBar控制器，Item标题等信息代码等等….. 后面有一个大牛说了一句话： 这是一个历史悠久的Bug，从iOS 5就开始有了，tabBarController对应子控制器标题最好不要这么设置，会有问题。 附上截图 顿时我好想又想到了stackoverflow的那个问题，并想起来项目中设置TabBarController对应控制器和相关标题文案，图的代码。好像终于找到了解决方案，但是是真的吗？我也不知道，因为前面提到了，无法复现了（这Bug非常变态，你想它出了，死都不出来，但是不知不觉可能又出来了，而那个时候是不是又不是调试模式）。 七：解决方案？ 最后我决定换掉上面设置TabBarController对应控制器和相关标题文案，图片的代码，并且和部门同事，测试人员一起想办法专门测了一下这个问题，但是最终一次都没有出现过，于是我就跟测试人员说：你先测试或者回忆一下之前出现的方案，尽量多测试一下，不管这个问题是不是真的解决了，跟其他同事也说一下，留意一下这个问题,然后就闪人了…… 回到座位后，我沉思了几秒，再回想了一下整个过程，并且带讽刺的微笑，问自己： 这个问题真的解决了吗？我也不知道.......]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>开发文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——免密登录，我以为有多难？]]></title>
    <url>%2F2017%2F11%2F18%2FiOS%E2%80%94%E2%80%94%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%EF%BC%8C%E6%88%91%E4%BB%A5%E4%B8%BA%E6%9C%89%E5%A4%9A%E9%9A%BE%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[以前总是在群里或者网上听说什么：单点登录，免密登录，因为没有听过，所以感觉很高大上的样子，最近一次免密登录的开发需求，差点给自己打脸了……… 前言： 最近公司要开发一个免密登录的需求，以前好像听过，感觉没撒用处，就没有去管了。 因此不得不研究一下，原本以为会和某些第三方一样，各种配置，导入，各种坑，却没想到……哎！ 背景现在很多人在使用一个App的时候，遇到这样的一些问题： 经常需要输入账号密码，手动或者自动退出 如果账号或者密码一次输错又要重新输入，甚至各种验证。 有时候密码不太记得了，就要狠麻烦的修改或者找回 如果涉及到太多安全信息在里面，输入的时候可能会特别小心。 …. 有了上面这些问题之后，自然也有很多公司或者技术人员考虑了很多技术或者涉及上的解决方案。其中免密登录被公认为是一种不错的选择，即使也有一些缺陷…… 什么是：免密登录免 密登录的意思 : 就 是 免 密认证，是利用了电信运营商独有的移动网络安全认证，实现手机号码认证登录、手机号码 就 是账号，无需设置密码，由运营商移动网络认证。 天翼基于各行业的合作，天翼账号为合作方提供一套智能认证解决方案，”免密认证“和”运营商能力“： “免密认证”，依托电信运营商的移动数据网络，采用“通信网关取号”及SIM卡识别等技术，准确识别用户手机号码。依托运营商计费网络更“快，准，安全”。 “运营商能力”，基于天翼手机用户的二次卡校验，实名校验，用户信用等多种基于运营商的特色功能。 移动统一认证是中国移动推出的手机号码认证功能，应用集成后可通过数据网络、短信网关获取本机号码（覆盖移动、电信、联通手机号），实现手机用户免输账号密码一键注册/登录。 同时，应用可获取更多用户授权的号码信息，调用更多的用户身份认证功能。如：本机号码校验、号码状态查询、二次卡查询、实名认证、防刷单、互联互通等服务。 由于天翼帐号免密登录在移动号码上的成功率不高，有些公司会考虑接入移动帐号免密登录来改善或者进行双重介入与验证判断（我们就是这做的）。 具体需求 当前手机无SIM卡/网络情况差，调用免密登录接口失败时，走短信登录流程； 有SIM卡且网络比较稳定，判断该手机号类型， 如果是移动卡，调用移动免密登录的接口，走移动帐号免密登录流程， 其他类型则调用移动免密登录的接口，走现有的天翼帐号登录流程。 当有双卡双待时，本机号码为启用了移动网络数据的那个。 核心代码 开发与操作流程1. 运营商类型判断定义枚举 typedef NS_ENUM(NSInteger, SSOperatorsType) { // Apple NetworkStatus Compatible Names. // 参考 https://en.wikipedia.org/wiki/Mobile_country_code Other = 0, // 中国移动 Mobile = 1, // 中国联通 Unicom = 2, // 中国联通 Telecom = 3, // 中国电信 Tietong = 4 // 中国铁通 }; 2. 库导入#import &lt;CoreTelephony/CTCarrier.h&gt; #import &lt;CoreTelephony/CTTelephonyNetworkInfo.h&gt; 3. 类型获取/** 获取运营商类型 @return 对应的运营商类型（枚举） */ + (SSOperatorsType)getOperatorsType{ CTTelephonyNetworkInfo *telephonyInfo = [[CTTelephonyNetworkInfo alloc] init]; CTCarrier *carrier = [telephonyInfo subscriberCellularProvider]; NSString *currentCountryCode = [carrier mobileCountryCode]; NSString *mobileNetWorkCode = [carrier mobileNetworkCode]; if (![currentCountryCode isEqualToString:@&quot;460&quot;]) { return Other; } // 参考 https://en.wikipedia.org/wiki/Mobile_country_code if ([mobileNetWorkCode isEqualToString:@&quot;00&quot;] || [mobileNetWorkCode isEqualToString:@&quot;02&quot;] || [mobileNetWorkCode isEqualToString:@&quot;07&quot;]) { // 中国移动 return Mobile; } if ([mobileNetWorkCode isEqualToString:@&quot;01&quot;] || [mobileNetWorkCode isEqualToString:@&quot;06&quot;] || [mobileNetWorkCode isEqualToString:@&quot;09&quot;]) { // 中国联通 return Unicom; } if ([mobileNetWorkCode isEqualToString:@&quot;03&quot;] || [mobileNetWorkCode isEqualToString:@&quot;05&quot;] || [mobileNetWorkCode isEqualToString:@&quot;11&quot;]) { // 中国电信 return Telecom; } if ([mobileNetWorkCode isEqualToString:@&quot;20&quot;]) { // 中国铁通 return Tietong; } return Other; } 4. 移动判断/** 移动运营商类型判断 @return 布尔值（是否是移动运营商类型） */ - (BOOL)checkOperatorsTypeChinaMobile { return [NetWorkState getOperatorsType] == Mobile; } 具体实现代码（抽取封装之后的）//免密登录 //1.本机手机号未注册过115帐号，则免密登录后自动注册、登录、绑定本机手机号。 //2.本机手机号已注册过115帐号，则直接登录该帐号。 //3.客户端判断当前启用移动网络数据的号码是否属于移动， //属于则走移动免密登录流程， //不属于则走现有的天翼免密流程 if ([[NetWorkState shareNetWork] checkOperatorsTypeChinaMobile]) { ///移动接口接入地址 http://dev.10086.cn/wiki/?p5_01_03#p2-2 [UMCOpenLogin loginExplicitly:self complete:^(id sender) { if ([sender[@&quot;resultcode&quot;] isEqual:@&quot;000&quot;] &amp;&amp; sender[@&quot;uniqueid&quot;] &amp;&amp; sender[@&quot;accesstoken&quot;]) { [MBProgressHUD showLoading:NSLocalizedString(@&quot;正在登录...&quot;,nil)]; [COLoginService noCodeLoginWithToken:sender[@&quot;accesstoken&quot;] uniqueId:sender[@&quot;uniqueid&quot;] block:^(id _Nonnull model, NSError * _Nonnull error) { [MBProgressHUD hide]; }]; } else if(![sender[@&quot;resultcode&quot;] isEqual:@&quot;102121&quot;]) { [self smsVerifyCodeLogin]; } }]; } else { ///天翼接口接入地址 http://id.189.cn/api?initialSrc=/html/api_detail_447.html [EAccount login:@&quot;&quot; loginWay:@&quot;zm|dm&quot; accountType:@&quot;&quot; loginList:@[] hasat:NO hideTop:NO baseApp:YES basicLoginTxt:@&quot;短信登录&quot; controller:self success:^(NSDictionary * _Nonnull resultDic) { if (resultDic[@&quot;accessToken&quot;]) { [MBProgressHUD showLoading:NSLocalizedString(@&quot;正在登录...&quot;,nil)]; [COLoginService noCodeLoginWithToken:resultDic[@&quot;accessToken&quot;] uniqueId:nil block:^(id _Nonnull model, NSError * _Nonnull error) { [MBProgressHUD hide]; }]; } } failure:^(NSError * _Nonnull error) { NSLog(@&quot;error%@&quot;, error); if (error.code == -8994014) { [self smsVerifyCodeLogin]; } else { [MBProgressHUD showError:error]; } }]; } 免密登录后的流程 获取用户信息 通过获取用户信息接口，在用户登录后可以获取用户昵称、手机号码、头像等信息，需要对接获取用户信息接口. 刷新accessToken accessToken是调用账号登录的调用凭证，accessToken有效期为1个月 在有效期内避免accessToken过期后，可以在用户打开应用时使用刷新accessToken接口进行刷新. 相关API：登录相关接口这里只介绍一下登录相关，其他Api可自行查阅API文档和源代码 天翼API：/** 打开登录页面 @param showThirdLogin 第三方登录的配置，有qq，微博，微信三个，要哪个登录方式，就传对应的拼音，如@&quot;qq&quot; 或者@&quot;qq|weixin&quot; 或者@&quot;qq|weixin|weibo&quot; @param loginWay 登录方式，zm、dm、zm|dm、dm|zm等4种方式，zm代表账号密码登录，dm，代表短信验证码登录，zm|dm代表两种都有，并且优先账号密码登录, dm|zm代表两种都有，优先短信登录 @param accountType 账号类型，有mobile,email两种，两种都要的话，传@&quot;mobile|email&quot;，否则传@&quot;mobile&quot; 或者@&quot;email&quot; @param loginList 已经登录上的账号的accessToken组成的数组，不需要多账号功能的，可以传一个空的数组 @param hasat 登录页面的登录账号是否默认加上@189.cn，yes表示有后缀，no表示没有后缀 @param hideTop 是否隐藏头部导航栏 @param baseApp 自定义账号入口方式 @param basicLoginTxt 自定义账号入口方式的自定义文本 （6到8个字符） @param controller 可以为nil，如果是nil，SDK会新建一/Users/thy/TY/EAccountSDK_WIFI/EAccountSDK/EAccountSDK/EAccount.h个window来加载登录页面，如果不是空，SDK会使用controller来preszent登录页面。 @param success 登录成功的回调 @param failure 登录失败的回调 */ + (void)login:(NSString *)showThirdLogin loginWay:(NSString *)loginWay accountType:(NSString *)accountType // loginList:(NSArray *)loginList hasat:(BOOL)hasat hideTop:(BOOL)hideTop baseApp:(BOOL)baseApp basicLoginTxt:(NSString *)basicLoginTxt controller:(nullable UIViewController *)controller success:(successHandler)success failure:(failureHandler)failure; 移动API：/** 显式登录 */ + (void)loginExplicitly:(UIViewController *)vc complete:(void (^)(id sender))complete; 总结 免密登录主要体现在安全性上，手机丢了，那么就麻烦大了， 而且现在的黑科技太发达了，短信截获、伪装基站、伪装商家服务号、复制SIM 卡…… 用手机号登录、用短信验证码的方式真的安全吗？！]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>免密登录，我以为有多难？</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——iPhone X适配实战总结]]></title>
    <url>%2F2017%2F11%2F18%2FiOS%E2%80%94%E2%80%94iPhone-X%E9%80%82%E9%85%8D%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[最近公司项目需要开始适配iPhone X了，之前在网上看到过很多讲解iPhone X适配的文章，也刷过几篇文章看了一遍，但是看完之后实在受不了各种假帖。甚至讲的都是一些理论和差异上的东西，真正讲解实际开发中适配iPhone的并没有多少，有些看完正片文章之后都不知道怎么开始。于是自己去根据官方提供的资料和指南写一篇只针对iPhone X适配的贴子…… 前言： 本文从实际开发着手iPhone X适配，关于相关理论与常识内容不会过多解释。 本文会分析iPhone X适配的几个不同方向和相关的处理方案 本文会分析并总结适配和测试过程中遇到的Bug，最终给出实际的适配方案或者代码 本文会尽量多的从实际项目与实际适配步骤会代码进行介绍 官方资料HIG-Human Interface Guideline官方Session 首先我们要明确一点：iPhone X适配的宗旨：我们要做的是让那些不能被遮挡的内容和控件在安全区域范围内显示,一.iPhone X的规则| | | iPhone X是真正的3x标准，印象中7p是2.88x iPhone X宽度和4.7的6，7，8一致（375），高度多出145pt（+20%） iPhone X的比例是9：19.5，而4.7的6，7，8比例是9：16， iPhone X（375812-&gt;11252436-&gt;5.8英寸）Super Retina 状态栏20-&gt;44(留海H=30，W=209,耳朵W=83)，底脚0-&gt;34 实际上可有效利用的高度为：145 – 24 (Status Bar) – 34 (Home Indicator) = 87pt 键盘高度由 216pt 增长为 291pt，设计文字区域时要小心 Home Indicator，Tab Bar 高度由 49pt 增长为 83pt 横屏时Home Indicator的高度为21pt，需要格外注意 | | | iPhone X竖屏时占满整个屏幕的控制器的view的safeAreaInsets是（44，0，34，0），横屏是（0，44，21，44），inset后的区域正好是safeAreaLayoutGuide区域 如果你的 UI「顶部」有 Navigation Bar 或其它类似的UI控件，那么一般来说，在设计稿将 Navigation Bar 的背景色往上延伸 44pt，「垫在 Status Bar 后方」作为背景色即可如果你的 UI「底部」有 Tab Bar、Toolbar 或其它类似的UI控件，在设计稿时将背景色往下延伸 34pt，「垫在 Home Indicator 后方」作为背景色即可。 二： iOS11相关 如果只是设置了titleView，没有设置barbutton，把titleview的宽度设置为屏幕宽度，则titleview距离屏幕的边距，iOS11之前，在iPhone6p上是20p，在iPhone6p之前是16p；iOS11之后，在iPhone6p上是12p，在iPhone6p之前是8p。 如果只是设置了barbutton，没有设置titleview，则在iOS11里，barButton距离屏幕的边距是20p和16p；在iOS11之前，barButton距离屏幕的边距也是20p和16p。 如果同时设置了titleView和barButton，则在iOS11之前，titleview和barbutton之间的间距是6p，在iOS11上titleview和barbutton之间无间距 estimatedRowHeight是一个预估高度，iOS11之前是为0，在iOS11下，这个值默认为44。 iOS11以前,我们布局时, 视图的 top 和 bottom 一般参照的是 Top Layout Guide 和 Bottom Layout Guide iOS11为UIViewController和UIView增加了两个新的属性safeAreaInsets和safeAreaLayoutGuide, 通过这两个属性我们可以获得安全区域的范围 safeAreaInsets 适用于手动计算. safeAreaLayoutGuide 适用于自动布局. 三. iPhone环境判断 通过分辨率判断：#define kDevice_Is_iPhoneX ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(1125, 2436), [[UIScreen mainScreen] currentMode].size) : NO) 通过设备名称判断：@&quot;iPhone10,1&quot; : @&quot;iPhone 8&quot;, @&quot;iPhone10,4&quot; : @&quot;iPhone 8&quot;, @&quot;iPhone10,2&quot; : @&quot;iPhone 8 Plus&quot;, @&quot;iPhone10,5&quot; : @&quot;iPhone 8 Plus&quot;, @&quot;iPhone10,3&quot; : @&quot;iPhone X&quot;, @&quot;iPhone10,6&quot; : @&quot;iPhone X&quot;, 判断状态栏的高度（如果状态栏没有隐藏，且竖屏的情况） 判断屏幕的高度或者宽度（横屏的时候） 根据是否可执行或者获取对应API的值（safeAreaInseret） 根据系统框架 常用宏定义#define IS_IPHONE_X_HEIGHT ([[UIScreen mainScreen] bounds].size.height &gt;= 812.0f ? 812.0f : 667.0f) #define ScaleWidth(width) width/ 375.0*KSCREEN_WIDTH #define ScaleHeigth(height) height/IS_IPHONE_X_HEIGHT*KSCREEN_HEIGHT #define WKSW(width) width/375.0*KSCREEN_WIDTH #define WKSH(height) height/IS_IPHONE_X_HEIGHT*KSCREEN_HEIGHT #define SafeAreaTopHeight (kWJScreenHeight == 812.0 ? 88 : 64) #define VIEWSAFEAREAINSETS(view) ({UIEdgeInsets i; if(@available(iOS 11.0, *)) {i = view.safeAreaInsets;} else {i = UIEdgeInsetsZero;} i;}) VIEWSAFEAREAINSETS(view).left VIEWSAFEAREAINSETS(self.view).right 四.启动页的适配启动页的启动方式 LaunchScreen(这里直接设置图片就可以) LaunchImage 使用对应的设计图片：1125 * 2436 如果使用的是Assets中的LaunchImage, 在增加了iPhone X尺寸的图片配置.准备一张尺寸:1125 * 2436的启动图片, 移动到LaunchImage的Finder目录中, 并在LaunchImage中的Contents.json文件中增加 (注意Json格式): { &quot;extent&quot; : &quot;full-screen&quot;, &quot;idiom&quot; : &quot;iphone&quot;, &quot;subtype&quot; : &quot;2436h&quot;, &quot;filename&quot; : &quot;图片名.png&quot;, &quot;minimum-system-version&quot; : &quot;11.0&quot;, &quot;orientation&quot; : &quot;portrait&quot;, &quot;scale&quot; : &quot;3x&quot; } 五.刷新框架的适配iOS11这里拿最有名的刷新框架,如果使用的类似的刷新框架并且隐藏导航那么你或许会遇到：刷新控件和留海重合且被挡住 具体原因：iOS 11上面废除了automaticallyAdjustsScrollViewInsets，使用contentInsetAdjustmentBehavior代替 适配具体代码： if (@available(iOS 11.0, *)) { self.home_collectionView.contentInsetAdjustmentBehavior = UIApplicationBackgroundFetchIntervalNever; } else { self.automaticallyAdjustsScrollViewInsets = false; // Fallback on earlier versions } 宏定义：/// 第一个参数是当下的控制器适配iOS11 一下的，第二个参数表示scrollview或子类 #define AdjustsScrollViewInsetNever(controller,view) if(@available(iOS 11.0, *)) { view.contentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever; } else if([controller isKindOfClass:[UIViewController class]]) { controller.automaticallyAdjustsScrollViewInsets = false; } 六：导航栏在iOS11导航栏多了一个LargeTitleView，专门显示大字标题用的，整个导航栏的高度达到了96p，这不包括状态栏的高度，也就是说，整个app顶部高度达到了116p，其中statusbar=20，title=44，largetitle=52，不过默认是64p； 当然，iPhoneX的高度会更高点，如果不显示大字标题，顶部的高度也达到了88，statusbar=44，title=44，如果显示大字标题，则高度变成了140，statusbar=44，title=44，largetitle=52，也就是说，iPhoneX的刘海高度为24p， 七：导航栏按钮间距变化(UIBarButtonItem) (iPhoneX &amp; iOS 11)iOS11以后，导航栏的层级发生了变化，也无法时使导航栏左右按钮边距为0了 iOS11之前导航栏的title是添加在UINavigationItemView上面，而navigationBarButton则直接添加在UINavigationBar上面，如果设置了titleView，则titleView也是直接添加在UINavigationBar上面。iOS11之后，大概因为largeTitle的原因，视图层级发生了变化，如果没有给titleView赋值，则titleView会直接添加在_UINavigationBarContentView上面，如果赋值了titleView，则会把titleView添加在_UITAMICAdaptorView上，而navigationBarButton被加在了_UIButtonBarStackView上，然后他们都被加在了_UINavigationBarContentView上 所以如果你的项目是自定义的navigationBar，那么在iOS11上运行就可能出现布局错乱的bug，解决办法是重写UINavigationBar的layoutSubviews方法，调整布局，上代码： - (void)layoutSubviews { [super layoutSubviews]; //注意导航栏及状态栏高度适配 self.frame = CGRectMake(0, 0, CGRectGetWidth(self.frame), naviBarHeight); for (UIView *view in self.subviews) { if([NSStringFromClass([view class]) containsString:@&quot;Background&quot;]) { view.frame = self.bounds; } else if ([NSStringFromClass([view class]) containsString:@&quot;ContentView&quot;]) { CGRect frame = view.frame; frame.origin.y = statusBarHeight; frame.size.height = self.bounds.size.height - frame.origin.y; view.frame = frame; } } } 看了简书App适配iOS11发现titleView支持autolayout，这要求titleView必须是能够自撑开的或实现了- intrinsicContentSize方法 - (CGSize)intrinsicContentSize { return UILayoutFittingExpandedSize; } 导航栏新增了一种大标题样式，默认设置是不开启，所以不需要修改。 titleView支持autolayout，这要求titleView必须是能够自撑开的或实现了- intrinsicContentSize， App需要实现导航栏左右按钮边距为0 八：继承自UIScrollView的视图偏移问题在iOS11设备上运行出现最多问题应该就是tableview莫名奇妙的偏移20pt或者64pt了。。原因是iOS11弃用了automaticallyAdjustsScrollViewInsets属性（前面有提到），取而代之的是UIScrollView新增了contentInsetAdjustmentBehavior属性，这一切的罪魁祸首都是新引入的safeArea， 原因分析 原因是iOS 11中Controller的automaticallyAdjustsScrollViewInsets属性被废弃了，所以当tableView超出安全区域时系统自动调整了SafeAreaInsets值，进而影响adjustedContentInset值，在iOS 11中决定tableView的内容与边缘距离的是adjustedContentInset属性，而不是contentInset。adjustedContentInset的计算方式见本文第二部分内容。因为系统对adjustedContentInset值进行了调整，所以导致tableView的内容到边缘的距离发生了变化，导致tableView下移了20pt（statusbar高度）或64pt（navigationbar高度）。 如果你的APP中使用的是自定义的navigationbar，隐藏掉系统的navigationbar，并且tableView的frame为(0,0,SCREEN_WIDTH, SCREEN_HEIGHT)开始，那么系统会自动调整SafeAreaInsets值为(20,0,0,0)，如果使用了系统的navigationbar，那么SafeAreaInsets值为(64,0,0,0)，如果也使用了系统的tabbar，那么SafeAreaInsets值为(64,0,49,0) if (@available(iOS 11.0, *)) { self.tableView.contentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever; } else { self.automaticallyAdjustsScrollViewInsets = NO; } 这个问题的解决方法有哪些？ 重新设置tableView的contentInset值，来抵消掉SafeAreaInset值，因为内容下移偏移量 = contentInset + SafeAreaInset； 如果之前自己设置了contentInset值为(64,0,0,0),现在系统又设置了SafeAreaInsets值为(64,0,0,0)，那么tableView内容下移了64pt，这种情况下，可以设置contentInset值为(0,0,0,0)，也就是遵从系统的设置了。 设置tableView的contentInsetAdjustmentBehavior属性 如果不需要系统为你设置边缘距离，可以做以下设置： //如果iOS的系统是11.0，会有这样一个宏定义“#define __IPHONE_11_0 110000”；如果系统版本低于11.0则没有这个宏定义 #ifdef __IPHONE_11_0 if ([tableView respondsToSelector:@selector(setContentInsetAdjustmentBehavior:)]) { tableView.contentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever; } #endif contentInsetAdjustmentBehavior属性也是用来取代automaticallyAdjustsScrollViewInsets属性的，推荐使用这种方式。 通过设置iOS 11新增的属性addtionalSafeAreaInset； iOS 11之前，大家是通过将Controller的automaticallyAdjustsScrollViewInsets属性设置为NO，来禁止系统对tableView调整contentInsets的。如果还是想从Controller级别解决问题，那么可以通过设置Controller的additionalSafeAreaInsets属性，如果SafeAreaInset值为(20,0,0,0)，那么设置additionalSafeAreaInsets属性值为(-20,0,0,0)，则SafeAreaInsets不会对adjustedContentInset值产生影响，tableView内容不会显示异常。 这里需要注意的是addtionalSafeAreaInset是Controller的属性，要知道SafeAreaInset的值是由哪个Controller引起的，可能是由自己的Controller调整的，可能是navigationController调整的。是由哪个Controller调整的，则设置哪个Controller的addtionalSafeAreaInset值来抵消掉SafeAreaInset值。 九：UITableView，cell，header，footer高度异常,tableView顶部有留白在iOS 11中默认启用Self-Sizing，，Headers, footers, and cells都默认开启了Self-Sizing，所有estimated 高度默认值从iOS11之前的 0 改变为UITableViewAutomaticDimension要解决此类异常的话，可通过以下代码解决 _tableView.estimatedRowHeight = 0; _tableView.estimatedSectionHeaderHeight = 0; _tableView.estimatedSectionFooterHeight = 0; 这个配合estimatedRowHeight、estimatedSectionFooterHeight、estimatedSectionHeaderHeight使用，可以预估高度。之前，设置header或者footer高度为0时，需要设置height=0.1，才会起作用，如果直接设置为0，则会使用默认高度。iOS11由于自动使用预估高度，所以，忽略了设置的高度，使原来的高度增大了。只要把这几个属性设置为0就可以解决 在iOS11里面有时候在tableView的头部和尾部留白，因为苹果给滚动试图加进去了self-sizeing，开始计算逐步计算contentSize，默认如果不去实现viewForHeaderInSection就不会调用heightForHeaderInSection,尾部试图一样。func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -&gt; UIView? { } func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -&gt; CGFloat { return 0.001 } 如果你不想实现viewForHeaderInSection也不想留白，那么只需要使用上面的三段代码把self-sizeing自动估高关闭即可 如果你使用了Masonry，某些界面需要适配需要适配safeArea，可以试试下面这段代码 if (@available(iOS 11.0, *)) { make.edges.equalTo()(self.view.safeAreaInsets) } else { make.edges.equalTo()(self.view) } 十：适配iOS 11 列表的册数删除在iOS8之后，苹果官方增加了UITableVIew的右滑操作接口，即新增了一个代理方法(tableView: editActionsForRowAtIndexPath:)和一个类(UITableViewRowAction)，代理方法返回的是一个数组，我们可以在这个代理方法中定义所需要的操作按钮(删除、置顶等)，这些按钮的类就是UITableViewRowAction。 这个类只能定义按钮的显示文字、背景色、和按钮事件。并且返回数组的第一个元素在UITableViewCell的最右侧显示，最后一个元素在最左侧显示。从iOS 11开始有了一些改变，首先是可以给这些按钮添加图片了，然后是如果实现了以下两个iOS 11新增的代理方法，将会取代(tableView: editActionsForRowAtIndexPath:)代理方法： 注意：看的有的文章如果在iOS11上面调用老的删除，会崩溃， - (nullable UISwipeActionsConfiguration *)tableView:(UITableView *)tableView leadingSwipeActionsConfigurationForRowAtIndexPath:(NSIndexPath *)indexPath func tableView(_ tableView: UITableView, trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -&gt; UISwipeActionsConfiguration? func tableView(_ tableView: UITableView, trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -&gt; UISwipeActionsConfiguration? { let action = UIContextualAction(style: .destructive, title: &quot;Delete&quot;) { (action, view, handler) in handler(true) } let configuration = UISwipeActionsConfiguration(actions: [action]) return configuration } func tableView(_ tableView: UITableView, leadingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -&gt; UISwipeActionsConfiguration? { let action = UIContextualAction(style: .normal, title: &quot;Mark&quot;) { (action, view, handler) in handler(true) } action.backgroundColor = UIColor.init(red: 254/255.0, green: 175/255.0, blue: 254/255.0, alpha: 1); let configuration = UISwipeActionsConfiguration(actions: [action]) return configuration } 十一：到底用viewSafeAreaInsetsDidChange还是viewWillLayoutSubviews先来看看下面一段代码，相信做过iPhone X适配的同学应该都不陌生， var safeArea: CGFloat = 0 if #available(iOS 11.0, *) { safeArea += self.view.safeAreaInsets.bottom || UIApplication.shared.keyWindow.rootViewController.view.safeAreaInsets.bottom } coding ... constant || originY || frame || height 有时候，我们会发现这样的一段适配的代码，如果根据苹果的特性，和我们所了解情况，我们一般都会把他放到viewSafeAreaInsetsDidChange，但是，并没有什么卵用，但是根据UI刷新的特性，我试着把他放在viewWillLayoutSubviews，却又正常了，很多人对此很是不解。 首先我们要知道： viewSafeAreaInsetsDidChange调用时机很早，在viewWillAppear后 viewSafeAreaInsetsDidChange后面会调用两次viewDidLayoutSubviews，所以我们应该把改变高度或布局的代码都写在viewDidLayoutSubviews里，这样就不会有多余的动画效果了 注意: viewDidLayoutSubviews可能会由别的操作频繁触发，所以如果调整safeArea布局的代码比较耗时，可以考虑加上一个状态标记，只在didChange后执行一次布局调整 - (void)viewDidLayoutSubviews { [super viewDidLayoutSubviews]; UIEdgeInsets safeAreaInsets = sgm_safeAreaInset(self.view); CGFloat height = 44.0; // 导航栏原本的高度，通常是44.0 height += safeAreaInsets.top &gt; 0 ? safeAreaInsets.top : 20.0; // 20.0是statusbar的高度，这里假设statusbar不消失 if (_navigationbar &amp;&amp; _navigationbar.height != height) { _navigationbar.height = height; } } 十二：纯代码的宽高比适配/// 高度系数 812.0 是iPhoneX的高度尺寸，667.0表示是iPhone 8 的高度，如果你觉的它会变化，那我也很无奈 #define kWJHeightCoefficient (kWJScreenHeight == 812.0 ? 667.0/667.0 : kWJScreenHeight/667.0) | | | 十三：纯代码适配iPhone X脚底首先需要知道一点的是，底部脚底高度是34（tabBar之下所拓张的区域）适配规则： 列表页面不去适配，底部有按钮的界面要适配 viewSafeAreaInsetsDidChange方法里面打印NSLog(@”%@”,NSStringFromUIEdgeInsets(self.view.safeAreaInsets)); 注意： 1.介绍viewSafeAreaInsetsDidChange方法系统调用或者你设置控制器的additionalSafeAreaInsets安全区域边界2.顺序viewSafeAreaInsetsDidChange调用顺序实在viewWillAppear之后，在viewWillLayoutSubvies之前调用 /// 底部宏，吃一见长一智吧，别写数字了 #define SafeAreaBottomHeight (kWJScreenHeight == 812.0 ? 34 : 0) 十四：xib和SB适配安全区域：整个屏幕–导航栏–状态栏–tabbar（自己设定的安全区域除外 xib的适配齐刘海和圆角，如果你们项目要求适配iOS 9一下的，就该一个一个好好拖，如果你们不要求适配iOS 9一下的，只需要给view打开安全区域。 十五：App Store评论跳转问题在iOS11 之后，会跳的Today里面说无法连接到App Store 先来看看我们之前的写法 NSString *appstoreUrlString = [NSString stringWithFormat: @&quot;itms-apps://itunes.apple.com/WebObjects/MZStore.woa/wa/viewContentsUserReviews?type=Purple+Software&amp;id=%@&quot;,AppStoreAppId ]; NSURL * url = [NSURL URLWithString:appstoreUrlString]; if ([[UIApplication sharedApplication] canOpenURL:url]){ [[UIApplication sharedApplication]openURL:url]; }else{ WKLog(@&quot;can not open&quot;); } 到iOS 11后，那样已经没有效果了，要改成: NSString *appstoreUrlString = [NSString stringWithFormat:@&quot;itms-apps://itunes.apple.com/cn/app/idXXXXXX?mt=8&amp;action=write-review&quot;, AppStoreAppId ]; NSURL * url = [NSURL URLWithString:appstoreUrlString]; if ([[UIApplication sharedApplication] canOpenURL:url]){ [[UIApplication sharedApplication]openURL:url]; }else{ WKLog(@&quot;can not open&quot;); } 十六：导航栏设置透明问题本来导航栏设置为不透明，如今却变成了透明(磨砂)模式，要知道导航栏透明与不透明的区别除了视觉差异外还有对屏幕左上角坐标点（0,0）的基准是不一样的。 当导航栏设置为透明模式时—&gt;基准点为手机屏幕最左上角，也就是说如果你在（0,0）点放一个有色label时，你就会发现导航栏是挡住了你的方块的，因为是半透明，你能隐约间看到有色块如果你需要设置导航栏透明度，切记把 self.navigationController.navigationBar.translucent = NO; 写到ViewWillAppear里！ 十七：twitter今天刚发现的一个坑，那就是iOS11设置里并没有集成twitter等第三方应用了 一些系统的关于这些APP的API也申明被废弃了，并推荐使用官网SDK iOS 11 no longer supports using Twitter through the built-in social framework. ]Instead,you can use Twitter Kit 3 to Tweet, log in users, and use the Twitter API. 所以APP里集成twitter分享同学要注意了，一定要检查下twitter分享功能。其它APP分享如Facebook，微博分享功能等应该是完好的。 十八：AppIcon在iOS11上发现了一个奇怪的现象，APP在启动时图标会出现黑边， 原因是iOS11修改了App启动动画，如果你的App图标有圆角那么就会变成这个鸟样了…所有图标都换成直角就好了 十九：相册访问权限iOS11上系统默认打开了用户相册的访问权限，但是当你保存图片时APP就会crash， 原因是需要在info.plist再申明一个NSPhotoLibraryAddUsageDescription的key，同时为了兼容iOS11以前的机型，保留以前NSPhotoLibraryUsageDescription的key 总结：1. 属性总结： self.additionalSafeAreaInsets self.view.safeAreaInsets self.additionalSafeAreaInsets 改变safeAreaInsets的值 self.viewSafeAreaInsetsDidChange() self.view.safeAreaInsetsDidChange()- (void)viewSafeAreaInsetsDidChange在UIViewController中第一次调用的时间是在- (void)viewWillAppear:(BOOL)animated调用之后, 在- (void)viewWillLayoutSubviews调用之前. 当你的viewController改变了它的safeAreaInsets值时，有两种方式获取到回调 self.viewSafeAreaInsetsDidChange()self.view.safeAreaInsetsDidChange() self.view.safeAreaLayoutGuide self.view.safeAreaLayoutGuide UIView的一个只读属性，作为参照物，让view可以相对某个view的safeAreaLayoutGuide做布局，从而保证view能正常、安全地显示（相对的那个view不一定要是父view） 把safeAreaLayoutGuide看成是一个“view”，这个“view”系统自动帮我们调整它的bounds，让它不会被各种奇奇怪怪的东西挡住，包括iPhone X的刘海区域和底部的一道杠区域，可以认为在这个“view”上一定能完整显示所有内容,safeAreaInsets来调整自己的bounds的 self.view.insetsLayoutMarginsFromSafeArea 如果你不想让safeAreaInsets影响你的视图布局，则可以将insetsLayoutMarginsFromSafeArea设置为NO，所有的视图布局将会忽略safeAreaInsets这个属性了。 要注意的是，insetsLayoutMarginsFromSafeArea仅用于AutoLayout，即使该属性为NO，视图的safeAreaInsets还是一样有值，而且安全区域变更方法safeAreaInsetsDidChange一样被调用。 contentInsetAdjustmentBehavior 在iOS11 中, UIViewController的automaticallyAdjustsScrollViewInsets属性已经不再使用,我们需要使用UIScrollView的 contentInsetAdjustmentBehavior 属性来替代它. UIScrollViewContentInsetAdjustmentBehavior 是一个枚举类型,值有以下几种: automatic 和scrollableAxes一样,scrollView会自动计算和适应顶部和底部的内边距并且在scrollView 不可滚动时,也会设置内边距.scrollableAxes 自动计算内边距.never不计算内边距always 根据safeAreaInsets 计算内边距 2. Safe Area 与 Layout Margins一般在做 UI 设计，背景色或较不重要的內容可完整地延伸至屏幕边缘；主要的内容呈现区域 (例如 Table View) 会往内缩 (indent) 一层，称为「Safe Area」；而通常文字或是按钮等更加关键的物件，考虑到美观及操作性，會再内缩一层，称之为「Layout Margins 竖屏时的 Safe Area 可延伸至屏幕左右两侧，上部留 44pt 給 Status Bar；Layout Margins 通常左右再内缩 16pt。 横屏时的 Safe Area 左右两侧皆内缩 44pt；Layout Margins 通常左右再内缩 16pt。 Home IndicatorHome Indicator 为 iPhone X 屏幕下方的一个操控區域，外观是一条粗线 (手把)，由屏幕底部往上滑动可返回主界面 (Home Screen)，或进入多任务管理界面 (App Switcher)。 注意：该“粗线”不可自定义外观，系统会自动判断背景颜色，深色背景时显示浅色 Bar，浅色背景时则显示深色 Bar。 3. Edge Protection如果你的 UI 带有由屏幕底部往上滑动 (Swipe) 的手势，可能会与系统的手势冲突，这时可告诉开发者该 UI界面需要启用「Edge Protection」。启用时，Home Indicator 将会变得较为透明，并下降位置 (但还在)，让全屏体验更为完整。当使用者第一次由下往上滑动时，此手势将保留给你的 App 使用，而不会触发 Home Indicator；当使用者在这时进行第二次滑动，才会触发。 注意：此选项将造成使用者不便，因此当真的有需要时再考虑启用 4. Auto-HideUI 中若是有影片播放等需要降低干扰的情况，需要完全隐藏 Home Indicator，可启用「Auto-Hide」选项，启用时，若是使用者数秒内沒有操纵行为，Home Indicator 将自动隐藏，直到使用者触碰界面才会再度出现。 注意：此选项将造成使用者困惑，因此當真的有需要时再考虑启用。 推荐： 你可能需要为你的 APP 适配 iOS 11 iOS 11 适配集锦 iOS 11新特性与适配 iOS 11更新的内容(开发) APP适配iOS11 WWDC:Updating Your App for iOS 11 PDF版：Updating Your App For iOS 11 iPhoneX人机交互指南(开发&amp;设计师) 官方iPhoneX人机交互指南 中文版iPhoneX人际交互指南 强烈推荐UI 設計師需要知道的 iPhone X 細節]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>iPhone X适配实战总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——App跳转到系统设置]]></title>
    <url>%2F2017%2F11%2F16%2FiOS%E2%80%94%E2%80%94App%E8%B7%B3%E8%BD%AC%E5%88%B0%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[这里就不扯太多没用的理论，也不做什么总结与分析，只是整理备用，方便查询：关于App跳转到系统设置…… 前言： 先上一段代码，懂的自然会懂….. #define iOS10 ([[UIDevice currentDevice].systemVersion doubleValue] &gt;= 10.0) NSString * urlString = @&quot;App-Prefs:root=FACETIME&quot;; if ([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:urlString]]) { if (iOS10) { [[UIApplication sharedApplication] openURL:[NSURL URLWithString:urlString] options:@{} completionHandler:nil]; } else { [[UIApplication sharedApplication] openURL:[NSURL URLWithString:urlString]]; } } 说明： APP的跳转通过： [[UIApplication sharedApplication] openURL:url]这种方法来实现的。 而APP之间传递数据 的 接收是在AppDelegate里： (BOOL)application:(UIApplication )application openURL:(NSURL )url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation { }方法里。 印象中iOS 10之前所有prefs中的P都是小写，而iOS 10之后Prefs中的P变成了大写 系统内置跳转 跳转 写法 运营商 App-Prefs:root=Carrier 通用-还原 App-Prefs:root=Reset Siri App-Prefs:root=SIRI 隐私 App-Prefs:root=Privacy 音乐 App-Prefs:root=MUSIC 音乐-均衡器 App-Prefs:root=MUSIC&amp;path=com.apple.Music:EQ 蜂窝网络：Prefs:root=MOBILE_DATA_SETTINGS_ID — Prefs:root=General&amp;path=Network/ Wi-Fi：Prefs:root=WIFI 定位服务：Prefs:root=LOCATION_SERVICES 个人热点：Prefs:root=INTERNET_TETHERING 关于本机：Prefs:root=General&amp;path=About 辅助功能：Prefs:root=General&amp;path=ACCESSIBILITY 飞行模式：Prefs:root=AIRPLANE_MODE 锁定：Prefs:root=General&amp;path=AUTOLOCK 亮度：Prefs:root=Brightness 蓝牙：Prefs:root=Bluetooth 时间设置：Prefs:root=General&amp;path=DATE_AND_TIME FaceTime：Prefs:root=FACETIME 设置：Prefs:root=General 设置 Prefs:root=SETTING 定位服务 Prefs:root=LOCATION_SERVICES 键盘设置：Prefs:root=General&amp;path=Keyboard iCloud：Prefs:root=CASTLE iCloud备份：Prefs:root=CASTLE&amp;path=STORAGE_AND_BACKUP 语言：Prefs:root=General&amp;path=INTERNATIONAL 定位：Prefs:root=LOCATION_SERVICES 音乐：Prefs:root=MUSIC Music Equalizer — Prefs:root=MUSIC&amp;path=EQ Music Volume Limit — Prefs:root=MUSIC&amp;path=VolumeLimit Network — Prefs:root=General&amp;path=Network Nike + iPod — Prefs:root=NIKE_PLUS_IPOD Notes — Prefs:root=NOTES Notification — Prefs:root=NOTIFICATIONS_ID Phone — Prefs:root=Phone Photos — Prefs:root=Photos Profile — Prefs:root=General&amp;path=ManagedConfigurationList Reset — Prefs:root=General&amp;path=Reset Safari — Prefs:root=Safari Siri — Prefs:root=General&amp;path=Assistant Sounds — Prefs:root=Sounds Software Update — Prefs:root=General&amp;path=SOFTWARE_UPDATE_LINK Store — Prefs:root=STORE Twitter — Prefs:root=TWITTER Usage — Prefs:root=General&amp;path=USAGE Wallpaper — Prefs:root=Wallpaper 其他服务与APP跳转 电话 mobilephone:// 备忘录 mobilenotes:// 墨客 com.moke.moke-1:// 名片全能王 camcard:// 扫描全能王 camscanner:// TuneIn Radio tunein:// 或 tuneinpro:// OfficeSuite mobisystemsofficesuite:// WPS Office KingsoftOfficeApp:// Line line:// 1Password onepassword:// Clear(著名的Todo应用) clearapp:// Chrome谷歌浏览器 googlechrome:// Calendars 5 calendars:// GoodReader 4 com.goodreader.sendtogr:// PDF Expert 5 pdfexpert5presence:// Documents 5 rdocs:// nPlayer nplayer-http:// GPlayer gplayer:// AVPlayer HD AVPlayerHD:// AVPlayer AVPlayer:// Ace Player aceplayer:// 12306订票助手 trainassist:// 金山词霸 com.kingsoft.powerword.6:// 节奏大师 tencentrm:// 赶集生活 **:// 凤凰新闻 comIfeng3GifengNews:// 高铁管家 gtgj:// 飞信 fetion:// 豆瓣FM doubanradio:// 大智慧 dzhiphone:// 布卡漫画 buka:// 爱奇艺PPS ppstream:// 哔哩哔哩动画 bilibili:// 56视频 com.56Video:// 365日历 rili365:// 58同城 wbmain:// 遇见 iaround:// 陌陌 momochat:// 有道词典 yddict:// 优酷 youku:// 掌阅iReader iReader:// 艺龙旅行 elongIPhone:// 迅雷+迅雷云播 thunder:// 熊猫公交 wb1405365637:// 携程无线 CtripWireless:// 无线苏州 SuZhouTV:// 唯品会 vipshop:// 微视 weishiiosscheme:// 微拍 wpweipai:// 旺信 wangxin:// 网易公开课 ntesopen:// 网易将军令 netease-mkey:// 万年历 youloft.419805549:// 土豆视频 tudou:// 同花顺 amihexin:// 天涯社区 tianya:// 天气通Pro sinaweatherpro:// 天气通 sinaweather:// 墨迹天气 rm434209233MojiWeather:// 淘宝旅行 taobaotravel:// 人人 renrenios:// 蜻蜓FM qtfmp:// 浦发银行 wx1cb534bb13ba3dbd:// 招商银行 cmbmobilebank:// 建设银行 wx2654d9155d70a468:// 工商银行 com.icbc.iphoneclient:// 酷我音乐 com.kuwo.kwmusic.kwmusicForKwsing:// 酷狗音乐 kugouURL:// 今日头条 snssdk141:// 京东 openApp.jdMobile:// QQ mqq:// 微信 wechat:// 或 weixin:// QQ音乐 qqmusic:// QQ斗地主 tencent382:// QQ浏览器 mttbrowser:// QQ安全中心 qmtoken:// QQ国际版 mqqiapi:// 腾讯新闻 qqnews:// 腾讯微云 weiyun:// 腾讯地图 sosomap:// 腾讯企业邮箱 qqbizmailDistribute2:// 腾讯手机管家 mqqsecure:// 腾讯视频 tenvideo:// 或 tenvideo2:// 或 tenvideo3:// 腾讯微博 TencentWeibo:// 天天星连萌 tencent100689806:// 天天爱消除 tencent100689805:// 天天酷跑 tencent100692648:// 天天飞车 tencent100695850:// PPTV pptv:// 爱奇艺视频 qiyi-iphone:// 暴风影音 com.baofeng.play:// 保卫萝卜2 wb2217954495:// 保卫萝卜 wb1308702128:// 百度音乐 baidumusic:// 百度视频 baiduvideoiphone:// 或 bdviphapp:// 百度糯米 bainuo:// 百度魔图 photowonder:// 百度魔拍 wondercamera:// 百度地图 baidumap:// 百度导航 bdNavi:// 百度 baiduboxapp:// 或 BaiduSSO:// 搜狗输入法 com.sogou.sogouinput:// 搜狐视频 sohuvideo-iphone:// 或 sohuvideo:// 搜狐新闻 sohunews:// 随手记 FDMoney:// 天天动听 ttpod:// 挖财记账 wacai:// 威锋网 com.weiphone.forum:// 新浪微博 weibo:// 或 sinaweibo:// 网易邮箱 neteasemail:// 高德导航 Autonavi:// 百度输入法 BaiduIMShop:// 百度贴吧 com.baidu.tieba:// 淘宝 taobao:// 天猫 tmall:// 支付宝 alipay:// 旺旺卖家版 wangwangseller:// 百度云 baiduyun:// 网易新闻 newsapp:// UC浏览器 ucbrowser:// E-Mail MESSAGE://]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>App跳转到系统设置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode Server完整教程]]></title>
    <url>%2F2017%2F11%2F11%2FXcode-Server%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[由于公司项目的需要，以及同事和测试人员的反馈，我们的打包服务器挂了，貌似之前经常挂（因为我桌旁的就是装有打包服务器的垃圾桶，在领用Mac之前，我都是用那个开发的）。其实之前我也一直想找个机会搞一下Xcode Server，记得还专门写过一篇总结，但是由于工作的原因，也由于帐号的原因就没去搞了，这一次刚好有这个机会，于是我专门放下手上所有的活，打算把这个东西弄好来……… 如果你对CI和CD已经足够了解，仅仅想知道怎么搞好Xcode Server，那么你可以直接从准备开始… 背景：之前项目使用的是Jenkins，但是由于Jenkins的各种问题，配置，后面被换到了Xcode Server（当然除了他们我还可以选择Fantlane）。自从老大走了以后Xcode Server经常挂，导致测试人员不发打包测试，从而影响整体进度。而且这一次好像是彻底挂了，根本都进不去了….. 常识：这里简单介绍一下Xcode Server和常用的持续交付与继承工具（CI&amp;CD）。 xcodebuild - 由Apple开发，主要用于Xcode的构建和测试，有时可能难以想起，但可配置程度很高。 fastlane - 实际上并不是一个工具，而是一组可用于构建、测试、上传至iTunes Connect、供应配置文件管理、屏幕截图创建、dsym上传/下载至主要崩溃报告平台的一系列工具。 xctool和其他 - “其他”是指诸如nomad tools等工具，这些工具或者被弃用，或者逐渐缺少支持，或者即将被废弃。尽管Facebook在使用某种工具，但并不意味着这个工具依然可以得到妥善的维护。 服务器方面主要的选择包括： TravisCI/CircleCI - 托管式服务器，可免费用于开源项目，可随处访问，极为强大。相比Jenkins可配置的选项较少，仅支持与Github集成。用于私有代码库的价格高昂。 Xcode Server - 能与Xcode高度集成，实际上也是唯一可用于Xcode的服务器，由Apple开发，最有可能只需要少量配置即可投入使用。 Jenkins - CI服务器领域曾经的王者，有大量插件可用，可与各种其他产品集成，需要一定的配置和维护，但是非常强大。 需求一般项目到了一定程度，或者公司和成员到了一定规模都会考虑自动化，当然也包括那些喜欢导致或者懒惰想一键打包发布的程序员。因此结合公司，项目或者个人的情况我们可以将整个过程进行拆分。 构建并签署我们的所有不同特性的应用； 将我们的应用商店首选项上传至iTunes Connect； 将IPA、dSYM，以及变更日志上传至HockeyApp； 针对发布和开发分支持续不断地运行单元测试和UI测试； 构建每次合并请求（MR）并汇报测试结果； 进行持续不断地构建和签署，以确保没有引入新的问题。 由于时间的原因，也由于目前需求的原因，我们目前只需要进行打包发布相关操作，至于，分析，测试… 看完上面之后，相信你知道我接下来要说的是什么， 准备OS X工具下载 下载 OS X Server（付费开发者免费使用） 下载 Xcode 这里就不多废话了，直接到苹果商店搜索就可以 帐号与代码仓库地址 开发者帐号（相关证书与描述文件） git源代码仓库地址 装备完了上面所需要的东西之后我们就可以开始配置和使用OS X Server了 配置Xcode打开OS X Server，根据提示点击一步一步操作即可 1 选择服务器主机：一般选自身，也可以指定IP 2 选择Xcode服务，开启服务（右上角） 老版配置页面 这里需要注意，之前的配置方案是直接有 权限和版本号：自己考虑，我这里默认设置不改了； 开发团队：使用自己的apple ID添加； 开发设备：需要用设备连接服务器后才能搜索到，初次连接，可能还需要在Status选项里面点击【Add to Teams】（比如设备不是你上面apple ID 的就需要） 查看Bot：会打开网页（Bot管理页面，默认127.0.01）,可以直接静态分析测试打包等，当然需要后面配置成功才能使用。 新版配置页面 最新版本不知道为什么没有了对应的信息，根据提示信息应该的Xcode兼容性问题（因为：点击选择Xcode，选择指定Xcode之后提示是说版本不兼容） 此时界面只有一个选择Xcode的按钮，点击进去就会直接进入到Server &amp; Bots 你会看到下面的界面 这里也可以直接在Xcode Preferences中打开， 解锁后点击OFF&amp;ON进行开启服务，然后会提示Select Integration User（选择集成用户） 这里我们一般都会新建一个用户，而不是直接使用服务器账户，然后填写对应的信息（帐号密码），这里要记住后面会有用 点击创建之后就会执行一系列操作，对Xcode进行配置 具体执行操作有 Saveing version information Enableing developer model Configuring SSL certificates Starting Redis initializing database Starting API Server Starting Apache Starting control daemon Starting Builder Upgrading Xcode Server Data Saveing version information 完成后你会看到，一个提示新用户登录的提示，为了更好的进行测试和验证，我们都会先登录用户 直接登录就可以，并且一步一步确认进入到子账户，子账户会提示： 这里先不用管，切回到服务器账户就可以，这个时候，你就可以看到刚刚创建的账户已经出现了，并且处于登录状态，我们可以点击直接切换到对应账户，或者选择和重新创建多个账户，控制超时时间。 登录账户在Xcode Preferences中选择Account，点击右下角添加账户，分别登录Apple ID，GitHub，Xcode Server Apple ID：对应开发者帐号，要和本地证书与描述文件对应 GitHub 注意:Source Control 需要打开才能使用！具体下面的各种自动自己考虑勾选； Xcode Server（如果使用Xcode 9.1最新版本，这一步已经不需要了，也就是说Xcode 9.1已经自带了Bots功能） 注意：Accounts 添加 Servers，一般默认自己主机，也可以选择指定IP地址，按服务器配置时对应选择；需要填写用户名，密码，自己搞定； 完成帐号登录以后，可以适当下载更新一下证书文件 配置Xcode Server（如果使用Xcode 9.1最新版本，这一步已经不需要了，也就是说Xcode 9.1已经自带了Bots功能）再次打开Xcode Server，进入Xcode服务页面，点击打开Xcode，会直接打开Xcode Preferences中的Server &amp; Bots并开启对应账户，这里和前面操作一样，如果没有就根据提示直接确定或者输入对应的账号信息就可以（如果没有登录帐号的话） 创建Bots 注意：自己的项目必须是个git文件夹，比如github上clone下来的项目，或者是本地服务器git来的，总之需要git文件夹；（官方文档使用Xcode的Source Control 方式搞定，具体可以看官方指南。我直接用了第三方软件SourceTree管理的） 这里由于我们是直接使用GitLab的，所以我直接从GitLab克隆了一分项目源码到本地文件夹。 打开Xcode，保证项目编译正常的情况下创建Bots（这里可以直接点击Products-&gt;Create Bots） 1 Bot命名与服务器选择，基本默认不改；2 选择项目内容，后面的master，可选其他分支，比如develop；3 Bot 操作配置Scheme：默认项目本身Actions：1分析；2单元测试（测试项目没开单元测试所有没的选）；3打包；Cleaning：可以选择，因为是自己的电脑做服务器的，所以选择了一周清理一次；Configuation：项目配置；4 环境变量？没用过，sorry；5 添加脚本，比如完成后发送个邮件通知；6 create！注意 需要一次验证 git 的用户名和密码！不是之前设置的用户名与密码。7 成功；各种信息以及完成的打包等；通过IP地址也可以实时整合并下载； 当你看到一个类型这样的界面，说明已经配置并且创建Bots完成，具体是否正确，需要进行打包验证或者根据日志进行查找具体问题 注意： 如果在使用Xcode Server对应的分析，测试功能，还需要额外进行一些配置，由于时间的问题，这里我们暂时只使用打包功能。 打包配置需要选择InHouse 打包验证输入网址或者点击Xcode Perferences中的Account，点击Xcode Server对应的地址链接，进入网址（这里是icocos.local对应ip是10.0.6.7），这里可以在当前服务器进行操作，也可以在配置Xcode的时候创建的那个帐号进行操作，同意可以在内网的其他端系统或者浏览器进行操作 然后就会有一打包的进度…… 错误总结错误问题一： 问题原因： 因为没有登录对应的Git帐号或者没有打包对应项目的workspace 错误问题二： 问题原因： 同样是因为没有登录对应的Git帐号 错误问题三： 问题原因： 同样是因为没有登录对应的Git帐号 错误问题四： 问题原因： 这里是由于创建Bots进行配置的时候，只需要打包功能就行了，那些什么分析,测试不需要,还有打包配置要选InHouse，不然打不了的 错误问题五： 问题原因： 由于升级了Xcode 9.1，和对应的Xcode Server不兼容，这里需要输入xcsd密码（也不知道是sm鬼），根据2017@swift大会的朋友经验： 备份/Library/Developer/XcodeServer，然后删除XcodeServer文件夹内容，重新前面的步骤就正常了。 错误问题六： 问题原因： 这其实不是sm错误 ，只是一个安全警告，解决方案：点击显示详细信息-&gt;继续访问网址，就可以了 错误问题七： 问题原因： 此问题困扰了很久，由于加入了GZIP库，但是…. 错误问题八： 问题原因： 此问题困扰了很久，由于加入了GZIP库，但是…. 其他问题 这些问题目前没有找到好的解决方案，根据提示查找发现，证书，前面都没有问题…… 总结一最后根据最新经验总结，最新版本Xcode 9.1配置其实非常简单了 配置Xcode Perferences中Server &amp; Bots 创建并登录帐号 Xcode Perferences登录git，app，server帐号 Clone远程Git源代码，并打开保证正常编译 Create Bots并配置 重启相关服务，Server，Bots，Xcode，开始打包 注意： 关于代码提交，不管使用Xcode还是其他方式，是没有关系的，Xcode服务指向的是master或者其他分支的服务器资源；关于打包，项目配置里就做好证书等配置文件的选择；内测的ipa包，可以结合蒲公英等平台作分发也是很方便的；考虑是不是可以搞个脚本上传。 打包过程中 通过 Xcode 中的 Integrate 查看进度我们不难发现，其实整个过程和我们手动打包的过程是一样的 打包完成 但是这样可能享受不到OS X Server那样多而且好用的服务，不过如果只是需要简单的进行打包，配合测试进行验证，简单的发布引用还是可以满足的…….. 推荐想了解更过关于Xcode Server配置与使用的，可以参考与学习下面的文章，笔者也是从下面的文章中一点一点学习的，并结合了朋友指点进行实战。 3个官方文档： 官方配置教程 苹果开发指南 OS X Server 帮助 简书教程： OS X Server 之 Xcode服务 手动打包流程 iOS App打包上架超详细流程]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Xcode Server完整教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——__attribute__使用与总结]]></title>
    <url>%2F2017%2F11%2F08%2FiOS%E2%80%94%E2%80%94-attribute-%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[关于attribute，其实iOS开发中无处不在，只是我们平时都只是开发，因为苹果已经帮我们处理好了这一切，或许你在曾在哪里看到过并且了解过，或者你曾在写过组件和框架相关，否则你应该只会知道大概的意思，而且只是小部分，今天我们就来分析一下一些常用attribute的含义，具体文章参考网络资料…… __attribute__使用与总结attribute是GNU C特色之一,在iOS用的比较广泛.系统中有许多地方使用到. attribute可以设置函数属性（Function Attribute ）、变量属性（Variable Attribute ）和类型属性（Type Attribute)等. 函数属性(Function Attribute) noreturn noinline always_inline pure const nothrow sentinel format format_arg no_instrument_function section constructor destructor used unused deprecated weak malloc alias warn_unused_result nonnull 类型属性(Type Attributes) aligned packed transparent_union, unused, deprecated may_alias 变量属性(Variable Attribute) aligned packed Clang特有的 availability overloadable 书写格式书写格式：attribute后面会紧跟一对原括弧，括弧里面是相应的attribute参数 attribute(xxx) 常见的系统用法format官方例子:NSLog #define NS_FORMAT_FUNCTION(F,A) __attribute__((format(__NSString__, F, A))) format属性可以给被声明的函数加上类似printf或者scanf的特征，它可以使编译器检查函数声明和函数实际调用参数之间的格式化字符串是否匹配。该功能十分有用，尤其是处理一些很难发现的bug。对于format参数的使用如下 format (archetype, string-index, first-to-check) 第一参数需要传递“archetype”指定是哪种风格,这里是 NSString；“string-index”指定传入函数的第几个参数是格式化字符串；“first-to-check”指定第一个可变参数所在的索引. noreturn官方例子: abort() 和 exit() 该属性通知编译器函数从不返回值。当遇到类似函数还未运行到return语句就需要退出来的情况，该属性可以避免出现错误信息。 availability官方例子: - (CGSize)sizeWithFont:(UIFont *)font NS_DEPRECATED_IOS(2_0, 7_0, &quot;Use -sizeWithAttributes:&quot;) __TVOS_PROHIBITED; 来看一下 后边的宏 #define NS_DEPRECATED_IOS(_iosIntro, _iosDep, ...) CF_DEPRECATED_IOS(_iosIntro, _iosDep, __VA_ARGS__) define CF_DEPRECATED_IOS(_iosIntro, _iosDep, ...) __attribute__((availability(ios,introduced=_iosIntro,deprecated=_iosDep,message=&quot;&quot; __VA_ARGS__))) //宏展开以后如下 __attribute__((availability(ios,introduced=2_0,deprecated=7_0,message=&quot;&quot;__VA_ARGS__))); //ios即是iOS平台 //introduced 从哪个版本开始使用 //deprecated 从哪个版本开始弃用 //message 警告的消息 availability属性是一个以逗号为分隔的参数列表，以平台的名称开始，包含一些放在附加信息里的一些里程碑式的声明。 introduced：第一次出现的版本。 deprecated：声明要废弃的版本，意味着用户要迁移为其他API obsoleted： 声明移除的版本，意味着完全移除，再也不能使用它 unavailable：在这些平台不可用 message：一些关于废弃和移除的额外信息，clang发出警告的时候会提供这些信息，对用户使用替代的API非常有用。 这个属性支持的平台：ios，macosx。 简单例子: //如果经常用,建议定义成类似系统的宏 - (void)oldMethod:(NSString *)string __attribute__((availability(ios,introduced=2_0,deprecated=7_0,message=&quot;用 -newMethod: 这个方法替代 &quot;))){ NSLog(@&quot;我是旧方法,不要调我&quot;); } - (void)newMethod:(NSString *)string{ NSLog(@&quot;我是新方法&quot;); } 如果调用了,会有警告 unavailable告诉编译器该方法不可用，如果强行调用编译器会提示错误。比如某个类在构造的时候不想直接通过init来初始化，只能通过特定的初始化方法()比如单例，就可以将init方法标记为unavailable; //系统的宏,可以直接拿来用 #define UNAVAILABLE_ATTRIBUTE __attribute__((unavailable)) #define NS_UNAVAILABLE UNAVAILABLE_ATTRIBUTE @interface Person : NSObject @property(nonatomic,copy) NSString *name; @property(nonatomic,assign) NSUInteger age; - (instancetype)init NS_UNAVAILABLE; - (instancetype)initWithName:(NSString *)name age:(NSUInteger)age; @end 实际上unavailable后面可以跟参数,显示一些信息 //系统的 #define NS_AUTOMATED_REFCOUNT_UNAVAILABLE __attribute__((unavailable(&quot;not available in automatic reference counting mode&quot;))) objc_root_class表示这个类是一个根类(基类),比如NSObject,NSProxy. //摘自系统 //NSProxy NS_ROOT_CLASS @interface NSProxy &lt;NSObject&gt; { Class isa; } //NSObject __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0) OBJC_ROOT_CLASS OBJC_EXPORT @interface NSObject &lt;NSObject&gt; { Class isa OBJC_ISA_AVAILABILITY; } NSObject@property (nonatomic,strong) __attribute__((NSObject)) CFDictionaryRef myDictionary; CFDictionaryRef属于CoreFoundation框架的,也就是非OC对象,加上attribute((NSObject))后,myDictionary的内存管理会被当做OC对象来对待. objc_designated_initializer用来修饰类的designated initializer初始化方法，如果修饰的方法里没有调用super类的 designated initializer，编译器会发出警告。可以简写成NS_DESIGNATED_INITIALIZER visibility语法: attribute((visibility(“visibility_type”)))其中，visibility_type 是下列值之一： default 假定的符号可见性可通过其他选项进行更改。缺省可见性将覆盖此类更改。缺省可见性与外部链接对应。 hidden 该符号不存放在动态符号表中，因此，其他可执行文件或共享库都无法直接引用它。使用函数指针可进行间接引用。 internal 除非由 特定于处理器的应用二进制接口 (psABI) 指定，否则，内部可见性意味着不允许从另一模块调用该函数。 protected 该符号存放在动态符号表中，但定义模块内的引用将与局部符号绑定。也就是说，另一模块无法覆盖该符号。 除指定 default 可见性外，此属性都可与在这些情况下具有外部链接的声明结合使用。您可在 C 和 C++ 中使用此属性。在 C++ 中，还可将它应用于类型、成员函数和命名空间声明。 系统用法: // UIKIT_EXTERN extern #ifdef __cplusplus #define UIKIT_EXTERN extern &quot;C&quot; __attribute__((visibility (&quot;default&quot;))) #else #define UIKIT_EXTERN extern __attribute__((visibility (&quot;default&quot;))) #endif nonnull编译器对函数参数进行NULL的检查,参数类型必须是指针类型(包括对象) //使用 - (int)addNum1:(int *)num1 num2:(int *)num2 __attribute__((nonnull (1,2))){//1,2表示第一个和第二个参数不能为空 return *num1 + *num2; } - (NSString *)getHost:(NSURL *)url __attribute__((nonnull (1))){//第一个参数不能为空 return url.host; } 常见用法aligned__attribute((aligned (n)))，让所作用的结构成员对齐在n字节自然边界上。如果结构中有成员的长度大于n，则按照最大成员的长度来对齐.例如: 不加修饰的情况 typedef struct { char member1; int member2; short member3; }Family; //输出字节: NSLog(@&quot;Family size is %zd&quot;,sizeof(Family)); 输出结果 2016-07-25 10:28:45.380 Study[917:436064] Family size is 12 修改字节对齐为1 typedef struct { char member1; int member2; short member3; }__attribute__ ((aligned (1))) Family; //输出字节: NSLog(@&quot;Family size is %zd&quot;,sizeof(Family)); 输出结果 2016-07-25 10:28:05.315 Study[914:435764] Family size is 12 和上面的结果一致,因为 设定的字节对齐为1.而结构体中成员的最大字节数是int 4个字节,1 &lt; 4,按照4字节对齐,和系统默认一致. 修改字节对齐为8 typedef struct { char member1; int member2; short member3; }__attribute__ ((aligned (8))) Family; //输出字节: NSLog(@&quot;Family size is %zd&quot;,sizeof(Family)); //输出结果为: 2016-07-25 10:28:05.315 Study[914:435764] Family size is 16 这里 8 &gt; 4,按照8字节对齐,结果为16,不知道字节对齐的可以看我的这篇文章http://www.jianshu.com/p/f69652c7df99 可是想了半天,也不知道这玩意有什么用,设定值小于系统默认的,和没设定一样,设定大了,又浪费空间,效率也没提高,感觉学习学习就好. packed让指定的结构结构体按照一字节对齐,测试: //不加packed修饰 typedef struct { char version; int16_t sid; int32_t len; int64_t time; } Header; //计算长度 NSLog(@&quot;size is %zd&quot;,sizeof(Header)); 输出结果 2016-07-22 11:53:47.728 Study[14378:5523450] size is 16 可以看出,默认系统是按照4字节对齐 //加packed修饰 typedef struct { char version; int16_t sid; int32_t len; int64_t time; }__attribute__ ((packed)) Header; //计算长度NSLog(@”size is %zd”,sizeof(Header)); 输出结果 2016-07-22 11:57:46.970 Study[14382:5524502] size is 15 用packed修饰后,变为1字节对齐,这个常用于与协议有关的网络传输中. noinline &amp; always_inline内联函数:内联函数从源代码层看，有函数的结构，而在编译后，却不具备函数的性质。内联函数不是在调用时发生控制转移，而是在编译时将函数体嵌入在每一个调用处。编译时，类似宏替换，使用函数体替换调用处的函数名。一般在代码中用inline修饰，但是能否形成内联函数，需要看编译器对该函数定义的具体处理 noinline 不内联 always_inline 总是内联 这两个都是用在函数上 内联的本质是用代码块直接替换掉函数调用处,好处是:快代码的执行，减少系统开销.适用场景: 这个函数更小 这个函数不被经常调用 使用例子: //函数声明 void test(int a) __attribute__((always_inline)); #### warn_unused_result 当函数或者方法的返回值很重要时,要求调用者必须检查或者使用返回值,否则编译器会发出警告提示 - (BOOL)availiable __attribute__((warn_unused_result)) { return 10; } objc_subclassing_restricted因为某些原因,我们不希望这个类被继承,也就是 “最终”的类,用法如下: __attribute__((objc_subclassing_restricted)) @interface ViewController : UIViewController @end 如果继承了这个类,编译器会报错 objc_requires_super这个属性要求子类在重写父类的方法时,必须要重载父类方法,也就是调用super方法,否则警告.示例如下: @interface ViewController : UIViewController - (void)jump __attribute__((objc_requires_super)); @end - (void)jump{ NSLog(@&quot;父类必须先执行&quot;); } @interface SGViewController : ViewController @end @implementation SGViewController - (void)jump{ NSLog(@&quot;子类才能再执行&quot;); } @end objc_boxable实现类似于NSNumber 的快速打包能力@(…),一般对于struct,union我们只能通过NSValue将其打包. objc_boxable 可以帮助我们实现快速打包,示例如下: //自定义结构体 typedef struct __attribute__((objc_boxable)){ CGFloat x,y,width,height; }SGRect; SGRect rect = {0,0,100,200}; //这里直接打包成NSValue NSValue *value = @(rect); //这里我直接用系统的方法打印 NSLog(@&quot;%@&quot;,NSStringFromCGRect(value.CGRectValue)); 输出结果 2016-07-21 21:28:43.538 Study[14118:5408921] {{0, 0}, {100, 200}} 这样SGRect就具备快速打包功能了. constructor / destructor意思是: 构造器和析构器;constructor修饰的函数会在main函数之前执行,destructor修饰的函数会在程序exit前调用. 示例如下: int main(int argc, char * argv[]) { @autoreleasepool { NSLog(@&quot;main&quot;); return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); } } __attribute__((constructor)) void before(){ NSLog(@&quot;before main&quot;); } __attribute__((destructor)) void after(){ NSLog(@&quot;after main&quot;); } //在viewController中调用exit - (void)viewDidLoad { [super viewDidLoad]; exit(0); } 输出结果 2016-07-21 21:49:17.446 Study[14162:5415982] before main 2016-07-21 21:49:17.447 Study[14162:5415982] main 2016-07-21 21:49:17.534 Study[14162:5415982] after main 注意点: 程序退出的时候才会调用after函数,经测试,手动退出程序会执行上面两个函数不管写在哪个类里,哪个文件中效果都一样如果存在多个修饰的函数,那么都会执行,顺序不定实际上如果存在多个修饰过的函数,可以它们的调整优先级 代码如下: int main(int argc, char * argv[]) { @autoreleasepool { NSLog(@&quot;main&quot;); return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); } } __attribute__((constructor(101))) void before1(){ NSLog(@&quot;before main - 1&quot;); } __attribute__((constructor(102))) void before2(){ NSLog(@&quot;before main - 2&quot;); } __attribute__((destructor(201))) void after1(){ NSLog(@&quot;after main - 1&quot;); } __attribute__((destructor(202))) void after2(){ NSLog(@&quot;after main - 2&quot;); } 输出结果 2016-07-21 21:59:35.622 Study[14171:5418393] before main - 1 2016-07-21 21:59:35.624 Study[14171:5418393] before main - 2 2016-07-21 21:59:35.624 Study[14171:5418393] main 2016-07-21 21:59:35.704 Study[14171:5418393] after main - 2 2016-07-21 21:59:35.704 Study[14171:5418393] after main - 1 注意点: 括号内的值表示优先级,[0,100]这个返回时系统保留的,自己千万别调用.根据输出结果可以看出,main函数之前的,数值越小,越先调用;main函数之后的数值越大,越先调用.当函数声明和函数实现分开写时, 格式如下: static void before() __attribute__((constructor)); static void before() { printf(&quot;before\n&quot;); } 讨论:+load,constructor,main的执行顺序,代码如下: + (void)load{ NSLog(@&quot;load&quot;); } __attribute__((constructor)) void before(){ NSLog(@&quot;before main&quot;); } 输出结果 2016-07-21 22:13:58.591 Study[14185:5421811] load 2016-07-21 22:13:58.592 Study[14185:5421811] before main 2016-07-21 22:13:58.592 Study[14185:5421811] main 可以看出执行顺序为: load-&gt;constructor-&gt;main 为什么呢? 因为 dyld（动态链接器，程序的最初起点）在加载 image（可以理解成 Mach-O 文件）时会先通知 objc runtime 去加载其中所有的类，每加载一个类时，它的 +load 随之调用，全部加载完成后，dyld 才会调用这个 image 中所有的 constructor 方法,然后才调用main函数. enable_if用来检查参数是否合法,只能用来修饰函数: void printAge(int age) __attribute__((enable_if(age &gt; 0 &amp;&amp; age &lt; 120, &quot;你丫太监?&quot;))) { NSLog(@&quot;%d&quot;,age); } 表示只能输入的参数只能是 0 ~ 120左右,否则编译报错 cleanup声明到一个变量上，当这个变量作用域结束时，调用指定的一个函数.如果不知道什么是作用域,请先学习一下.例子: //这里传递的参数是变量的地址 void intCleanup(int *num){ NSLog(@&quot;cleanup------%d&quot;,*num); } - (void)test{ int a __attribute__((cleanup(intCleanup))) = 10; } 输出结果 2016-07-22 09:59:09.139 Study[14293:5495713] cleanup------10 注意点: 指定的函数传递的参数是变量的地址作用域的结束包括:大括号结束、return、goto、break、exception等情况当作用域内有多个cleanup的变量时,遵守 先入后出 的栈式结构. 示例代码: void intCleanup(int *num){ NSLog(@&quot;cleanup------%d&quot;,*num); } void stringCleanup(NSString **str){ NSLog(@&quot;cleanup------%@&quot;,*str); } void rectCleanup(CGRect *rect){ CGRect temp = *rect; NSString *str = NSStringFromCGRect(temp); NSLog(@&quot;cleanup------%@&quot;,str); } int a __attribute__((cleanup(intCleanup))) = 10; { NSString *string __attribute__((cleanup(stringCleanup))) = @&quot;string&quot;; CGRect rect __attribute__((cleanup(rectCleanup))) = {0,0,1,1}; } 输出结果 2016-07-22 10:09:36.621 Study[14308:5498861] cleanup------{{0, 0}, {1, 1}} 2016-07-22 10:09:36.622 Study[14308:5498861] cleanup------string 2016-07-22 10:09:36.622 Study[14308:5498861] cleanup------10 讨论:如果修饰了某个对象,那么cleanup和dealloc,谁先执行?测试代码如下: void objectCleanup(NSObject **obj){ NSLog(@&quot;cleanup------%@&quot;,*obj); } - (void)viewDidLoad { [super viewDidLoad]; ViewController *vc __attribute__((cleanup(objectCleanup))) = [[ViewController alloc] init]; } - (void)dealloc{ NSLog(@&quot;dealloc&quot;); } 输出结果 2016-07-22 10:23:08.839 Study[14319:5502769] cleanup------&lt;ViewController: 0x13fe881e0&gt; 2016-07-22 10:23:08.840 Study[14319:5502769] dealloc 可以明显看出,cleanup先于对象的dealloc执行. 在block中的用法:在block中使用,先看例子: //指向block的指针,觉得不好理解可以用typeof void blockCleanUp(void(^*block)()){ (*block)(); } void (^block)(void) __attribute__((cleanup(blockCleanUp))) = ^{ NSLog(@&quot;finish block&quot;); }; 这个好处就是,不用等到block最后才写某些代码,我们可以把它放在block的任意位置,防止忘记. overloadable用于c语言函数,可以定义若干个函数名相同，但参数不同的方法，调用时编译器会自动根据参数选择函数原型： __attribute__((overloadable)) void print(NSString *string){ NSLog(@&quot;%@&quot;,string); } __attribute__((overloadable)) void print(int num){ NSLog(@&quot;%d&quot;,num); } 输出结果 //调用 print(10); print(@&quot;哈哈&quot;); objc_runtime_name看到runtime是不是就感觉高大上,没错这个也跟运行时有关.作用是将将类或协议的名字在编译时指定成另一个.示例如下: __attribute__((objc_runtime_name(&quot;NSObject&quot;))) @interface SGObject :NSObject @end 输出结果 //调用 NSLog(@&quot;%@&quot;,[SGObject class]); //输出 2016-07-22 11:18:00.934 Study[14355:5516261] NSObject]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>attribute__使用与总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——App启动优化分析与总结]]></title>
    <url>%2F2017%2F11%2F03%2FiOS%E2%80%94%E2%80%94App%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[随着人们对App性能与实用要求越来越高，也随着大量iOS开发中的涌入，现如今已经不再是几年前会做简单App，然后开始开发，能写出一个可用功能的产品就可以了，于是，很多公司和开发者也开始关注和实战启动优化，因为App除了桌面Log，启动是也是夺得用户喜好最首要的条件，如果一个App每次启动都要几十秒甚至几分钟，你觉得你还会继续使用吗…… 如果你对iOS开发中App的整个启动过程干兴趣，那么可以先看我之前分享的一个主题iOS——App整个启动过程分析 当然关于启动优化，上面只是简单的提了一下，本文结合那篇文章进行详细分析 启动优化准备APP启动时间： t(App总启动时间) = t1(main()之前的加载时间) + t2(main()之后的加载时间)。 t1 = 系统dylib(动态链接库)和自身App可执行文件的加载； t2 = main方法执行之后到AppDelegate类中的didFinishLaunchingWithOptions方法执行结束前这段时间，主要是构建第一个界面，并完成渲染展示。 前面我们分析了，Main之前和之后的加载过程这里我们先简单介绍一下，之前没有详细说明的一些其中关联的技术： App开始启动后，系统首先加载可执行文件（自身App的所有.o文件的集合），然后加载动态链接库dyld，dyld是一个专门用来加载动态链接库的库。执行从dyld开始，dyld从可执行文件的依赖开始, 递归加载所有的依赖动态链接库。 其实无论对于系统的动态链接库还是对于App本身的可执行文件而言，他们都算是image（镜像），而每个App都是以image(镜像)为单位进行加载的 什么是image 1.executable可执行文件 比如.o文件。 2.dylib 动态链接库 framework就是动态链接库和相应资源包含在一起的一个文件夹结构。 3.bundle 资源文件 只能用dlopen加载，不推荐使用这种方式加载。 注意：除了我们App本身的可行性文件，系统中所有的framework比如UIKit、Foundation等都是以动态链接库的方式集成进App中的。 不同进程之间共用系统dylib的_TEXT区，但是各自维护对应的_DATA区。 所有动态链接库和我们App中的静态库.a和所有类文件编译后的.o文件最终都是由dyld(the dynamic link editor)，Apple的动态链接器来加载到内存中。每个image都是由一个叫做ImageLoader的类来负责加载（一一对应） 是ImageLoader image 表示一个二进制文件(可执行文件或 so 文件)，里面是被编译过的符号、代码等， ImageLoader 作用是将这些文件加载进内存，且每一个文件对应一个ImageLoader实例来负责加载。 ImageLoader加载步骤分两步走： 在程序运行时它先将动态链接的 image 递归加载 (也就是上面测试栈中一串的递归调用的时刻)。 再从可执行文件 image 递归加载所有符号。 真正的启动优化：Main之前：检测方式：Apple提供了一种测量方法，在 Xcode 中 Edit scheme -&gt; Run -&gt; Auguments 将环境变量DYLD_PRINT_STATISTICS 设为1 pre-main阶段 1.1. 加载应用的可执行文件 1.2. 加载动态链接库加载器dyld（dynamic loader） 1.3. dyld递归加载应用所有依赖的dylib（dynamic library 动态链接库） 动态链接库的加载步骤具体分为5步： load dylibs image 读取库镜像文件 Rebase image Bind image Objc setup initializers load dylibs image在每个动态库的加载过程中， dyld需要： 分析所依赖的动态库 找到动态库的mach-o文件 打开文件 验证文件 在系统核心注册文件签名 对动态库的每一个segment调用mmap() 通常的，一个App需要加载100到400个dylibs， 但是其中的系统库被优化，可以很快的加载。 ######&gt; 针对这一步骤的优化有： 减少非系统库的依赖 尽量不使用内嵌（embedded）的dylib，加载内嵌dylib性能开销较大 合并已有的dylib和使用静态库（static archives），减少dylib的使用个数 使用静态资源，比如把代码加入主程序 懒加载dylib，但是要注意dlopen()可能造成一些问题，且实际上懒加载做的工作会更多 rebase/bind由于ASLR(address space layout randomization)的存在，可执行文件和动态链接库在虚拟内存中的加载地址每次启动都不固定，所以需要这2步来修复镜像中的资源指针，来指向正确的地址。 rebase修复的是指向当前镜像内部的资源指针； 而bind指向的是镜像外部的资源指针。rebase步骤先进行，需要把镜像读入内存，并以page为单位进行加密验证，保证不会被篡改，所以这一步的瓶颈在IO。bind在其后进行，由于要查询符号表，来指向跨镜像的资源，加上在rebase阶段，镜像已被读入和加密验证，所以这一步的瓶颈在于CPU计算。 通过命令行可以查看相关的资源指针: xcrun dyldinfo -rebase -bind -lazy_bind myApp.App/myApp 优化该阶段的关键在于减少__DATA segment中的指针数量。 ######&gt; 我们可以优化的点有： 减少ObjC类（class）、方法（selector）、分类（category）的数量 减少C++虚函数数量（创建虚函数表有开销） 转而使用swift stuct（其实本质上就是为了减少符号的数量） Objc setup这一步主要工作是: 注册Objc类 (class registration) 把category的定义插入方法列表 (category registration) 保证每一个selector唯一 (selctor uniquing) 由于之前2步骤的优化，这一步实际上没有什么可做的。 initializers以上三步属于静态调整(fix-up)，都是在修改__DATA segment中的内容，而这里则开始动态调整，开始在堆和堆栈中写入内容。 在这里的工作有： Objc的+load()函数 C++的构造函数属性函数 形如attribute((constructor)) void DoSomeInitializationWork() 非基本类型的C++静态全局变量的创建(通常是类或结构体)(non-trivial initializer) 比如一个全局静态结构体的构建，如果在构造函数中有繁重的工作，那么会拖慢启动速度 Objc的load函数和C++的静态构造函数采用由底向上的方式执行，来保证每个执行的方法，都可以找到所依赖的动态库。 +load方法断点的调用堆栈和顺序： dyld 开始将程序二进制文件初始化 交由 ImageLoader 读取 image，其中包含了我们的类、方法等各种符号 由于 runtime 向 dyld 绑定了回调，当 image 加载到内存后，dyld 会通知 runtime 进行处理 runtime 接手后调用 mapimages 做解析和处理，接下来 loadimages 中调用 callloadmethods 方法，遍历所有加载进来的 Class，按继承层级依次调用 Class 的 +load 方法和其 Category 的 +load 方法 ######&gt; 我们可以做的优化有： 少在类的+load方法里做事情，尽量把这些事情推迟到+initiailize 减少构造器函数个数，在构造器函数里少做些事情 减少C++静态全局变量的个数 至此，可执行文件中和动态库所有的符号(Class，Protocol，Selector，IMP，…)都已经按格式成功加载到内存中，被 runtime 所管理，再这之后，runtime 的那些方法(动态添加 Class、swizzle 等等才能生效)。 到这里整个过程： 整个事件由 dyld 主导，完成运行环境的初始化后，配合 ImageLoader 将二进制文件按格式加载到内存， 动态链接依赖库，并由 runtime 负责加载成 objc 定义的结构，所有初始化工作结束后，dyld 调用真正的 main 函数。 总结优化点： 减少不必要的framework，因为动态链接比较耗时 check framework应当设为optional和required，如果该framework在当前App支持的所有iOS系统版本都存在，那么就设为required，否则就设为optional，因为optional会有些额外的检查 合并或者删减一些OC类，关于清理项目中没用到的类，使用工具AppCode代码检查功能，查到当前项目中没有用到的类如下： 删减一些无用的静态变量 删减没有被调用到或者已经废弃的方法 将不必须在+load方法中做的事情延迟到+initialize中 尽量不要用C++虚函数(创建虚函数表有开销) Main之后：检测方式：测量main()函数开始执行到didFinishLaunchingWithOptions执行结束的耗时，自己插入代码到工程。 main()阶段 2.1. dyld调用main() 2.2. 调用UIApplicationMain() 2.3. 调用applicationWillFinishLaunching 2.4. 调用didFinishLaunchingWithOptions 在main()被调用之后，App的主要工作就是初始化必要的服务，显示首页内容等。而我们的优化也是围绕如何能够快速展现首页来开展。App通常在AppDelegate类中的didFinishLaunchingWithOptions方法中创建首页需要展示的view，然后在当前runloop的末尾，主动调用CA::Transaction::commit完成视图的渲染。 而视图的渲染主要涉及三个阶段： 准备阶段 这里主要是图片的解码 布局阶段 首页所有UIView的- (void)layoutSubViews()运行 绘制阶段 首页所有UIView的- (void)drawRect:(CGRect)rect运行 再加上启动之后必要服务的启动、必要数据的创建和读取，这些就是我们可以尝试优化的地方 因此，对于main()函数调用之前我们可以优化的点有： 不使用xib，直接视用代码加载首页视图 NSUserDefaults实际上是在Library文件夹下会生产一个plist文件，如果文件太大的话一次能读取到内存中可能很耗时，这个影响需要评估，如果耗时很大的话需要拆分(需考虑老版本覆盖安装兼容问题) 每次用NSLog方式打印会隐式的创建一个Calendar，因此需要删减启动时各业务方打的log，或者仅仅针对内测版输出log 梳理应用启动时发送的所有网络请求，是否可以统一在异步线程请求 梳理各个二方/三方库，找到可以延迟加载的库，做延迟加载处理，比如放到首页控制器的viewDidAppear方法里。 梳理业务逻辑，把可以延迟执行的逻辑，做延迟执行处理。比如检查新版本、注册推送通知等逻辑。 避免复杂/多余的计算。 避免在首页控制器的viewDidLoad和viewWillAppear做太多事情，这2个方法执行完，首页控制器才能显示，部分可以延迟创建的视图应做延迟创建/懒加载处理。 采用性能更好的API。 首页控制器用纯代码方式来构建。 总结：具体优化点 纯代码方式而不是storyboard加载首页UI。 对didFinishLaunching里的函数考虑能否挖掘可以延迟加载或者懒加载，需要与各个业务方pm和rd共同check 对于一些已经下线的业务，删减冗余代码。 对于一些与UI展示无关的业务，如微博认证过期检查、图片最大缓存空间设置等做延迟加载 对实现了+load()方法的类进行分析，尽量将load里的代码延后调用。 上面统计数据显示展示feed的导航控制器页面(NewsListViewController)比较耗时，对于viewDidLoad以及viewWillAppear方法中尽量去尝试少做，晚做，不做 到这里之后其实已经差不多了，相信你应该有哪么写成就与收获。 除了这些，我们还可以喂项目做一些缓存优化 ccache 等缓存方案 优化 Xcode 配置 加钱堆硬件 以上优化方案出发点都是基础优化编译耗时来解决的。 哪有没有一个办法可以做到不编译就执行修改后的代码呢？ 答案肯定是：有的 基于 Objective-C 的动态特性，是完全可以做到这一点的，这也是各种热修复框架的支撑原理之一。那么如果需要做到不编译就执行修改后的代码，我们可以这样做： 获取本地修改后代码 -&gt; 转 JavaScript 或 Lua -&gt; 模拟器执行修改后的脚本。 获取本地修改代码 这里也有许多方法，可以手动复制，也可以自动获取。这里我是选择利用 Xcode Editor Extension 来获取到你选中的修改代码的。 Objective-C 转 JavaScript 由于整个流程我是基于 JSPatch 来开发的，所以是需要转为 JS 的脚本。这里我是写了个 node.js 的脚本来实现，转换算法是利用 https://github.com/bang590/JSPatchConvertor 中的开源代码。 模拟器执行修改后的脚本 由于已经有 JSPatch 完整的框架做支撑，这里只需要利用其中的方法 -[JPEngine evaluateScriptWithPath:] 去执行修改后的脚本即可。 当然这种有一定的缺陷，不管是针对苹果审核，还是学习成本，或者是其他意向不到的问题 使用之前还是慎重考虑，可以适当的使用作为部分模块的优化，或者作为学习。 至于后续的步骤就是，写好代码，逻辑，界面，优化…… 性能优化推荐：iOS应用性能调优的25个建议和技巧]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>App启动优化分析与总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——防止反编译总结]]></title>
    <url>%2F2017%2F10%2F26%2FiOS%E2%80%94%E2%80%94%E9%98%B2%E6%AD%A2%E5%8F%8D%E7%BC%96%E8%AF%91%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[iOS开发中有一个方向叫，你想工程开发，曾经也试着话时间去研究过相关的技术，熟悉使用那些相关的工具，但是毕竟没有专门实战过项目，也就只能简单的入门一下。而随着iOS开发年限的增长，和所了解到的东西，发现有不少公司或者朋友都在关注安全这一块，虽然Apple已经把安全做得很到位了，但是还是有这一块的问题存在，所以我根据个人的能力并结合网上的相关资料，简单的整理了一下，不管是作为了解，还是项目实战，或者为了面试，我都希望能有所帮助…… 已经app store上线的程序，苹果采取DRM进行保护，这样直接使用反汇编工具IDA是提示文件加密的，但现在DRM不堪一击。 先来说说iOS开发中有那些安全风险 iOS应用安全1、内购破解： 插件法（仅越狱）、iTools工具替换文件法（常见为存档破解）、八门神器修改 2、网络安全风险： 截获网络请求，破解通信协议并模拟客户端登录，伪造用户行为，对用户数据造成危害 ​3、应用程序函数PATCH破解：​&gt; 利用FLEX 补丁软件通过派遣返回值来对应用进行patch破解 4、源代码安全风险： 通过使用ida等反汇编工具对ipa进行逆向汇编代码，导致核心代码逻辑泄漏与被修改，影响应用安全 面对这些iOS应用存在的风险，iOS应用如何防止被反编译，防止反编译防砸壳我们要分析一个 app，最开始一般是砸壳 $ DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib /path/to/XXX.app/XXX 然后将解密之后的二进制文件扔给类似 hopper 这样的反编译器处理。 注意：直接将没有砸壳的二进制文件扔个 hopper 反编译出来的内容是无法阅读的（被苹果加密了） 对于这一步的防范，有两种方式。 限制二进制文件头内的段通过在 Xcode 里面工程配置 build setting 选项中将 -Wl,-sectcreate,RESTRICT,restrict,/dev/null 添加到 “Other Linker Flags” setuid 和 setgid （Apple 不接受调用这两个函数的 app，因为它可以通过查看符号表来判断您的二进制运行文件是否包含这两个函数） 检测tweak（越狱设备）我们会使用 TheOS 创建 tweak 类型的工程。然后针对我们要分析的类，使用提供的 logify.pl 命令生成的 mk 文件来打印该类所有方法的入参和出参。这对分析 app 的运行方式有很大的帮助。当然，我们也可以自己创建某个类的 mk，来 hook 某个函数，让它以我们想要的方式运行， 对于这一步的防范可以在工程的 main 函数里面加入一层判断，首先读取 /Library/MobileSubstrate/DynamicLibraries 下所有的 plist 文件的内容，查看是否某个 plist 含有你的 app 的 bundle id，是的话，可以判定有人想利用 tweak 攻击你的 app，这时候你可以采取比如说将 app 给 crash 掉，或者限制某些功能等方式来应对 就是 MobileSubstrate 在 app 加载到内存的时候会先去检查 /Library/MobileSubstrate/DynamicLibraries 下面是否有需要加载的 tweak，有的话就加载，怎么判断有没有？就是根据 plist 里面的 bundle ID 判断的。 防 http 抓包 就是将 NSURLSessionConfiguration 的 connection​Proxy​Dictionary 设置成空的字典，因为这个属性就是用来控制会话的可用代理的。 但是由于 OC 方法很容易被 hook，避免抓包是不可能的，所以，个人认为最好的方式是对请求参数进行加密（最好是非对称加密，比如 RSA） 加密硬编码的明文字符串 你的 app 被人抓包了，某些数据请求接口也被人发现了，那么很简单，逆向人员可以直接拷贝特征比较明显的字符串到 hopper 中搜索，通过查看该字符串被引用的地方，可以很快的找到相应的逻辑代码。 对于这一步的防范需要做的就是对硬编码的明文进行加密或混淆。 有个开源代码可以用，UAObfuscatedString，但是这个开源混淆代码写出来的字符串是相当长的（也就是麻烦），同时不支持加密,还有一个不错的MixPlainText（可以在编译期间加密所有代码中的明文字符串，在 app 运行的时候解密字符串） 使用 Swift 开发 class-dump 工具目前就不支持含有 Swift 的二进制文件。 TheOS 也是最近才开始支持 Swift，但是还没有加到主分支上（可以参见 Features）。所以目前来看，至少 Swift 可能比纯 OC 的工程要安全一点点 使用静态内连 C 函数由于 OC 语言的动态性，导致 OC 的代码是最容易被破解分析的。在安全性上，更推荐使用 C 语言写成的函数。但是 C 语言的函数也是可以被 hook 的，主要有3种方式： 使用 Facebook 开源的 fishhook 使用 MobileSubstrate 提供的 hook C 语言函数的方法 void MSHookFunction(void function, void replacement, void** p_original); 使用 mach_override，关于 mach_override 和 fishhook 的区别请看 mach_override 和 fishhook 区别 由于上面这三种方式可以 hook C 函数。要想不被 hook 解决方法是使用静态内联函数，这样的话需要被 hook 的函数没有统一的入口，逆向人员想要破解只能去理解该函数的逻辑。 使用 block严格来说使用 block 并不能很大程度提高安全性，因为逆向人员只要找到使用该 block 的方法，一般来说在其附近就会有 block 内代码的逻辑。 其实使用 block 的安全性是比直接使用 oc 方法是要高的。尤其是含有嵌套的 block 或者是作为参数传递的 block，处理起来就更加复杂了。所以，如果能将内敛 C 函数，嵌套 block ， block 类型参数组合起来的话，安全性应该是会有一定提升。 代码混淆（或者加密）方法体，方法名高级混淆 对应用程序的方法名和方法体进行混淆，保证源码被逆向后无法解析代码 程序结构混排加密 对应用程序逻辑结构进行打乱混排，保证源码可读性降到最低 本地数据加密 对NSUserDefaults，sqlite存储文件数据加密，保护帐号和关键信息 URL编码加密i 对程序中出现的URL进行编码加密，防止URL被静态分析 网络传输数据加密 对客户端传输数据提供加密方案，有效防止通过网络接口的拦截获取数据 代码混淆的方式有几种 添加无用又不影响逻辑的代码片段，迷糊逆向人员 对关键的类、方法，命名成与真实意图无关的名称 对于第二种，目前有一些自动化工具,个人认为最好的一个加密混淆工具是 ios-class-guard，不过目前这个项目已经停止维护了。但是这种方式的混淆我觉得才是最终极的方案。 念大婶在博客中介绍了两种方法，用于保护代码逻辑，对抗逆向分析 代码混淆 通过宏定义，混淆objective-c消息(函数)，用于对抗class-dump。 敏感逻辑用C实现 通过static关键字和函数指针的方式，将关键逻辑隐藏，可以对抗class-dump和Cycript攻击。 其实只有成功的应用才会被反编译资源。。。如果应用知名度不够高或者没什么用户量的话，无需浪费时间避免反编译，而是花时间、精力和金钱来迭代版本和推广App！ ######相关链接推荐 iOS程序 防止动态调试和代码注入 对 iOS app 进行安全加固 iOS 安全 之 方法混淆 iOS 对源代码进行混淆 iOS代码混淆]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>防止反编译总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——最新高级面试题整理（阿里篇）]]></title>
    <url>%2F2017%2F10%2F25%2FiOS%E2%80%94%E2%80%94%E6%9C%80%E6%96%B0%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E9%98%BF%E9%87%8C%E7%AF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[最近有朋友和同事在找工作，也问了一些相关的iOS技术问题，虽然今时不如往日，但是面试与面试之前的准备还是要做足的，即使我不用面试，但是我还是经常关注着一块的内容，就当回顾技术点和广度学习。最近有个朋友发了一串面试题给我，说是阿里的，听起来好高大上的样子，于是开始看了一下题目，看完后，顿时不知所措…… 具体问题 1.dSYM你是如何分析的？ 2.多线程有哪几种？你更倾向于哪一种？ 3.单例弊端？ 4.如何把异步线程转换成同步任务进行单元测试？ 5.介绍下App启动的完成过程？ 6.比如App启动过慢，你可能想到的因素有哪些？ 7.0x8badf00d表示是什么？ 8.怎么防止反编译？ 9.说说你遇到到的技术难点？ 10.说说你了解的第三方原理或底层知识？ 11.介绍下内存的几大区域？ 12.你是如何组件化解耦的？ 13.runtime如何通过selector找到对应的IMP地址 14.runloop内部实现逻辑？ 15.你理解的多线程？ 16.GCD执行原理？ 17.怎么防止别人动态在你程序生成代码 18.YYAsyncLayer如何异步绘制？ 19.优化你是从哪几方面着手？ 看完之后我相信你知道我为什么，顿时不知所措。 其实很多东西我们都知道，或者能说出一二，又或者用过，研究过，但是仔细回想一下，发现大部分问题的大部分答案或者内容都已经忘得差不多了 于是网上寻找并结合自己实际理解整理了一下 这是知乎上的部分答案: 阿里面试题 如果你想寻找各大互联网公司的面试题，请戳这里 各大互联网公司的面试题 1.dSYM你是如何分析的？Xcode编译项目后，我们会看到一个同名的 dSYM 文件，dSYM 是保存 16 进制函数地址映射信息的中转文件——称为符号表文件 http://www.cnblogs.com/quansir/p/5539682.htmlhttp://blog.csdn.net/openglnewbee/article/details/38824139 2.多线程有哪几种？你更倾向于哪一种？http://www.cocoachina.com/ios/20150731/12819.html 3.单例弊端？由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。 单例类的职责过重，在一定程度上违背了“单一职责原则”。 因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。 现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的共享对象长时间不被利用， 系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致共享的单例对象状态的丢失。 4.如何把异步线程转换成同步任务进行单元测试？http://www.cnblogs.com/goodboy-heyang/p/5277910.html 5.介绍下App启动的完成过程？https://icocos.github.io/2017/06/28/iOS%E2%80%94%E2%80%94App%E6%95%B4%E4%B8%AA%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/ 6.比如App启动过慢，你可能想到的因素有哪些？https://www.zhihu.com/question/19823199http://blog.csdn.net/Tencent_Bugly/article/details/77363817?locationNum=1&amp;fps=1 7.0x8badf00d表示是什么？异常代码 0x8badf00d 指示应用程序已终止的 iOS 因为看门狗超时发生。 应用程序时间太长，启动、 终止，或对系统事件作出响应。 一个常见的原因做在主线程上的同步联网。无论操作是线程 0 上： 需要搬到后台线程，或处理方式不同，所以，它不会阻止在主线程。 http://www.cnblogs.com/smileEvday/p/Crash1.htmlhttps://developer.apple.com/library/content/technotes/tn2151/_index.html#//apple_ref/doc/uid/DTS40008184-CH1-APPINFO 8.怎么防止反编译？http://blog.sina.com.cn/s/blog_134451adb0102wduz.htmlhttp://blog.sina.com.cn/s/blog_12f70aa790102vfd9.html 9.说说你遇到到的技术难点？http://blog.csdn.net/johnny_nass_hu/article/details/50854143http://www.cnblogs.com/ywr-zf/p/5917772.html 10.说说你了解的第三方原理或底层知识？https://github.com/Draveness/analyze 11.介绍下内存的几大区域？http://www.jianshu.com/p/5054c6932bdbhttps://www.baidu.com/link?url=CilnOv5mL3MVF50415d0SjkFgRpq_iNaZ44_Jiu1_1AQIi_qFqLMzvaRzqVoIUyI&amp;wd=&amp;eqid=f8f0a387000453cb0000000659f066f9http://www.cnblogs.com/chenjiangxiaoyu/p/7723154.html 12.你是如何组件化解耦的？http://blog.csdn.net/GGGHub/article/details/52713642https://www.2cto.com/kf/201611/552444.html 13.runtime如何通过selector找到对应的IMP地址http://blog.csdn.net/dp948080952/article/details/52437451 14.runloop内部实现逻辑？http://www.jianshu.com/p/1154df5d866fhttp://www.cocoachina.com/ios/20150601/11970.html 15.你理解的多线程？http://www.jianshu.com/p/5e96759a941b 16.GCD执行原理？http://www.jianshu.com/p/5840523fb3eahttp://www.cocoachina.com/bbs/read.php?tid-459704.html 17.怎么防止别人动态在你程序生成代码http://ruixiazun.blog.163.com/blog/static/9068791820141173588694/ 18.YYAsyncLayer如何异步绘制？http://ios.jobbole.com/86878/http://www.cnblogs.com/sunshine-anycall/p/7674021.html?utm_source=tuicool&amp;utm_medium=referral 19.优化你是从哪几方面着手？https://zhidao.baidu.com/question/181762176405714684.htmlhttps://www.2cto.com/kf/201505/401059.htmlhttps://zhidao.baidu.com/question/563610078113818364.htmlhttp://cache.baiducontent.com/c?m=9d78d513d9981cee4fede5697b17c0171e43f0132ba4a4027ea4843995732c40506793ac56510775d6d27d1716df4f4b9cf12173471451b18cb98e5ddccb85585e9f573e671df65662d60edfbd5154c037e75efeae69f0ccf525e2a9c5d2af4322b944737e94b7cb040f4e8c29b2033090bb840d501a07ba9a683eac053673d83440c116a4bf2f2c1a8aa7db5b4e942dd3611397ad&amp;p=8e6ac64ad4d000fa08e2977e085c8e&amp;newp=8f7f8f15d9c041aa0db8cf2d0214c1231610db2151d4da136b82c825d7331b001c3bbfb42324150ed2c77f6507ad485cebf232773c0127a3dda5c91d9fb4c57479dd726f&amp;user=baidu&amp;fm=sc&amp;query=iOS+%D3%C5%BB%AF%C4%E3%CA%C7%B4%D3%C4%C4%BC%B8%B7%BD%C3%E6%D7%C5%CA%D6%3F&amp;qid=82c11955000459a8&amp;p1=2 由于时间的原因，暂时先整理到这里，只是网上寻找了一些相关而且还不错的链接， 后期会专门抽时间整理这些问题 望谅解……]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>最新高级面试题整理（阿里篇）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——CocoaPods私有化组件]]></title>
    <url>%2F2017%2F10%2F25%2FiOS%E2%80%94%E2%80%94CocoaPods%E7%A7%81%E6%9C%89%E5%8C%96%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[相信你能看到这里，就一定用过cocoapods，cocoapods是什么呢？怎么用？算了吧，都是本文的范围，这里只介绍怎么将自己的项目组件进行私有化，其实严格来说不算什么私有化，只是，想自己写好的框架放到github或者其他平台上让他支持cocoapods管理。这类文章网上已经随处可见，但是由于打算开始写自己的框架，就记录了一下….. 首推荐 用CocoaPods做iOS程序的依赖管理 深入理解 CocoaPods CocoaPods 都做了什么? 如果你还不知道sm是CocoaPods，或者想对CocoaPods了解更深入一点的，可以先看看上面的推荐 1. 在github创建仓库完成，然后将仓库检出到本地注意创建事项： LICENSE(许可证)文件不可缺少，否则检测spec文件时，会有警告（选择MIT就OK） 不要使用中文，最好和库名字直接对应 其实也可以在其他平台，不一定是github 2. 将写好开源框架/库的Demo或者Example放到Git仓库下，还要将要开源的文件夹也放入到git仓库中（该文件夹在后面会被用到） 3. 项目发布到github后，我们在工程根目录中初始化一个Podspec文件：创建自己项目的Podspec描述文件: pod spec create iCocos 4. 编辑修改iCocos.podspec对应信息 可以直接参照我的内容进行修改 具体内容不介绍 s.name：名称，pod search 搜索的关键词,注意这里一定要和.podspec的名称一样,否则报错 s.version：版本号 s.ios.deployment_target:支持的pod最低版本 s.summary: 简介 s.homepage:项目主页地址 s.license:许可证 s.author:作者 s.social_media_url:社交网址,这里我写的微博默认是Twitter,如果你写Twitter的话,你的podspec发布成功后会@你 s.source:项目的地址 s.source = { :git =&gt; “https://github.com/al1020119/iCocos.git&quot;, :commit =&gt; “68defea” } s.source = { :git =&gt; “https://github.com/al1020119/iCocos.git&quot;, :tag =&gt; 1.0.0 } s.source = { :git =&gt; “https://github.com/al1020119/iCocos.git&quot;, :tag =&gt; s.version } commit =&gt; “68defea” 表示将这个Pod版本与Git仓库中某个commit绑定 tag =&gt; 1.0.0 表示将这个Pod版本与Git仓库中某个版本的comit绑定 tag =&gt; s.version 表示将这个Pod版本与Git仓库中相同版本的comit绑定 s.source_files:需要包含的源文件 s.resources: 资源文件 s.requires_arc: 是否支持ARC s.dependency：依赖库，不能依赖未发布的库，如 s.dependency = ‘AFNetworking’ s.dependency：依赖库，如有多个可以这样写。我这里是托管在github上,所以这里将地址copy过来就行了。 source_files: 核心代码的文件地址。 这里是经常出错的地方！—如果使用的是这种方式来显示核心代码地址而不是下面的模块化的话， 需要将代码文件必须以仓库名命名（也就意味着最多只有两个文件.h和.m文件了，可以有一个.h文件，把它作为头文件就行），这种方式检验podspec文件有点严格，否则就会报错。 source_files:写法及含义建议大家写第一种或者第二种 &quot;YJSettingTableView/* &quot;&quot;YJSettingTableView/YJSettingTableView/*.{h,m}&quot; &quot;YJSettingTableView/**/*.h&quot; “*” 表示匹配所有文件 “*.{h,m}” 表示匹配所有以.h和.m结尾的文件 “**” 表示匹配所有子目录 5. 设置tag号，提交修改（注：只要spec文件被修改，就必须重新执行如下命令）因为cocoapods是依赖tag版本的,所以必须打tag,以后再次更新只需要把你的项目打一个tag然后修改.podspec文件中的版本接着提交到cocoapods官方就可以了,提交命令请看下面 git commit -m “Release 1.0.0” (先提交当前修改) git tag “v1.0.0” (添加tag) //为git打tag, 第一次需要在前面加一个v git push –tags (推送tag到远程) git push origin master (推送到远程到代码仓库) 或许可能有些没有加入的（执行 git add . 就可以） 6. 提交之前先验证.podspec文件是否合法 pod spec lint iCocos.podspec –verbose pod spec lint iCocos.podspec –allow-warnings (忽略警告) 我这边在验证的时候出现了下面错误 LiudeMacBook:iCocos a115$ pod spec lint iCocos.podspec –verbose -&gt; iCocos (1.0.0) - ERROR | license: Sample license type. - ERROR | description: The description is empty. - ERROR | [iOS] unknown: Encountered an unknown error (The `iCocos` pod failed to validate due to 2 errors. [!] The validator for Swift projects uses Swift 3.0 by default, if you are using a different version of swift you can use a `.swift-version` file to set the version for your Pod. For example to use Swift 2.3, run: `echo &quot;2.3&quot; &gt; .swift-version`: - ERROR | license: Sample license type. - ERROR | description: The description is empty. ) during validation. Analyzed 1 podspec. [!] The spec did not pass validation, due to 3 errors. [!] The validator for Swift projects uses Swift 3.0 by default, if you are using a different version of swift you can use a `.swift-version` file to set the version for your Pod. For example to use Swift 2.3, run: `echo &quot;2.3&quot; &gt; .swift-version`. 根据上面提示了三个错误（due to 3 errors），其实是两个，1，3是一个 1. description is empty这里原始description是这样的 `s.description = &lt;&lt;-DESC` `DESC` 需要改成一段属于自己的描述，其他信息类型修改 关于swift-version 这里直接执行echo &quot;2.3&quot; &gt; .swift-version就正常的 但是据需验证又出现如下错误： LiudeMacBook:iCocos a115$ pod spec lint iCocos.podspec -&gt; iCocos (1.0.0) - ERROR | [iOS] unknown: Encountered an unknown error ([!] /usr/bin/git clone https://github.com/al1020119/iCocos.git /var/folders/4z/d12mnyfx7c37vg91t8h0941h0000gp/T/d20171025-8857-1oau87 --template= --single-branch --depth 1 --branch 1.0.0 Cloning into &apos;/var/folders/4z/d12mnyfx7c37vg91t8h0941h0000gp/T/d20171025-8857-1oau87&apos;... warning: Could not find remote branch 1.0.0 to clone. fatal: Remote branch 1.0.0 not found in upstream origin ) during validation. Analyzed 1 podspec. [!] The spec did not pass validation, due to 1 error. 这里其实不是错误，是没有更新处理，前面说了： （注：只要spec文件被修改，就必须重新执行如下命令） git commit -m &quot;Release 1.0.0&quot; (先提交当前修改) git tag 1.0.0 (添加tag) git push --tags (推送tag到远程) git push origin master (推送到远程到代码仓库) 或许可能有些没有加入的（执行 git add . 就可以） 7. 然后再次验证就会成功 LiudeMacBook:iCocos a115$ pod spec lint iCocos.podspec –verbose -&gt; iCocos (1.0.0) Analyzed 1 podspec. iCocos.podspec passed validation. 或许你还可能遇到下面的错误，不过不要慌，直接按照下面操作就可以 先删除tag // 删除本地tag git tag -d 1.0.0 // 删除远程tag git push origin -d tag 1.0.0 修改spec文件（必须修改相应的version和source）重新执行–&gt;设置tag号，提交修改的步骤 8. trunk推送podspec文件podspec文件验证成功，通过trunk推送podspec文件 pod trunk push iCocos.podspec 如果你是第一次，并且没有帐号你会看到下面一段 LiudeMacBook:iCocos a115$ pod trunk push iCocos.podspec [!] You need to register a session first. Usage: $ pod trunk push [PATH] Publish the podspec at `PATH` to make it available to all users of the ‘master’ spec-repo. If `PATH` is not provided, defaults to the current directory. Before pushing the podspec to cocoapods.org, this will perform a local lint of the podspec, including a build of the library. However, it remains *your* responsibility to ensure that the published podspec will actually work for your users. Thus it is recommended that you *first* try to use the podspec to integrate the library into your demo and/or real application. If this is the first time you publish a spec for this pod, you will automatically be registered as the ‘owner’ of this pod. (Note that ‘owner’ in this case implies a person that is allowed to publish new versions and add other ‘owners’, not necessarily the library author.) Options: --allow-warnings Allows push even if there are lint warnings --use-libraries Linter uses static libraries to install the spec --swift-version=VERSION The SWIFT_VERSION that should be used to lint the spec. This takes precedence over a .swift-version file. --skip-import-validation Lint skips validating that the pod can be imported --skip-tests Lint skips building and running tests during validation --silent Show nothing --verbose Show more debugging information --no-ansi Show output without ANSI codes --help Show help banner of specified command 根据上面的提示是告诉你：需要你用邮箱注册一个trunk 9. 我们直接使用终端注册pod trunk register al10201119@163.com &quot;iCocos&quot; --description=&quot;iCocos&quot; 之后会有一封带有验证链接的邮件发送到你输入的邮箱，点击验证后就可以回来终端继续提交操作了。 已经注册过的不需要注册,怎么看自己有没有注册 pod trunk me 10. 发布代码到cocoapodspod trunk push iCocos.podspec --verbose pod trunk push iCocos.podspec --allow-warnings 发布时会验证 Pod 的有效性，如果你在手动验证 Pod 时使用了 –use-libraries 或 –allow-warnings 等修饰符，那么发布的时候也应该使用相同的字段修饰，否则出现相同的报错。 pod trunk push iCocos.podspec –verbose 一段很长的描述，然后你会看到下面的成功提示 11. 如果提交到cocoapods还有可能遇到下面错误：Updating spec repo &apos;master&apos; warning: inexact rename detection was skipped due to too many files. warning: you may want yo set your diff.renameLimit variable to at least 3080 an retry the command ... [!] There was an error pushing a new version to trunk: execution expired 这里有解决方案：http://www.sw33tcode.com/?p=31 git config merge.renameLimit 999999 git config --unset merge.renameLimit 12. 然后开始去搜索我的库了但是发现既然没有，各种排查，最后发现由于延时的问题，不过如果还是不出现的，网上找到了相应的方案： 删除~/Library/Caches/CocoaPods目录下的search_index.json文件 pod setup成功后会生成~/Library/Caches/CocoaPods/search_index.json文件。 终端输入rm ~/Library/Caches/CocoaPods/search_index.json 删除成功后再执行pod search 稍等片刻，然后pod search就会出现你所要搜的类库了。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>CocoaPods私有化组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——Objective-C与Swift优缺点对比]]></title>
    <url>%2F2017%2F09%2F19%2FiOS%E2%80%94%E2%80%94Objective-C%E4%B8%8ESwift%E4%BC%98%E7%BC%BA%E7%82%B9%E5%AF%B9%E6%AF%94%2F</url>
    <content type="text"><![CDATA[最近有个朋友（同事）在找工作，一起讨论关于面试过程中的面试题，有不少关于Objective-C的技术问题，尤其是关于一些技术的底层实现，当然这个在之前的文章中有整理，其中有一个问题就是关于Objective-C和Swift区别，与优缺点的对比，由于我刚使用Swift实战开发并不久，过去三年多都都是搞Objective-C，所以对Swift和Objective-C优缺点还真没有多少简介，虽然网上也有不少相关的资料和回答，但是想想这个问题以后再很多打算或者还没有开始使用Swift的公司会被经常问到，所以就花了点时间整理一下………. 简介Swift，苹果于2014年WWDC（苹果开发者大会）发布的新开发语言（已开源），可与Objective-C*共同运行于Mac OS和iOS平台，用于搭建基于苹果平台的应用程序。 动态性Swift 是一种强类型语言。类型静态，也就是说 Swift 的默认类型是非常安全的。 Swift 当中存在有这两个修饰符@objc和@dynamic，此外我们同样还可以访问NSObject。 @objc将您的 Swift API 暴露给 Objective-C 运行时，但是它仍然不能保证编译器会尝试对其进行优化。 如果您真的想使用动态功能的话，就需要使用@dynamic。一旦您使用了@dynamic修饰符之后，就不需要添加@objc了，因为它已经隐含在其中。 Swift比Objective-C有什么优势？ Swift容易阅读，语法和文件结构简易化。 Swift更易于维护，文件分离后结构更清晰。 Swift更加安全，它是类型安全的语言。 Swift代码更少，简洁的语法，可以省去大量冗余代码 Swift速度更快，运算性能更高。 Swift目前存在的缺点 版本不稳定，之前升级Swift3大动刀，苦了好多人，swift4目前还未知 使用人数比例偏低，目前还是OC的天下 社区的开源项目偏少，毕竟OC独大好多年，很多优秀的类库都不支持Swift，不过这种状况正在改变，现在有好多优秀的Swift的开源类库了 公司使用的比例不高，很多公司以稳为主，还是在使用OC开发，很少一些在进行混合开发，更少一些是纯Swift开发。 偶尔开发中遇到的一些问题，很难查找到相关资料，这是一个弊端。 纯Swift的运行时和OC有本质区别，一些OC中运行时的强大功能，在纯Swift中变无效了。 对于不支持Swift的一些第三方类库，如果非得使用，只能混合编程，利用桥接文件实现。 整体总结 String： Swift中String操作已经甩OC三百万条街 泛型： Swift泛用性还是不够强，如果项目不止涉及常用的http啊xmpp啊之类的协议，而是要做一些SIP啊FFMPEG啊之类的干活，那明显是OC成熟得多 Discriminated Union swift里的enum. 是静态语言独有的特性. 安全： 由于swift的strong static type system，编译器可帮你检查出更多问题，而不是在运行时突然boom，还有一个很牛逼的安全特性就是OptionalType。 快速： 静态相对来说语言本身速度更快，swift编译期就能生成vtable，确定具体要调用的方法，比起oc的动态派发自然是更快，当然处理到与oc之间桥接部分，可能不一定比oc快 细节使用区别 在 Swift 中没有了 main.m，@UIApplicationMain 是程序入口 swift不分.h和.m文件 ，一个类只有.swift一个文件，所以整体的文件数量比起OC有一定减少。 swift句尾不需要分号 ，除非你想在一行中写三行代码就加分号隔开。 在 Swift 中，一个类就是用一对 { } 括起的，没有 @implementation 和 @end swift数据类型都会自动判断 ， 只区分变量var 和常量let 强制类型转换格式不同 OC强转：(int)a Swift强转：Int(a) 关于BOOL类型更加严格 ，Swift不再是OC的非0就是真，而是true才是真false才是假 swift的 循环语句中必须加{}就算只有一行代码也必须要加 swift的switch语句后面可以跟各种数据类型了 ，如Int、字符串都行，并且里面不用写break（OC好像不能字符串） swift if后的括号可以省略: if a&gt;b {}，而OC里 if后面必须写括号。 swift打印 用print(&quot;&quot;) 打印变量时可以 print(&quot;\(value)&quot;)，不用像OC那样记很多%@，d%等。 Swift3的【Any】可以代表任何类型的值，无论是类、枚举、结构体还是任何其他Swift类型，这个对应OC中的【id】类型。 在 OC 中 alloc / init 对应( ) 在 OC 中 alloc / initWithXXX 对应 (XXX: ) 在 OC 中的类函数调用，在 Swift 中，直接使用 . 在 Swift 中，绝大多数可以省略 self.，建议一般不写，可以提高对语境的理解（闭包时会体会到） 在 OC 中的 枚举类型使用 UIButtonTypeContactAdd，而 Swift 中分开了，操作热键：回车-&gt; 向右 -&gt;. Swift 中，枚举类型的前缀可以省略，如：.ContactAdd，但是：很多时候没有智能提示 监听方法，直接使用字符串引起 循环引用问题Objective-C中循环引用也是遇到比较多的，一不小心就会导致循环引用，甚至导致内存问题 Swift [weak self] self是可选项，如果self已经被释放，则为nil [unowned self] self不是可选项，如果self已经被释放，则出现野指针访问 Objective-C __weak typeof(self) weakSelf; 如果self已经被释放，则为nil __unsafe_unretained typeof(self) weakSelf; 如果self已经被释放，则出现野指针访问 参考：推荐几个Objective-C的框架 FBRetainCycleDetector PLeakSniffer MLeaksFinder]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C与Swift优缺点对比</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发——SVG图展示方案]]></title>
    <url>%2F2017%2F09%2F14%2FiOS%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94SVG%E5%9B%BE%E5%B1%95%E7%A4%BA%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[最近，接到了一个需求，关于iOS中加载SVG图片的实现，就我了解苹果是没有提供这种API直接加载SVG图片的，但是发现网上有各种资料和相关库的实现，于是为了实现这个需求专门了解了一下，虽然最后没有用到牛逼的技术，或者没有话太多时间在SVG的解析上，但是这一路也折腾的挺累的，于是就有了这篇文章 SVG简介首先我们来看看上面是SVG svg 可缩放的矢量图形 SVG 可伸缩矢量图形 (Scalable Vector Graphics) SVG 文件是纯粹的 XML SVG 图像在放大或改变尺寸的情况下其图形质量不会有所损失 简单的说就是svg格式的图不会随着图片的缩放出现模糊、svg图实际是xml格式的，可以通过代码获取各种element 参考资料：http://www.ibm.com/developerworks/cn/web/wa-scalable/ SVG相关库由于在ios中源生的api没有提供相关的操作，但是可喜的是有第三方库提供了操作：SVGKit 使用SVGKit库显示svg图： 1、使用SVGKit库显示svg图 2、实现svg图的缩放操作 3、点击svg图的某个部分，获取svg图的某个部分 SVGKit的地址：https://github.com/SVGKit/SVGKit代码中集成SVGKit参考：http://stackoverflow.com/questions/3520977/build-fat-static-library-device-simulator-using-xcode-and-sdk-4/3647187#3647187 SVGKit是一个非常强大的，可以快速渲染SVG文件的框架，由Matt Rajca开发。你可以直接把SVG文件加载至app中，并且SVG中的每个图形会变成一个CAShapeLayer，可以方便地进行缩放和动画你的图形。SVGKit包含iOS和Mac示例，不过不支持渐变。可以从github上查看使用说明、示例以及下载相关的类。如果你想渲染app中的矢量图形，SVGKit是个不错的解决办法。 SVG图片加载加载网络文件目前来说，苹果相册并不支持SVG的存储，但是由于公司考虑到用户可能在PC端上传对应的SVG文件到服务器，当在客户端操作相册或者需要上传SVG图片的时候，就需要将用户上传到服务器的SVG获取并显示到界面，以供用户上传SVG的初衷。 一路来其实考虑了各种方案，但是由于目前还没有找到特别符合项目，特别好，而且是Swift版的库，就选择的使用WebView来直接加载SVG 上代码 if (isSVG) { self.webView = [[WebView alloc] initWithConfiguration:nil]; self.webView.frame = CGRectMake(index * CGRectGetWidth(visibleBounds), 0, CGRectGetWidth(visibleBounds), CGRectGetHeight(visibleBounds)); self.webView.autoresizingMask = UIViewAutoresizingFlexibleHeight | UIViewAutoresizingFlexibleWidth; self.webView.contentMode = UIViewContentModeRedraw; self.webView.opaque = YES; self.webView.allowsBackForwardNavigationGestures = NO; // 解决本地文件svg模拟器能正常打开，真机无法打开白屏问题 if ([originURL isFileURL]) { SEL sel = NSSelectorFromString(@&quot;loadFileURL:allowingReadAccessToURL:&quot;); if ([self.webView respondsToSelector:sel]) { NSString* directory = [originURL.absoluteString stringByDeletingLastPathComponent]; SEL myMethod = @selector(loadFileURL:allowingReadAccessToURL:); // 返回一个方法 如果那个方法找不到则返回nil NSMethodSignature *signature = [[WKWebView class] instanceMethodSignatureForSelector:myMethod]; NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature]; [invocation setSelector:myMethod]; NSURL *loadFileURL = originURL; NSURL *allowingReadAccessToURL = [NSURL URLWithString:directory]; //注意：1、这里设置参数的Index 需要从2开始，因为前两个被selector和target占用。下面这样写也没有任何 [invocation setArgument:&amp;loadFileURL atIndex:2]; [invocation setArgument:&amp;allowingReadAccessToURL atIndex:3]; invocation.target = self.webView; [invocation invoke]; } else { // load the passed in URL [self.webView loadRequest:[NSURLRequest requestWithURL:originURL]]; } } else { [self.webView loadRequest:[NSURLRequest requestWithURL:originURL]]; } [view addSubview:self.webView]; self.photoCurrentModel = ((UDPhotoModel *)obj); if (index == 0) { self.webView.tag = 10000; } else { self.webView.tag = 0; } // 长安弹出手势 UILongPressGestureRecognizer *longPress = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(handleLongPressWebImage:)]; longPress.minimumPressDuration = 1; longPress.delegate = self; [self.webView addGestureRecognizer:longPress]; // 单击手势 UITapGestureRecognizer *tapWeb = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(handleTapWebImage:)]; tapWeb.delegate = self; [self.webView addGestureRecognizer:tapWeb]; // 轻扫手势 UIPanGestureRecognizer *panWebImageBack = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(panWebImageBackAction:)]; panWebImageBack.delegate = self; [self.webView addGestureRecognizer:panWebImageBack]; } 交互操作的实现由于根据项目的需求，我们需要对SVG图片进行一个操作，但是本身使用WebView加载的SVG，因此只能使用手势的方式，增加对他的交互 /** * 要想让点击手势起作用需要实现 * 如果第一个手势是点击第二个是长按就返回NO 不支持同时响应长按和点击手势 */ - (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer { if ([otherGestureRecognizer isKindOfClass:[UILongPressGestureRecognizer class]] &amp;&amp; [gestureRecognizer isKindOfClass:[UITapGestureRecognizer class]]) { return NO; } else { return YES; } } - (void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation{ // 不执行前段界面弹出列表的JS代码 [self.webView evaluateJavaScript:@&quot;document.documentElement.style.webkitTouchCallout=&apos;none&apos;;&quot; completionHandler:nil]; } -(void)panWebImageBackAction:(UIPanGestureRecognizer *)gest{ if (gest.state == UIGestureRecognizerStateChanged) { [self commitTranslation:[gest translationInView:gest.view] tagIndex:gest.view.tag]; } } /** * 判断手势方向 * * @param translation translation description */ - (void)commitTranslation:(CGPoint)translation tagIndex:(NSInteger)tagIndex { CGFloat absX = fabs(translation.x); CGFloat absY = fabs(translation.y); // 设置滑动有效距离 if (UIUserInterfaceIdiomIsPad()) { if (MAX(absX, absY) &lt; 300) return; } else { if (MAX(absX, absY) &lt; 150) return; } if (absX &gt; absY ) { if (translation.x&lt;0) { //向左滑动 }else{ //向右滑动 } } else if (absY &gt; absX) { if (translation.y&lt;0) { //向上滑动 }else{ //向下滑动 } } } // 单击 - (void)handleTapWebImage:(UITapGestureRecognizer *)sender { } // 长按 - (void)handleLongPressWebImage:(UILongPressGestureRecognizer *)sender{ } 加载本地文件加载本地SVG的时候，其实和加载本地的html，pdf等式一样的，打开之后完全是一个网页 具体如下： NSString *svgName = @&quot;svg名称&quot;; NSString *svgPath = [[NSBundle mainBundle] pathForResource:svgName ofType:nil]; NSData *svgData = [NSData dataWithContentsOfFile:svgPath]; NSString *reasourcePath = [[NSBundle mainBundle] resourcePath]; NSURL *baseUrl = [[NSURL alloc] initFileURLWithPath:reasourcePath isDirectory:true]; UIWebView *webView = [[UIWebView alloc] init]; webView.frame = CGRectMake(0, 0, width, height); [webView loadData:svgData MIMEType:@&quot;image/svg+xml&quot; textEncodingName:@&quot;UTF-8&quot; baseURL:baseUrl]; 总结：如果想要交互并且放大缩小，难度就大了，然后我就百度了下，发现了个好东西SVGKit 由于项目的原因，暂时只能考虑使用WebView来实现了，后期有机会专门研究一下SVG的加载过程或者将它替换成使用库的方式当然，我也希望苹果能够增加对SVG的支持，哈哈！ 误操作考虑到WebView默认的特性是，所有内容会直接放在左上角，如果你没有对她进行一些适应的话于是我想到了，之前用WebView加载HTML的方式，去执行JS代码将它居中，以控制内部内容居中 [webView evaluateJavaScript:@&quot;Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight)&quot; completionHandler:^(id _Nullable result, NSError * _Nullable error) { if (!error) { } }]; 不执行前段界面弹出列表的JS代码 [webView evaluateJavaScript:@&quot;document.documentElement.style.webkitTouchCallout=&apos;none&apos;;&quot; completionHandler:nil]; // 执行JS，是WebView内容剧中，边距自适应：这里无效，具体原因不明， // 预览同张svg图片两端预览效果不一致(https://yun.115.com/5/T339573.html#) [webView evaluateJavaScript:@&quot;document.getElementsByTagName(&apos;body&apos;)[0].style.verticalAlign = &apos;middle&apos;;&quot; completionHandler:nil]; [webView evaluateJavaScript:@&quot;document.getElementsByTagName(&apos;body&apos;)[0].style.textAlign = &apos;center&apos;;&quot; completionHandler:nil]; [webView evaluateJavaScript:@&quot;document.getElementById(&apos;mapid&apos;).style.margin = &apos;auto&apos;;&quot; completionHandler:nil]; 但是发现并没有什么卵用，试了好久才发现自己，傻逼了，SVG是XML格式的，并不能像HTML一样，使用JS去执行对应的DOC操作于是，就停下了。 直到现在暂时还没有找到对应的方案，由于Android能够控制SVG居中适应，导致我这边有一个区配合Android的Bug如果您知道怎么处理或者有什么好的方案，欢迎联系我，或者有什么好的建议和简介，我们可以一起交交流与学习。 参考http://www.cocoachina.com/ios/20161115/18087.html https://segmentfault.com/a/1190000002580541]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift——简单服务端开发实战]]></title>
    <url>%2F2017%2F09%2F12%2FSwift%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[相比不少iOS开发者在平时业余时间，都学习或者瞎搞过非iOS开发相关的技术，比如PHP，H5，Python，Kotlin，Go等，但是不管是为了打发时间，还是作为业余学习爱好，或者是广度拓展知识量，抑或者为了装逼，但是对我来说目前吃饭的家伙依然还是iOS，虽然iOS依然学的很水，就在5月份的时候去深圳参加过一次2017@Swift开发者大会，除了感触自己英语很差之外，还有一个记忆深刻的话题就是关于使用Swift开发服务端应用，当时确实有不少人在学习和研究相关技术，由于工作的原因也就没有去捣鼓，当然也可能是因为Swift开发服务端并不是那么稳定，完善，最近不知道为撒，突然想花点时间尝试一下，不管结果怎样或者是不是外面传的那么牛逼，我就当尝鲜吧……哈哈！ 前言 这里就不介绍什么Swift相关的知识了，如果不了解或者不够熟悉Swift的请查看相关文档 目前而言关于Swift开发服务端应用的库比较好的有两个：Vapor和Perfect当然也还有其他关于类似的，具体可以参考这里的对比：服务端写Swift体验 (Perfect框架) 因为我所在的一个2017@Swift开发者大会群中，其中有一位是Perfect作者之一，而且经常有听到关于Perfect的讨论，我也前往官网和github看了一下，文档非常详细，star也有12k，所以我决定从Perfect开始尝试。当然Vapor据说也不错，有机会也可以研究一下，然后对比，选择一个适合自己的来做点小东西。 Vapor参考：服务端 Swift - Vapor 篇 介绍摘自官网:Perfect是一组完整、强大的工具箱、软件框架体系和Web应用服务器，可以在Linux、iOS和macOS (OS X)上使用。 该软件体系为Swift工程师量身定制了一整套用于开发轻量、易维护、规模可扩展的Web应用及其它REST服务的解决方案， 这样Swift工程师就可以实现同时在服务器和客户端上采用同一种语言开发软件项目。 由于建立在一个高性能异步网络引擎基础上，Perfect还能够在FastCGI上运行，支持安全套接字加密（SSL）。 该软件体系还包含很多其它互联网服务器所需要的特点，包括WebSockets和iOS消息推送，而且很快会有更多强大的功能支持。 其实总结一句就是： Perfect是一套可以用来开发服务端应用的Swift库。 第一步：装备阶段开发环境 开发设备：MacBook Pro Xcode9.6、Swift3.1 homebrew 终端命令,以下是安装命令 /usr/bin/ruby -e “$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 环境配置swift –versioniCocos:blog icocos$ swift --version Apple Swift version 3.1 (swiftlang-802.0.53 clang-802.0.42) Target: x86_64-apple-macosx10.9 注意：最新版本的Swift 3.0。如果低于3.0版本则Perfect是无法成功编译。 软件Perfect依赖于若干软件接口库，比如OpenSSL、libssl-dev和uuid-dev brew install openssl libssl-dev uuid-dev 编译项目Clonegit clone https://github.com/PerfectlySoft/PerfectTemplate.git Swift编译命令cd PerfectTemplate swift build 命令行启动Swift Server.build/debug/PerfectTemplate 编译后可以启动一个本地的服务器，监听您计算机的8181端口： iCocos:PerfectTemplate icocos$ .build/debug/PerfectTemplate [INFO] Starting HTTP server localhost on 0.0.0.0:8181 服务器现在已经运行并等待连接。从浏览器打开http://localhost:8181/ 可以看到“Hello, world!”信息。 是不是感觉很熟悉，这不是和学习PHP的时候一样的吗？ XcodeSwift软件包管理器（SPM）能够创建一个Xcode项目，并且能够运行PerfectTemplate模板服务器，还能为您的项目提供完全的源代码编辑和调试。在您的终端命令行内输入： swift package generate-xcodeproj 然后打开产生的文件“PerfectTemplate.xcodeproj”，确定选择了可执行的目标文件，并选择在“我的Mac”运行。现在您可以运行并调试服务器了。 iCocos:PerfectTemplate icocos$ swift package generate-xcodeproj generated: ./PerfectTemplate.xcodeproj 运行项目打开Clone下来的项目文件PerfectTemplate中的.xcodeproj文件，选择带命令行图片（不能选错）的目标运行一行代码都不用写，就会发现Xcode命令行打印了一段： [INFO] Starting HTTP server localhost on 0.0.0.0:8181 到这里第一步基本上已经完成，下面基本上就可以开始撸代码了。 第二步：初步调整调整接口返回数据找到main.swift文件，handler方法中有这么一段： // An example request handler. // This &apos;handler&apos; function can be referenced directly in the configuration below. func handler(data: [String:Any]) throws -&gt; RequestHandler { return { request, response in // Respond with a simple message. response.setHeader(.contentType, value: &quot;text/html&quot;) response.appendBody(string: &quot;&lt;html&gt;&lt;title&gt;Hello, world!&lt;/title&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;&quot;) // Ensure that response.completed() is called when your processing is done. response.completed() } } 直接将Hello, world!替换为想要的内容，再在浏览器输入 0.0.0.0:8181刚刚所修改的内容就会直接显示出来。 慢慢的，我发现和之前学习PHP所设计的步骤和操作越来越像 添加软件包打开PerfectTemplate项目中的Package.swift，在package前面添加需要的软件包，并替换package中dependencies获取方式 //软件包管理 import PackageDescription let versions = Version(0,0,0)..&lt;Version(10,0,0) let urls = [ &quot;https://github.com/PerfectlySoft/Perfect-HTTPServer.git&quot;, //HTTP服务 &quot;https://github.com/PerfectlySoft/Perfect-MySQL.git&quot;, //MySQL服务 &quot;https://github.com/PerfectlySoft/Perfect-Mustache.git&quot; //Mustache ] let package = Package( name: &quot;PerfectDemoProject&quot;, targets: [], dependencies: urls.map { .Package(url: $0, versions: versions) } ) 第三步：搭建HTTP服务器关于HTTP服务器配置官方（HTTP 服务器）其实已经给出了一个比较完成的介绍，但是由于篇幅过长这里就整理了一下： 1.编辑main.swift import PerfectLib import PerfectHTTP import PerfectHTTPServer //HTTP服务 let networkServer = NetworkServerManager(root: &quot;webroot&quot;, port: 8888) networkServer.startServer() 2.创建并编辑NetworkServerManager.swift import PerfectLib import PerfectHTTP import PerfectHTTPServer open class NetworkServerManager { fileprivate var server: HTTPServer internal init(root: String, port: UInt16) { server = HTTPServer.init() //创建HTTPServer服务器 var routes = Routes.init(baseUri: &quot;/api&quot;) //创建路由器 configure(routes: &amp;routes) //注册路由 server.addRoutes(routes) //路由添加进服务 server.serverPort = port //端口 server.documentRoot = root //根目录 server.setResponseFilters([(Filter404(), .high)]) //404过滤 } //MARK: 开启服务 open func startServer() { do { print(&quot;启动HTTP服务器&quot;) try server.start() } catch PerfectError.networkError(let err, let msg) { print(&quot;网络出现错误：\(err) \(msg)&quot;) } catch { print(&quot;网络未知错误&quot;) } } //MARK: 注册路由 fileprivate func configure(routes: inout Routes) { // 添加接口,请求方式,路径 routes.add(method: .get, uri: &quot;/&quot;) { (request, response) in response.setHeader( .contentType, value: &quot;text/html&quot;) //响应头 let jsonDic = [&quot;hello&quot;: &quot;world&quot;] let jsonString = self.baseResponseBodyJSONData(status: 200, message: &quot;成功&quot;, data: jsonDic) response.setBody(string: jsonString) //响应体 response.completed() //响应 } } //MARK: 通用响应格式 func baseResponseBodyJSONData(status: Int, message: String, data: Any!) -&gt; String { var result = Dictionary&lt;String, Any&gt;() result.updateValue(status, forKey: &quot;status&quot;) result.updateValue(message, forKey: &quot;message&quot;) if (data != nil) { result.updateValue(data, forKey: &quot;data&quot;) }else{ result.updateValue(&quot;&quot;, forKey: &quot;data&quot;) } guard let jsonString = try? result.jsonEncodedString() else { return &quot;&quot; } return jsonString } //MARK: 404过滤 struct Filter404: HTTPResponseFilter { func filterBody(response: HTTPResponse, callback: (HTTPResponseFilterResult) -&gt; ()) { callback(.continue) } func filterHeaders(response: HTTPResponse, callback: (HTTPResponseFilterResult) -&gt; ()) { if case .notFound = response.status { response.setBody(string: &quot;404 文件\(response.request.path)不存在。&quot;) response.setHeader(.contentLength, value: &quot;\(response.bodyBytes.count)&quot;) callback(.done) } else { callback(.continue) } } } } 3.运行项目 可以看到底部打印 启动HTTP服务 [INFO] Starting HTTP server localhost on 0.0.0.0:8181 4.重新刷新浏览器链接会发现 { &quot;status&quot;:200 &quot;date&quot;: { &quot;hello&quot;: &quot;world&quot; } &quot;message&quot;: &quot;成功&quot; } 这里我们平时开发中返回的标准格式，具体含义这里就不介绍了 遇到的问题（报错）及解决方案：1.swift build：SSLRead() return error -9806报错 brew remove git brew remove curl brew install openssl brew install --with-openssl curl brew install --with-brewed-curl --with-brewed-openssl git swift build Swift开发服务端应用完整资料： Swift 服务端开发 Perfect、Vapor资料]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>底层分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发——系统API使用问题汇总（+解决方案）]]></title>
    <url>%2F2017%2F08%2F08%2FiOS%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9FAPI%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%EF%BC%88-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[平时实际开发中遇到最多的问题是什么？Bug？技术实现？技术难点？接口使用？方法优化？界面调整？ 其实最后总结来说终究是关于Api的问题，因为不管怎么样最后总会转成苹果对应的Api或者底层与处理。那么我们在使用苹果系统API的时候会遇到一些什么问题呢？也许你会说查文档，但是如果文档也没有提到相关的解决方案呢？那就懵逼了…… 1. 解决添加tap手势后点击cell无响应实现UIGestureRecognizerDelegate协议下面的方法1func gestureRecognizer(gestureRecognizer: UIGestureRecognizer, shouldReceiveTouch touch: UITouch) -&gt; Bool &#123; if NSStringFromClass(touch.view!.classForCoder) == &quot;UITableViewCellContentView&quot;&#123; return false &#125; return true &#125; 2.cell分割线不留空格12cell.preservesSuperviewLayoutMargins = falsecell.layoutMargins = UIEdgeInsetsZero 3.UISlider无法拖动进度条的问题解决在我听播放详情页的时候UISlider刚开始播放的时候距离左边20像素的位置之前的是不能拖动的，因为iOS在左边预留了20像素的手势返回处理。 当UISlider起始位置贴近屏幕边框的时候，UISilder不能拖动的原因是因为手势返回的原因，需要关闭手势返回就可以了。123- (BOOL)navigationControllerShouldDragback:(UINavigationController *)navigationController &#123;return false;&#125; 4.view被导航条给覆盖了，并没有从导航条的下面开始布局解决方法：（1）、设置edgesForExtendedLayout1self.edgesForExtendedLayout = UIRectEdgeNone; //view不需要拓展到整个屏幕 （2）、设置导航条的透明度1self.navigationController.navigationBar.translucent = NO; 5.我听设置当音频被占用的时候（如电话进来）系统会自动暂停当前使用的音频，如果想要系统使用完毕后恢复自己的音频使用 需要 播放自己的音频前设置：1[[AVAudioSession sharedInstance] setActive:NO withOptions:AVAudioSessionSetActiveOptionNotifyOthersOnDeactivation error:nil]; 然后设置系统音频中断恢复的通知1[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleInterruption:) name:AVAudioSessionInterruptionNotification object:[AVAudioSession sharedInstance]]; 中断发生时,应用程序的AVAudioSession会发送通知AVAudioSessionInterruptionNotification,注册通知代码如下:12在接收到通知的userInfo中,会包含一个AVAudioSessionInterruptionTypeKey,用来标识中断开始和中断结束.当中断类型为AVAudioSessionInterruptionTypeKeyEnded时,userInfo中还会包含一个AVAudioSessionInterruptionOptions来表明音频会话是否已经重新激活以及是否可以再次播放 6.跟xib一起走过的坑如果在xib中有一个控件, 已经明确设置尺寸了,输出的frame也是对的, 但是显示出来的效果不一样(比如尺寸变大了), 如果是这种情况一般就是autoresizingMask自动伸缩属性在搞鬼! 解决办法如下:1234//xib的awakeFromNib方法中设置UIViewAutoresizingNone进行清空- (void)awakeFromNib &#123;self.autoresizingMask = UIViewAutoresizingNone;&#125; 或者在layoutSubView中重新设置contentView的frame 7.一生部分对于系统视频音频API的使用较多，这里把我记得的坑公示，防止以后大家踩坑。 1.系统初始化AVCaptureSession的时候不能直接调用startSession的方法，需要先调用stopSession方法停止当前session，然后再调用startSession方法。否则会出现卡死主线程的问题。 （这里如果不手动显示调用stopSession，那么系统会利用主线程去停止session，而停止session是一个耗时操作，就会卡死主线程，出现页面卡死的现 2.因为之前一生拍摄需要拍照和视频录制相互切换，但是他们用的同一个session，只是视频的session中多了音频输入设备，如果直接使用session会造成录制的视频没有声音的问题（原因：因为session初始化的时候里面的视频设备音频设备还是使用的原来的session的。从拍照到录像的时候session中是没有音频设备的，所以需要重新加入音频设备， 注意(重点): 不能直接只加一个音频设备，需要把session中之前的输入输出设备全部移除掉，然后再重新加入新的输入输出音频视频设备，否则session不会生效。）1234567891011121314151617181920212223242526272829session.beginConfiguration()//移除输入if let input = self.getAVCaptureDeviceInput() &#123; let viewLayer = self.captureImage.layer viewLayer.masksToBounds = true let bounds = self.view.bounds self.captureVideoPreviewLayer?.frame = bounds for input in session.inputs &#123; if let input = input as? AVCaptureDeviceInput &#123; session.removeInput(input) &#125;&#125;if session.canAddInput(input) &#123; session.addInput(input)&#125; //移除输出self.stillImageOutput = AVCaptureStillImageOutput()let outputSettings = [AVVideoCodecKey : AVVideoCodecJPEG]self.stillImageOutput?.outputSettings = outputSettingsfor output in session.outputs &#123; if let output = output as? AVCaptureOutput &#123; session.removeOutput(output) &#125;&#125;if session.canAddOutput(stillImageOutput) &#123; session.addOutput(self.stillImageOutput)&#125;session.commitConfiguration() 3.视频拍摄设备方向和播放视频的设备方向是不一致的。所以需要在预览视频和上传后播放视频做视频的方向旋转处理。前置头像头和后置摄像头的处理方向是不一样的。 具体代码如下1234567891011121314151617if FrontCamera &#123; if self.videoFirstOrientation == .landscapeRight&#123; self.playerLayer?.setAffineTransform(CGAffineTransform(rotationAngle: CGFloat(Double.pi*0.5))) &#125;else if self.videoFirstOrientation == . landscapeLeft&#123; self.playerLayer?.setAffineTransform(CGAffineTransform(rotationAngle: CGFloat(Double.pi*1.5))) &#125; else if self.videoFirstOrientation == .portraitUpsideDown&#123; self.playerLayer?.setAffineTransform(CGAffineTransform(rotationAngle: CGFloat(Double.pi ))) &#125;&#125; else &#123; if self.videoFirstOrientation == .landscapeLeft &#123; self.playerLayer?.setAffineTransform(CGAffineTransform(rotationAngle: CGFloat(Double.pi * 1.5))) &#125; else if self.videoFirstOrientation == .landscapeRight &#123; self.playerLayer?.setAffineTransform(CGAffineTransform(rotationAngle: CGFloat(Double.pi / 2))) &#125; else if self.videoFirstOrientation == .portraitUpsideDown &#123; self.playerLayer?.setAffineTransform(CGAffineTransform(rotationAngle: 0)) &#125;&#125; 4.如果后期需要做滤镜或者实时视频滤镜，在DWVideoRecoder 中的123- (void)captureOutput:(AVCaptureOutput *)captureOutput didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection &#123;&#125; 这个方法是拿到当前视频输入设备捕捉的每一帧画面，然后进行对每一帧画面进行处理。这个方法中拿到当前帧的画面然后进行滤镜渲染显示 5.获取沙盒中的视频路径要用 url.path. 不能直接转换为String，否则拿到的地址是不对的。1try? FileManager.default.removeItem(atPath: url.path) 6.视频的压缩主要取决于码率和关键帧率。 123456789101112131415161718192021self.assetWriterVideoInput = (&#123; AVAssetWriterInput *writerInput = [[AVAssetWriterInput alloc] initWithMediaType:AVMediaTypeVideo outputSettings:(&#123; // 录制参数。 根据调节参数实现压缩 @&#123; AVVideoCodecKey : AVVideoCodecH264,//编码方式 AVVideoScalingModeKey : AVVideoScalingModeResizeAspectFill, AVVideoWidthKey : @(960),//视频的宽高 AVVideoHeightKey : @(540), // 压缩参数 ，10 表示清晰度。 AVVideoCompressionPropertiesKey : (&#123; @&#123; AVVideoAverageBitRateKey : @(640 * 320 * 10),//压缩码率 AVVideoMaxKeyFrameIntervalKey : @(10),//清晰度 AVVideoProfileLevelKey : AVVideoProfileLevelH264HighAutoLevel//清晰度等级，枚举类型 &#125;; &#125;) &#125;; &#125;)] &#125;);// yes指明输入应针对实时进行优化writerInput.expectsMediaDataInRealTime = YES; 7.目前没有做多音频视频合成的需求，如果有需求，可以在TakeViedeoController.swift中的mergeAndExportVideos方法中代码就是对多段音频视频合成处理的代码。 录制视频关键流程梳理 1.初始化session，在session中设置音频视频的输入输出设备。在DWVideoRecoder中setupSessionInputs 和 setupSessionOutputs中 2.初始化摄像头，开启session，显示当前摄像头捕捉画面，为了防止按钮在白光下面显示不清晰，在view上加了一层蒙版。 3.开始录制调用DWRecorder中的startRecordWithSwift，然后往沙盒中写入视频数据。 4.结束录制后停止session，显示录制的最后一帧图像。调用session的stopSession方法，并且将.mov的文件转换为mp4格式视频保存到沙盒，然后删除之前的mov文件 5.重新录制视频只需要把页面按钮状态重置，停止session重新开始session。在TakeVideoViewController中直接调用重录方法cancelAction即可重录。 6.播放视频。从沙盒中获取之前录制的mp4文件路径放到当前的player中。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS（Swift）开发——App开发文档]]></title>
    <url>%2F2017%2F08%2F02%2FiOS%EF%BC%88Swift%EF%BC%89%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[你有没有遇到过，突然老板或者老大跟你说，你根据项目或者根据功能写一份开发文档，当时很开心的答应了，后来想想，既然懵了。开发文档是什么鬼？写了这么多年代码都没写过什么开发文档，最多也就只是产品的需求文档，说明文档，代码的注释与规范文档，或者说过苹果的开发文档，因为之前刚好写过一次很简单的，最近公司又开始要写上面开发文档了，而且发现确实很多同学都不会，我在想，我是不是该做点什么……。 前言App开发过程中的文档分为很多种，比如最常见的就是官方的开发文档，这种比较倾向代码和接口，但是你可能还见过或者听过其他文档。 比如，这里根据个人理解整理了几个。 开发文档 需求(原型)文档 需求(说明)文档 技术方案文档 Bug修复文档 注释文档 代码与UI规范文档 性能优化文档 是不是有点晕了，哪有这么多鬼，其实按照之前的习惯，我都是一份开发文档就够了，基本上包含上面的东西，只是看你怎么细分。 开发文档概述实际开发中如果真的遇到要写上面开发文档可以从下面几个角度写。 一. 开发环境及工具 二. 项目或功能（需求）描述（最好有流程图或者UML）- 需求文档 三. 编写目的（用户特征和水平） 四. 项目或功能背景 五. 模块与关系 六. 类或术语说明 七. 参考资料（网络或公司内部资料，UI，原型，说明文档） 八. 项目进度预估 九. 难点预估（条件与限制） 十. 功能与所计划采用的技术 - 技术方案文档 十一. 用户界面与交互 十二. 软件（代码）接口 - 注释文档 十三. 通信（网络）接口 - 接口文档 十四. 问题与修复说明 - Bug修复文档 十五. 性能分析与优化 当然也不是说这些全部要写，可以根据项目或者功能适当编写。 下面大概一个个的说明一些每一个步骤是什么意思，需要怎么写，这里主要以iOS开发中App开发文档为规范，并使用苹果最新的语言Swift作为唯一语言。 一. 开发环境及工具 Mac OX 10 iPhone或者iPad 5+ 2+ 必须真机 iOS 8+ Xcode 8+ 其他工具：Tower，cornerstone 主要指明开发在工具，开发平台，开发版本的支持。描述软件的运行环境，包括硬件平台、硬件要求、操作系统和版本，以及其他的软 件或与其共存的应用程序等。 二. 项目或功能（需求）描述（最好有流程图或者UML）- 需求文档 顶层数据流图； 用例UseCase图； 系统流程图； 层次方框图。 主要根据产品给出的需求结合原型进行描述，并适当给出相应的图。 三. 编写目的（用户特征和水平） 描述最终用户应具有的受教育水平、工作经验及技术专长。 次软件或者功能编写的目的，对项目，对用户，对公司有什么好处。 四. 项目或功能背景 标识待开发软件产品的名称、代码； 列出本项目的任务提出者、项目负责人、系统分析员、系统设计员、程序设计员、程序员、资料员以及与本项目开展工作直接有关的人员和用户； 说明该软件产品与其他有关软件产品的相互关系。 此项目或功能编写之前市面上的情况，公司和用户的情况 五. 模块与关系 项目或功能对应模块在位置，入口，和其他模块的关系 六. 类或术语说明 项目或功能对应类的说明，和开发中使用到的一些相关的术语的说明 七. 参考资料（网络或公司内部资料，UI，原型，说明文档） 列举编写软件需求规格说明时所参考的资料，包括项目经核准的计划任务书、合同、引用的标准和规范、项目开发计划、需求规格说明、使用实例文档，以及相关产品的软件需求规格说明。 在这里应该给出详细的信息，包括标题、作者、版本号、发表日期、出版单位或资料来源。 网络资料，尤其是苹果的，也可以群里或者博客，文章等。公司内部的UI，原型，说明，网络接口资料 八. 项目进度预估 预计从上面开始到指定的时间节点完成任务或者完成对应的部分 九. 难点预估（条件与限制） 其中考虑到或者可能会遇到什么技术或者实现难点 十. 功能与所计划采用的技术 - 技术方案文档 将要采用的图形用户界面标准或产品系列的风格； 屏幕布局； 菜单布局； 输入输出格式； 错误信息显示格式； 建议采用RAD开发工具， 比如Visio，构造用户界面。 根据项目或者功能需求，在代码层面所使用的技术或者实现方案，或者比如说ios中布局方式的使用。 十一. 用户界面与交互 根据用户界面和入口说明交互与使用步骤并 十二. 软件（代码）接口 - 注释文档 每一个方法和属性对应的注释，一般是私有的话使用private但是也要注释，公开的都会使用标准的注释说明，苹果有自带的快捷键（command+option+/），之前有个插件叫VVDocument 十三. 通信（网络）接口 - 接口文档 网络请求对应的说明包括对应的参数，字段和返回值，也可以是数据模型层对应的模型属性和方法的说明 十四. 问题与修复说明 - Bug修复文档 开发或者测试的过程中出现了什么比较重要的bug，不要什么bug都写上，然后说明解决的方案 十五. 性能分析与优化 时间特性 响应时间； 更新处理时间； 数据转换与传输时间； 运行时间等。 适应性 在操作方式、运行环境、与其他软件的接口以及开发计划等发生变化时，软件的适应能力。 到此完成之后，根据实际需求和个人能力，个人理解分析项目或者功能那些地方需要进行优化一下，打算怎么去优化他。 后期会继续完善(根据项目或功能整理一套完整的开发文档)……. 注：这里是按照功能，并不是按照整个项目分，如果要写整个项目的开发文档也可以再根据功能细分。]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>开发文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift开发——实用技巧Literal]]></title>
    <url>%2F2017%2F07%2F31%2FSwift%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7Literal%2F</url>
    <content type="text"><![CDATA[由于之前一直在写OC项目，最近开始真正实用Swift开发与迭代项目，前段时间偶尔看到项目中一段莫名奇妙的代码，就是关于颜色和图片的设置，顿时激起了我的兴趣，即使我从Swift 1.0 到 2.0 再到 3.0 也没有看到过这样的写法，可能是我孤陋寡闻了，于是随便弄了一下，发现还真有趣…… 首先我们来看看本文的主要字眼：Literal Literal：照字面的， 原义的的意思. 个人理解：所见即所得其实理解的这里的含义应该就差不多能猜到我今天要说什么了。 通过官方资料Add a color, file, or image literal我们可以知道：Literal是Xcode8 的新特性，而且不支持 OC，只至少目前只能在Swift中使用。 Color LiteralColor Literal在Swift中我们写颜色都是这样的： let iCocosColor = UIColor(red: 10/255.0, green: 10/255.0, blue: 10/255.0, alpha: 1) 但是如果不 command + R 运行项目的话，我们就不知道这颜色到底长什么样。 那么有了接下Color Literal 之后，就简单多了。直接输入color提示下面的Color Literal，回车就可以，会看到一个默认的白色框， 点击白色框就可以选择任何你想要的颜色了。 同时也可以点击other进行其他多样化颜色的选取。如果把那句代码拷贝出来，其实是这样的： let iCocosColor = #colorLiteral(red: 1, green: 0.04969102033, blue: 0, alpha: 1) Image LiteralImage Literal而图片的定义或者设置我们一般会这么做。 let iCocosImage = UIImage(named: &quot;iCocos&quot;) 同样如果我们不command + R运行项目的话，也没办法知道是否正确，而且如果我把 name 写错，图片就不会显示了。 那么有了接下Image Literal 之后，就简单多了。直接输入iamge提示下面的Image Literal，回车就可以，会看到一个默认的图标， 点击图标就可以选择任何你想要的图片了。 如果把那句代码拷贝出来，其实是这样的： let iCocosImage = #imageLiteral(resourceName: &quot;circleItemMore&quot;) 到这里基本上就结束了，相信你会爱上这个特性。 是不是很牛逼，我当时没有查资料和文档的情况下，硬是没有看懂。]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>实用技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift篇——ARC中循环引用问题]]></title>
    <url>%2F2017%2F07%2F22%2FSwift%E7%AF%87%E2%80%94%E2%80%94ARC%E4%B8%AD%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[如果你有过实际iOS开发经验，尤其是OC时代的，那么你一定遇到过这样的一个问题，那就是循环应用，于是就有了各种文文章，各种解决方式实现这样的问题，但是这种情况到了Swift里面依然没有办法避免的，只是Swift里面似乎考虑到了OC中欠缺的地方，同时也为了我们能更好的处理这样的问题，给出了对应的方案…… 一、几个用到的关键概念弱引用(weak)：不会增加自动引用计数，必须为可选类型变量，因为弱引用在引用计数为0的时候，会自动赋为nil。在swfit中，可以赋值为nil的为可选类型 无主引用(unonwed)：不会增加自动引用计数，必须为非可选类型。在ARC销毁内存后，不会被赋为nil，所以在访问无主引用的时候，要确保其引用正确，不然会引起内存崩溃。 隐式解析可选类型：在初始的时候可以为nil，但是第一次赋值以后便会一直有值。语法是在变量后面加上感叹号(例如var name:String!)。使用该类型只需要正常调用，不需要像可选类型那样做判断。 二、类实例之间的循环引用1、实例A可选包含实例B的引用，实例B可选包含实例A的引用-用弱引用来解决公寓不一定有住户，住户也不一定在公寓里 class Person { let name: String init(name: String) { self.name = name } var apartment: Apartment? deinit { println(&quot;\(name) is being deinitialized&quot;) } } class Apartment { let number: Int init(number: Int) { self.number = number } weak var tenant: Person? deinit { println(&quot;Apartment #\(number) is being deinitialized&quot;) } } var john: Person? var number73: Apartment? john = Person(name: &quot;John Appleseed&quot;) number73 = Apartment(number: 73) john!.apartment = number73 number73!.tenant = john 2、实例A可选包含实例B，实例B一定包含实例A-用无主引用解决用户可能没有信用卡，但是信用卡一定会有用户。由于信用卡一定有用户，所以不是可选类型，不能用弱引用，swift中提供的无主引用是简单便捷的解决方案。 class Customer { let name: String var card: CreditCard? init(name: String) { self.name = name } deinit { println(&quot;\(name) is being deinitialized&quot;) } } class CreditCard { let number: Int unowned let customer: Customer init(number: Int, customer: Customer) { self.number = number self.customer = customer } deinit { println(&quot;Card #\(number) is being deinitialized&quot;) } } var john: Customer? john = Customer(name: &quot;John Appleseed&quot;) john!.card = CreditCard(number: 1234_5678_9012_3456, customer: john!) 3、A一定包含B，B一定包含A - 用隐式解析+无主引用解决国家一定包含首都，首都也一定在一个国家里 class Country { let name: String let capitalCity: City! init(name: String, capitalName: String) { self.name = name self.capitalCity = City(name: capitalName, country: self) } } class City { let name: String unowned let country: Country init(name: String, country: Country) { self.name = name self.country = country } }]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>ARC中循环引用问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift篇——可选类型总结]]></title>
    <url>%2F2017%2F07%2F18%2FSwift%E7%AF%87%E2%80%94%E2%80%94%E5%8F%AF%E9%80%89%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[在Swift中，可选类型其根源是一个枚举型，里面有None和Some两种类型。其实所谓的nil就是Optional.None, 非nil就是Optional.Some, 然后会通过Some(T)包装（wrap）原始值，这也是为什么在使用Optional的时候要拆包（从enum里取出来原始值）的原因, 也是PlayGround会把Optional值显示为类似{Some “hello world”}的原因，…… 首先我们先看下Objective-C与Swift语言对于可选nil的不同理解: Objective-C中的nil:表示缺少一个合法的对象，是指向不存在对象的指针，对结构体、枚举等类型不起作用(会返回NSNotFound) Swift中的nil:表示任意类型的值缺失，是一个确定的值，要么是该类型的一个值要么什么都没有(即为nil) 一、申明可选常量或变量let status: Int? = 1 // 申明可选Int类型的常量,初始值为1 var defaultAddress: String? = &quot;江苏南京&quot; // 申明可选String类型的变量,初始值为&quot;江苏南京&quot; var student: Person? // 申明可选Person(自定义的类)的变量，初始值为nil 注意：Int?与Int不相同，Int?表示可选的Int类型，可以赋值为nil，而Int不可以赋值为nil 二、使用”!”强制解析获取可选类型的值(不建议直接使用)var defaultAddress: String? = &quot;江苏南京&quot; if defaultAddress != nil { // !=或==可以用来判断是否为nil print(&quot;您的地址是\(defaultAddress!)&quot;) // 使用!强制解析 } else { print(&quot;对不起，您不存在地址信息&quot;) } var student: Person? print(&quot;学生为\(student!)&quot;) // XCode会提示运行错误，因为student初始值为nil，强制解析不行 三、使用可选绑定获取可选类型的值(建议的用法)var defaultAddress: String? = &quot;江苏南京&quot; if let address = defaultAddress { // 如果defaultAddress有值或类型转换成功，则将值赋值给address直接使用 print(&quot;您的地址是\(address)&quot;) // 使用address代替defaultAddress，且不需要加!强制解析 } else { print(&quot;对不起，您不存在地址信息&quot;) } 四、隐式解析可选类型(用于申明时肯定有初始值，但后面可能为nil)var mobileNumber: Int64! = 13912345678 // 第一次申明有初始值 print(&quot;您的电话号码是\(mobileNumber)&quot;) // 不需要使用!强制解析 // 打印内容:**您的电话号码是****Optional(13912345678)** // 还是不建议直接强制解析，因为实际项目中可能中间已经对该值做了改变，若为nil则会运行错误导致APP崩溃 if let number = mobileNumber { // 建议的做法 print(&quot;您的电话号码是\(number)&quot;) // 打印内容:**您的电话号码是****13912345678** } else { print(&quot;您没有记录电话号码&quot;) } 五、空合运算符(用于判断变量或常量是否为nil)// 空合运算符：a ?? b 判断a是否为nil，若a不为nil对a解封，否则返回b的值 var status: Int? // 申明可选Int类型的变量status，初始值为nil status ?? 0 // 因为status为nil，则返回0 // ?? 即为以下if else的缩写 func testOption() -&gt; Int { let status: Int? = 1 if status == nil { return 0 } else { return status! } } 六、函数/方法返回类型为可选类型A:返回值为可选类型的值(如Int?、String?、(Int, String)?、[Int]?、[Int: String]?等) func returnPossibleValue(value: Bool) -&gt; String? { // 返回类型为可选String类型 if value { return &quot;返回类型是可选类型值&quot; // 如果为真，返回Int类型的值1 } else { return nil // 如果为假，返回nil } } let possibleValue = returnPossibleValue(value: true) // 要用可选绑定判断再使用，因为possibleValue为String？可选类型 if let value = possibleValue { print(value) } else { print(&quot;none value&quot;) } B:返回值为可选类型的类(如URL?、自定义Person?等) class SomeClass { var someValue: Int init?(someValue: Int) { // 可失败构造器 if someValue == 1 { return nil } self.someValue = someValue } } func returnPossibleClass(value: Bool) -&gt; SomeClass? { // 返回的类实例可能为nil if value { return SomeClass(someValue: 1) // 返回的为nil } else { return SomeClass(someValue: 2) // 返回的SomeClass?实例，不为nil } } C:返回值为可选类型的闭包(如(()-&gt; (void))? ) func returnOptionalFunc(value: Bool) -&gt; (() -&gt; (Void))? { // 返回类型为可选类型的闭包 if value { return { () in print(&quot;返回类型是可选类型闭包&quot;) } } else { return nil } } let possibleFunc = returnOptionalFunc(value: true) // 要用可选绑定判断再使用，因为possibleFunc 为可选类型的闭包，类型为() -&gt; (Void) if let aFunc = possibleFunc { print(aFunc()) // 注意增加()调用闭包，因为没有参数则是空括号 } else { print(&quot;none func&quot;) } 七、可选类型在类或结构体中的运用A:可选类型在类中的运用 class PossibleClass { var someValue: Int var possibleValue: String? // 可选存储属性，默认值为nil init(someValue: Int) { // 构造方法中可以不对possibleValue属性初始化 self.someValue = someValue } } let someClass = PossibleClass(someValue: 4) // 实例化对象时不需要对possibleValue初始化，someClass实例中：someValue为4，possibleValue为nil 注意：类中所有属性都需要有默认值。属性可以在申明时赋予初始值，也可以在构造方法中赋予初始值；子类继承父类时，必须先给自身属性先初始化后再继承父类构造方法初始化。一般的，出于安全的因素，子类的属性都赋予初始值或直接定义为可选类型。 B:可选类型在结构体中的运用 struct PossibleStruct { var someValue: Int var possibleValue: String? // 可选存储属性，默认值为nil // 结构体中可以自定义一个init构造器对属性初始化，也可以不自定义 } let someStruct = PossibleStruct(someValue: 4, possibleValue: nil) 调用默认的逐一构造器 说明：从上图可看出实例化,PossibleStruct会调用默认逐一构造器，其中possibleValue可传String类型的值或nil 八、可选类型在构造器中的运用 概念：可失败构造器是 一个类、结构体或枚举类型的对象，在构造过程中有可能失败；这里所指的“失败”是指，如给构造器传入无效的参数值，或缺少某种所需的外部资源，又或是不满足某种必要的条件等。 A:结构体的可失败构造器 struct PossibleStructInit { let someValue: String init?(someValue: String) { // 可失败构造器 if someValue.isEmpty { return nil } // 如果实例化为空串，则返回nil(即实例化失败) self.someValue = someValue } } let oneStruct = PossibleStructInit(someValue: &quot;abc&quot;) // abc不是空串，oneStruct为PossibleStructInit？可选类型 if let one = oneStruct { // 使用if let可选绑定判断 print(one.someValue) } else { print(&quot;none value&quot;) } // 结果打印 abc let twoStruct = PossibleStructInit(someValue: &quot;&quot;) // 传参为空串 if let two = twoStruct { print(two.someValue) } else { print(&quot;none value&quot;) } // 结果打印 none value B:枚举的可失败构造器 enum PossibleEnmuInit { case East, West, South, North // 不带原始值，带原始值也可以使用可失败构造器 init?(director: Character) { switch director { case &quot;E&quot;: self = .East case &quot;W&quot;: self = .West case &quot;S&quot;: self = .South case &quot;N&quot;: self = .North default: return nil // 如果实例化时不是E/W/S/N字符，则返回nil(即实例化失败) } } } let oneEnmu = PossibleEnmuInit(director: &quot;E&quot;) // 传值E，返回PossibleEnmuInit?可选类型 if let one = oneEnmu { // 使用可选绑定判断 print(one) } else { print(&quot;none value&quot;) } // 结果打印 East let twoEnmu = PossibleEnmuInit(director: &quot;A&quot;) // 传值A，返回PossibleEnmuInit?可选类型 if let two = twoEnmu { // 使用可选绑定判断 print(two) } else { print(&quot;none value&quot;) } // 结果打印 none value C:类的可失败构造器 class Product { let name: String init?(name: String) { if name.isEmpty { return nil } self.name = name } } class CartItem: Product { let quantity: Int init?(name: String, quantity: Int) { if quantity &lt; 1 { return nil } // 实例化时如果quantity小于1，则立即终止构造过程 self.quantity = quantity super.init(name: name) // 如果name为空串，则立即终止构造过程 } } if let twoSocks = CartItem(name: &quot;sock&quot;, quantity: 2) { print(&quot;Item: \(twoSocks.name), quantity: \(twoSocks.quantity)&quot;) } // 打印 &quot;Item: sock, quantity: 2” if let zeroShirts = CartItem(name: &quot;shirt&quot;, quantity: 0) { print(&quot;Item: \(zeroShirts.name), quantity: \(zeroShirts.quantity)&quot;) } else { print(&quot;Unable to initialize zero shirts&quot;) } // 打印 &quot;Unable to initialize zero shirts” 九、可选类型在可选链中的运用概念：可选链为一种可以在当前值可能为nil的可选值上请求和调用属性、方法及下标的方法。如果可选值有值，那么调用就会成功；如果可选值是nil，那么调用将返回nil。多个调用可以连接在一起形成一个调用链，如果其中任何一个节点为nil，整个调用链都会失败，即返回nil。 class Person { var name: String var room: Room? // 不是每个人都买房，定义为可选类型 init(name: String) { self.name = name } } class Room { var roomAddr: String var roomArea: Int init(roomAddr: String, roomArea: Int) { self.roomAddr = roomAddr self.roomArea = roomArea } } let xiaoming = Person(name: &quot;xiaoming&quot;) // 此时xiaoming实例中属性：name为&quot;xiaoming&quot;,room为nil if let address = xiaoming.room?.roomAddr, let area = xiaoming.room?.roomArea { // 使用?可选链式调用，如果含有值则返回该值(不需要手动强制解析),如果没有值则返回nil print(&quot;\(xiaoming.name)的房子地址在:\(address), 面积:\(area)&quot;) } else { print(&quot;\(xiaoming.name)没有房子&quot;) } // 打印：xiaoming没有房子 xiaoming.room = Room(roomAddr: &quot;南京雨花台区&quot;, roomArea: 95) // 定义xiaoming实例的room属性 // 再次调用以上可选绑定，打印 xiaoming的房子地址在:南京雨花台区, 面积:95 十、可选类型在错误处理中的运用概念：错误处理即为响应错误一级从错误中恢复的过程 A:一般的错误处理写法（一般使用于需要对不同的返回结果较为清晰的捕捉并做相应的处理） // 操作错误处理枚举 enum OperationError: Error { case ErrorOne case ErrorTwo(String) // 带关联值的枚举属性 case ErrorOthers } // 错误处理抛出 func throwDriver(num: Int) throws { if num == 1 { throw OperationError.ErrorOne } else if num == 2 { throw OperationError.ErrorTwo(&quot;数据类型错误&quot;) } else { throw OperationError.ErrorOthers } } do { print(&quot;使用do-catch捕获错误&quot;) try throwDriver(num: 2) // 使用try尝试请求 print(&quot;未捕获到错误&quot;) } catch OperationError.ErrorOne { // catch去捕捉是否又throw出来的错误 print(&quot;捕捉到错误：ErrorOne&quot;) } catch OperationError.ErrorTwo(let message) { // 可以使用let 获取枚举关联值 print(&quot;捕捉到错误：ErrorTwo&quot; + message) } catch OperationError.ErrorOthers { print(&quot;捕捉到错误：ErrorOthers&quot;) } // 打印结果如下： // 使用do-catch捕获错误 // 捕捉到错误：ErrorTwo数据类型错误 B:错误处理(try!)（不建议使用，可能会导致App崩溃） let photo = try! loadImage(atPath: &quot;./Resources/John Appleseed.jpg&quot;) // 上述语句中在执行loadImage方法时如果执行失败，使用try!来禁用错误传递，会有运行错误导致App崩溃 C:错误处理(try?)（一般使用于不需要对错误进行过多的处理） func someThrowingFunction() throws -&gt; Int { // ... } let x = try? someThrowingFunction() // x可能正常返回一个Int类型的值也有可能抛出一个错误异常，使用时对x用if let可选绑定判断 十一、可选类型在类型转换中的运用类型转换在向上转型时一般不会出现失败，例如从子类向父类转型，直接用as即可类型转换在向下转型时可能会出现失败，例如从父类向子类转型，要使用as?转型，使用时需要可选绑定后再用 使用as?类型转换值得注意的是：从Any转成Int为向下转型，Swift从安全因素考虑，会直接返回nil，所以在日常项目中若遇到从父类向子类转型时，一定要使用可选绑定，如以下代码： class SuperClass { // 这是一个父类 } class SubClass: SuperClass { // 这是一个子类 } let superClass = SuperClass() if let someClass = superClass as? SubClass { // 如果转换成功，则用someClass使用即可 } else { // 转换失败 } 其他、调用公共库时注意API的返回值 返回值类型 var score: [String: Int] = [&quot;语文&quot;: 87, &quot;数学&quot;: 99, &quot;英语&quot;: 61] let removedValue = score.removeValue(forKey: &quot;物理&quot;) // 返回nil 注意：从以上代码中可看出，removeValue方法会返回被删除key对应的Value值，发现不存在key为“物理”，即返回nil(removedValue常量值)]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>可选类型总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift——类&结构体&枚举总结]]></title>
    <url>%2F2017%2F07%2F15%2FSwift%E2%80%94%E2%80%94%E7%B1%BB-%E7%BB%93%E6%9E%84%E4%BD%93-%E6%9E%9A%E4%B8%BE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[OC中也有类，结构体，枚举。但是 到了Swift中，我发现实际的应该却远远超过OC，而且强大之处之后我们真正用了才知道，那么他们之间到底有什么区别呢？ 即枚举类型、结构类型（包括基本类型，基本类型实际都是结构类型的特例）、类。 类型区别 类是引用类型 引用类型(reference types，通常是类)被复制的时候其实复制的是一份引用，两份引用指向同一个对象。所以在修改一个实例的数据时副本的数据也被修改了(s1、s2)。 枚举，结构体是值类型 值类型(value types)的每一个实例都有一份属于自己的数据，在复制时修改一个实例的数据并不影响副本的数据(p1、p2)。值类型和引用类型是这三兄弟最本质的区别。 mutating值类型的属性不能在实例方法中被修改，但是有时候你确实想修改过，这时候 你可以使用变异方法 。关键字 mutating 总结枚举、结构体、类的共同点：定义属性和方法； 下标语法访问值； 初始化器； 支持扩展增加功能； 可以遵循协议； 类特有的功能：继承； 允许类型转换； 析构方法释放资源； 引用计数； 我该如何选择关于在新建一个类型时如何选择到底是使用值类型还是引用类型的问题其实在理解了两者之间的区别后是非常简单的，在这苹果官方已经做出了非常明确的指示（以下内容引自苹果官方文档）： 当你使用Cocoa框架的时候，很多API都要通过NSObject的子类使用，所以这时候必须要用到引用类型class。在其他情况下，有下面几个准则： 1.什么时候该用值类型：要用==运算符来比较实例的数据时 你希望那个实例的拷贝能保持独立的状态时 数据会被多个线程使用时 2.什么时候该用引用类型（class）：要用==运算符来比较实例身份的时候 你希望有创建一个共享的、可变对象的时候]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>类&amp;结构体&amp;枚举总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC&&Swift——方法调用技巧]]></title>
    <url>%2F2017%2F07%2F13%2FOC-Swift%E2%80%94%E2%80%94%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[在现在这个iOS行业，如果你还只会OC的话，可能你是一个老手，而且是一个不喜欢学习的老手，如果你只会Swift的话，那么那么可能很多底层的东西没有办法去挖掘，尤其是一个篇全局和理论的东西，所以如果你是一个iOS程序员，那么OC和Swift是必会的，只是看你比较偏向于那一块。很多项目中都能看到两者的身影，这个时候你就不得不学习怎么去混编或者交互…….. 1、OC调用Swift实例方法例如在ViewController.m类里调用Swift的logMe实例方法，就可以这么写： SwiftDemo* demo = [[SwiftDemo alloc] init]; [demo logMe]; 2、OC调用Swift静态方法首先先在SwiftDemo.swift文件中声明一个静态方法： public static func swiftStaticFunc(log: NSString) { print(log); } 然后回到ViewController.m类里调用该方法（记得编译一下才可以）同样、调用方式和OC之间的调用类似： [SwiftDemo swiftStaticFunc:@&quot;oc call swift static func&quot;]; 3、Swift调用OC实例方法在SwiftDemo.swift类里调用ViewController.m类里的logYou方法，swift调用代码如下： let vc = ViewController() vc.logYou() 声明一个变量vc，也就是ViewController的实例对象。然后用vc对象调用实例方法logYou。。 4、Swift调用OC静态方法首先先在ViewController.h中声明一个OC的静态方法： + (void) ocStaticFunc:(NSString*)log; 然后在.m文件中简单些一下实现： + (void)ocStaticFunc:(NSString *)log { NSLog(@&quot;%@&quot;, log); } 回到SwiftDemo.swift文件中，用swift调用OC的静态方法。 ViewController.ocStaticFunc(&quot;swift call oc static fun&quot;) 5、Swift调用OC多参方法首先先在ViewController.h中声明一个OC的多参方法： - (void) logMe:(NSString*)logMe logYou:(NSString*)logYou; 在.m文件中进行一下实现： - (void)logMe:(NSString *)logMe logYou:(NSString *)logYou { NSLog(@&quot;%@--%@&quot;, logMe, logYou); } 在SwiftDemo.swift文件中调用方法如下： vc.logMe(&quot;log me&quot;, logYou: &quot;log you&quot;) 方法从第一个参数开始都要写在括号里]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>方法调用技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift——不为人知的淫技]]></title>
    <url>%2F2017%2F07%2F08%2FSwift%E2%80%94%E2%80%94%E4%B8%8D%E4%B8%BA%E4%BA%BA%E7%9F%A5%E7%9A%84%E6%B7%AB%E6%8A%80%2F</url>
    <content type="text"><![CDATA[过去总是遇到一些看不太懂的代码，或者是一些开源的源码，或者是看到别人写代码，看起来好有逼格，有些因为好奇也就网上搜了一下，发现既然有这么一系列的东西我们虽然有用到，或者有看到，但是根本没有去了解他是什么？有什么用？或者苹果为什么要给个这样的特性？ @dynamicdynamic 可以让类里面的函数使用消息机制派发. 使用 dynamic, 必须导入 Foundation 框架, 里面包括了 NSObject 和 Objective-C 的运行时. dynamic 可以让声明在 extension 里面的函数能够被 override. dynamic 可以用在所有 NSObject 的子类和 Swift 的原声类. @objc使用 @objc 的典型例子就是给 selector 一个命名空间 @objc(abc_methodName), 让这个函数可以被 Objective-C 的运行时调用. @nonobjc 会改变派发的方式, 可以用来禁止消息机制派发这个函数, 不让这个函数注册到 Objective-C 的运行时里. 总结@objc 和 @nonobjc 显式地声明了一个函数是否能被 Objective-C 的运行时捕获到. @objc是用来将Swift的API导出给Objective-C和Objective-C runtime使用的，如果你的类继承自Objective-c的类（如NSObject）将会自动被编译器插入@objc标识。 加了@objc标识的方法、属性无法保证都会被运行时调用，因为Swift会做静态优化。要想完全被动态调用，必须使用dynamic修饰。使用dynamic修饰将会隐式的加上@objc标识。 @inline这个特性为编译器提供了内联提示。可以理解为告诉编译器可以使用直接派发. @asmname该属性给出了函数、方法或属性实现的符号名称。如果已经知道对应的函数参数及其类型，那么就可以直接调用Swift的内部标准库函数，甚至不用头文件，也可以方便地调用C语言编写的函数：@asmname(“function”) func f() @semantics这又是另一个谜。参数看起来像是array.mutate_unknown或array.init这样的字符串数组。想必这是要告诉编译器（或静态分析器）函数是如何工作的。 @unsafe_no_objc_tagged_pointer上面这个仍然是个谜，但据猜测，它是在告诉Swift与objective-C联系的时候不要使用tagged pointer。 对象在内存中是对齐的，它们的地址总是指针大小的整数倍，通常为16的倍数。对象指针是一个64位的整数，而为了对齐，一些位将永远是零。 Tagged Pointer利用了这一现状，它使对象指针中非零位有了特殊的含义。在苹果的64位Objective-C实现中，若对象指针的最低有效位为1(即奇数)，则该指针为Tagged Pointer。这种指针不通过解引用isa来获取其所属类，而是通过接下来三位的一个类表的索引。该索引是用来查找所属类是采用Tagged Pointer的哪个类。剩下的60位则留给类来使用。 @availability这个特性可以用来标识某些函数只在某些平台或版本上可用。第一个参数是平台，可以用星号（＊）代表一切可用，还可以是iOS或OS X。因为如果需要针对不同的平台，就要指定多个@availability属性。 @available放在函数（方法），类或者协议前面。 @available(iOS 9, *) func myMethod() { // do something } #available用在条件语句代码块中，判断不同的平台下，做不同的逻辑处理， if #available(iOS 8, *) { // iOS 8 及其以上系统运行 } 总结 网上有这么一段话：@available是编译期间判断的，而#available是运行时行为。 @transparent该特性会导致编译器在管道（pipeline）中更早地将函数内联。它用于“像+(Int, Int)这样非常原始的函数”，而“不应该用于独立函数”。甚至在没有优化设置的调试模式下，@transparent特性函数就会被内联，所以在调用“1+1”这样的函数时候并不会特别慢，另外这个特性与@inline（__always）非常类似。 @warn_unused_result在Swift 2.x的时候，带返回的方法我们如果在调用的时候后面使用到返回的参数，编译器不会有任何的警告，想要编译器给出警告的话需要自己在方法前面添加属性 @warn_unused_result , 如 @warn_unused_result func doSomething() -&gt; Bool { return true } 这个关键字的含义：如果某个函数使用了这个关键字，那么函数在被调用的时候，要检查或者使用返回值，某则编译器会进行警告。使用场合：在把一些功能封装起来（或者SDK的编写）时候，如果对返回值的使用比较重要，那么使用这个关键字提醒编译器要检查返回值是否被利用。 这时候调用这个方法没有使用返回参数的情况下编译器就会给出警告： Result of call to ‘doSomething()’ is unused @discardableResult Swift 3.0 的时候@warn_unused_result已经不需要了，默认情况下编译器就是会去检查返回参数是否有被使用，没有的话就会给出警告。如果你不想要这个警告，可以自己手动加上 @discardableResult ，如： @discardableResult func doSomething() -&gt; Bool { return true } 这样一来一切又恢复正常了。 @warn_unqualified_accessextension SortedArray { /// 返回集合里的最小值 /// /// - Complexity: O(1). @warn_unqualified_access public func min() -&gt; Element? { return first } /// 返回集合里的最大值 /// /// - Complexity: O(1). @warn_unqualified_access public func max() -&gt; Element? { return last } } 当你在类型的内部实现中调用这些函数，却没有显式地写明 self. 的前缀时，@warn_unqualified_access 会告诉编译器抛出一个警告。这样可以帮助你避免混淆了这些函数与全局函数 min(::) 和 max(::) 。 @convention@convention 特性是在 Swift 2.0 中引入的，用于修饰函数类型，它指出了函数调用的约定。用在以下几个地方： 修饰 Swift 中的函数类型，调用 C 的函数时候，可以传入修饰过 @convention(c) 的函数类型，匹配 C 函数参数中的函数指针。修饰 Swift 中的函数类型，调用 Objective-C 的方法时候，可以传入修饰过 @convention(block) 的函数类型，匹配 Objective-C 方法参数中的 block 参数。 拓展__attribute__((constructor)) //确保此函数在 在main函数被调用之前调用__attribute__((destructor)) // 确保此函数在 在main函数被调用之后调__attribute__((cleanup())) 用于修饰一个变量，在它的作用域结束时可以自动执行一个指定的方法后期如果有遇到或者发现其他更多相关的我也会随时更新，如果你有遇到不错的也可以联系我，我们一起交流讨论…….]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>不为人知的淫技</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift——动态&静态分析与实战]]></title>
    <url>%2F2017%2F07%2F04%2FSwift%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81-%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[我们知道在OC里面有一个非常牛逼的特性，那就是动态性，也就是说很多东西都被推到了运行时，包括我们所理解的消息机制和转发机制。但是据我了解OC貌似是没有动态类型的，因为他是一门静态类型的语言，他对多就是支持一些和OC动态的交互，但是Swift在通过某些手段还是可以实现对消息的动态转发的…… Swift是一门静态类型的语言，不支持类似OC中的消息机制和转发机制以及其他一些动态的特性，但是你可以通过某些手段实现这一点。 新的Swift编译器更智能，能够识别对象和方法的调用关系以及层级关系，减少对象调用方法的查找时间；同时在内存管理上也有所提高。大部分的方法调用，尤其是重复的方法调用，并没有必要次次都从头开始进行查找，消息分发、转发。Swift一定程度上减少了这种重复的劳动。 Swift是OO（面向对象）的语言，所以少不了方法和属性的重载等特性，程序只能在运行时来确定具体的方法或属性来间接调用或间接访问，这就叫做动态派发。从性能上考虑，对于动态派发的方法，会有常量时间的运行时开销。 函数的派发方式： 程序判断使用哪种途径去调用一个函数的机制. 直接派发(Direct Dispatch) 函数表派发(Table Dispatch) 消息机制派发(Message Dispatch) 大多数语言都会支持一到两种, Java 默认使用函数表派发, 但你可以通过 final 修饰符修改成直接派发. C++ 默认使用直接派发, 但可以通过加上 virtual 修饰符来改成函数表派发. Objective-C 则总是使用消息机制派发, 但允许开发者使用 C 直接派发来获取性能的提高. 直接派发 (Direct Dispatch)直接派发是最快的, 不止是因为需要调用的指令集会更少, 并且编译器还能够有很大的优化空间, 例如函数内联等, 但这不在这篇博客的讨论范围. 直接派发也有人称为静态调用.因为缺乏动态性所以没办法支持继承. 函数表派发 (Table Dispatch )函数表派发是编译型语言实现动态行为最常见的实现方式. 函数表使用了一个数组来存储类声明的每一个函数的指针. 大部分语言把这个称为 “virtual table”(虚函数表), Swift 里称为 “witness table”. 每一个类都会维护一个函数表, 里面记录着类所有的函数, 如果父类函数被 override 的话, 表里面只会保存被 override 之后的函数. 一个子类新添加的函数, 都会被插入到这个数组的最后. 运行时会根据这一个表去决定实际要被调用的函数. 这种派发方式比起直接派发还是慢一点. 从字节码角度来看, 多了两次读和一次跳转,另一个慢的原因在于编译器可能会由于函数内执行的任务导致无法优化 这种基于数组的实现, 缺陷在于函数表无法拓展. 子类会在虚数函数表的最后插入新的函数, 没有位置可以让 extension 安全地插入函数. 消息机制派发 (Message Dispatch )消息机制是调用函数最动态的方式. 也是 Cocoa 的基石, 这样的机制催生了 KVO, UIAppearence 和 CoreData 等功能. 这种运作方式的关键在于开发者可以在运行时改变函数的行为. 不止可以通过 swizzling 来改变, 甚至可以用 isa-swizzling 修改对象的继承关系, 可以在面向对象的基础上实现自定义派发. Swift中的派发方式开发中遇到比较多的坑 Class中的mainMethod 会使用函数表派发, extension中的extensionMethod 则会使用直接派发. 总结起来有这么几点: 值类型总是会使用直接派发, 简单易懂 而协议和类的 extension 都会使用直接派发 NSObject 的 extension 会使用消息机制进行派发 NSObject 声明作用域里的函数都会使用函数表进行派发. 协议里声明的, 并且带有默认实现的函数会使用函数表进行派发 当然上面说到的也不知道必然的，比较OC这么多年的历史，而且动态特性在某些方面还是有着实际的好处，所以苹果也考虑到了这一点，使用某些手段我们可以指定派发方式 指定派发方式 (Specifying Dispatch Behavior)final final 允许类里面的函数使用直接派发. 这个修饰符会让函数失去动态性. 任何函数都可以使用这个修饰符, 就算是 extension 里本来就是直接派发的函数. 这也会让 Objective-C 的运行时获取不到这个函数, 不会生成相应的 selector. dynamic dynamic 可以让类里面的函数使用消息机制派发. 使用 dynamic, 必须导入 Foundation 框架, 里面包括了 NSObject 和 Objective-C 的运行时. dynamic 可以让声明在 extension 里面的函数能够被 override. dynamic 可以用在所有 NSObject 的子类和 Swift 的原声类. @objc &amp; @nonobjc @objc 和 @nonobjc 显式地声明了一个函数是否能被 Objective-C 的运行时捕获到. 使用 @objc 的典型例子就是给 selector 一个命名空间 @objc(abc_methodName), 让这个函数可以被 Objective-C 的运行时调用. @nonobjc 会改变派发的方式, 可以用来禁止消息机制派发这个函数, 不让这个函数注册到 Objective-C 的运行时里. final @objc 可以在标记为 final 的同时, 也使用 @objc 来让函数可以使用消息机制派发. 这么做的结果就是, 调用函数的时候会使用直接派发, 但也会在 Objective-C 的运行时里注册响应的 selector. 函数可以响应 perform(selector:) 以及别的 Objective-C 特性, 但在直接调用时又可以有直接派发的性能. @inline Swift 也支持 @inline, 告诉编译器可以使用直接派发. 有趣的是, dynamic @inline(__always) func dynamicOrDirect() {} 也可以通过编译! 但这也只是告诉了编译器而已, 实际上这个函数还是会使用消息机制派发. 这样的写法看起来像是一个未定义的行为, 应该避免这么做. 在使用Swift重写之前项目中AppDelegate的时候遇到了一个这样的问题（本文也是由这个问题的产生牵引我学习Swift动态相关内容的） Argument of ‘#selector’ refers to a method that is not exposed to Objective-C (Objective-C 无法获取 #selector 指定的函数). 你如果记得 Swift 会把这个函数优化为直接派发的话, 就能理解这件事情了. 这里修复的方式很简单: 加上@objc 或者 dynamic 就可以保证 Objective-C 的运行时可以获取到函数了. 这种类型的错误也会发生在UIAppearance 上, 依赖于 proxy 和 NSInvocation 的代码. 性能上的提升那么在实际项目中我们应该如何使用Swift结合动态和静态方式提高项目的性能呢？在Swift中，动态调用是通过在一个方法表中找到方法然后执行间接的调用（类似于C++的虚函数表），对于这种先查找再调用的过程，其效率是要低于方法的直接调用，而且间接调用会阻止许多编译器优化，这将加重间接调用的开销。接下来将列举一些技巧来禁用动态派发的行为，以达到提升性能的目的。 当属性、方法、或类不需要被重载时，可在其声明的地方加上final关键字在属性，方法或类声明时加上final关键字，表示其不能被重载，这将允许编译器安全的移除动态派发。如下代码所示，point和velocity将直接从对象的存储属性中加载，updatePoint()方法将被直接调用；另外，update()依然会通过动态派发的方式来调用，这样，ParticleModel的子类就可以重载update()来自定义实现。 class ParticleModel { final var point = ( x: 0.0, y: 0.0 ) final var velocity = 100.0 final func updatePoint(newPoint: (Double, Double), newVelocity: Double) { point = newPoint velocity = newVelocity } func update(newP: (Double, Double), newV: Double) { updatePoint(newP, newVelocity: newV) } } 除了上面所示，在属性和方法声明前加final关键字，还可以直接在类上加final，表示该类将不能作为父类被子类化，隐含的表明该类的所有的方法和属性都是final的。 final class ParticleModel { var point = ( x: 0.0, y: 0.0 ) var velocity = 100.0 // ... } 在属性、方法、或类声明前加private关键字，将限制其只能在同一个文件中被引用在声明前加private关键字，将限制其只能在当前文件中被引用，这将允许编译器在当前文件中找到所有潜在的重载声明，编译器会对这些private关键字的方法或属性进行优化，移除间接的方法调用以及属性访问。 假设在当前文件中没有类重载ParticleModel，那么编译器将移除所有带有private声明的动态派发调用。 class ParticleModel { private var point = ( x: 0.0, y: 0.0 ) private var velocity = 100.0 private func updatePoint(newPoint: (Double, Double), newVelocity: Double) { point = newPoint velocity = newVelocity } func update(newP: (Double, Double), newV: Double) { updatePoint(newP, newVelocity: newV) } } 如上代码所示，point和velocity将直接访问，updatePoint()方法也将直接被调用，而update()方法由于没有加private关键字，依然是只能间接调用。同样，private可以加在类的声明前，等同于类的所有方法和属性都将加上private关键字。 private class ParticleModel { var point = ( x: 0.0, y: 0.0 ) var velocity = 100.0 // ... } 在使用internal的声明中通过使用Whole Module Optimization来隐式的推断出final默认的情况下，Xcode将单独编译源文件，这会限制编译器优化的程度，Xcode 7后，增加了Whole Module Optimization选项，它能允许编译器在同一个模块（Module）中分析所有的源文件来进行优化，可以在Xcode的Building Settings中开启该选项，如下图所示。 在开启Whole Module Optimization选项，且声明为internal(默认级别)的情况下，模块的所有文件将同时被编译，这将允许编译器对整个模块一起分析，并对没有被重载且声明为internal级别的类、方法或属性添加final关键字。如下代码所示，我们修改一下ParticleModel类，添加public关键字： public class ParticleModel { var point = ( x: 0.0, y: 0.0 ) var velocity = 100.0 func updatePoint(newPoint: (Double, Double), newVelocity: Double) { point = newPoint velocity = newVelocity } public func update(newP: (Double, Double), newV: Double) { updatePoint(newP, newVelocity: newV) } } var p = ParticleModel() for i in stride(from: 0.0, through: times, by: 1.0) { p.update((i * sin(i), i), newV:i*1000) } 如上代码，当开启Whole Module Optimization选项的情况下，编译器能在属性point,velotity，以及updatePoint()方法上推断出final，既相当于在point、velocity、updatePoint()声明前加上final关键字，而update()方法由于是public级别，所以无法推断出final关键字，其仍将是间接调用。 总结： 使用静态派发的话结构体是个不错的选择, 而使用消息机制派发的话则可以考虑 NSObject 当你继承 NSObject 的时候, 这是一个你想要完全使用动态消息机制的表现. 当使用private或final关键字，或者开启Whole Module Optimization，声明internal级别的没有被重载的方法，将直接调用，在编译时确定。 运行时决定的动态派发的情形包括： 继承自NSObject或者方法有@objc前缀。 使用Swift的方法表的方式，除去上述情况下，将采用这种方式。]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>动态&amp;静态分析与实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift——访问控制关键字说明]]></title>
    <url>%2F2017%2F07%2F01%2FSwift%E2%80%94%E2%80%94%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[有的时候我们从访问控制可以看出代码的质量以及考虑的是否细致，在OC，Java时代我就接触过很多访问控制，但是Swift中又有什么不一样的地方呢？ 首先我们来看OC中的访问控制符 属性访问权限 protected 该类和所有的子类中的方法可以直接访问这样的变量，这是默认的。 private 该类中的方法可以访问这样的变量，子类不可以 可以将变量放在.m中 public 除了自己和子类中的方法外，也可以被其他类或者其他模块中的方法所访问。开放性最大。 package 框架集中 方法访问权限 只有public、private public .h文件 private .m中 其实这里并不默认，因为只有有那么一点基础都应该知道什么意思，但是当我们写Swift的时候，却发现很多地方不一样了。 swift中访问控制一共有5个关键字 open:可以在任何地方访问、继承和重写 public:可以在任何地方被访问，在其他module中不能被继承和重写(一会在详细介绍一下什么是module内和module外) internal:默认访问级别，在整个模块内都可以被访问 fileprivate:其修饰的属性可以再同一个文件被访问、继承和重写，同一个文件指同一个swift文件，一个文件中可以有多个类 private:其修饰的属性和方法只能在本类被访问和使用，不包括扩展类 上面部分是Swift新增的特性。 关键字详解1.private 和 fileprivate这两个访问关键字都是防止文件外访问，但是还是有一些差别的。 在原有的swift中的 private其实并不是真正的私有，如果一个变量定义为private，在同一个文件中的其他类依然是可以访问到的。 在swift 3中，新增加了一个 fileprivate来显式的表明，这个元素的访问权限为文件内私有。过去的private对应现在的fileprivate。现在的private则是真正的私有，离开了这个类或者结构体的作用域外面就无法访问。 2.internalinternal是Swift默认访问级别,所以其实是可以可不写 internal访问级别所修饰的属性或方法在源代码所在的整个模块都可以访问。 如果是框架或者库代码，则在整个框架内部都可以访问，框架由外部代码所引用时，则不可以访问。 如果是App代码，也是在整个App代码，也是在整个App内部可以访问。 3.public1.使用public修饰的类,属性或方法,可以被任何类访问, 2.但在其他的module中不可以被override和继承,而在本module可以; 注意：module内和module外的区别 ： module内是指不需要使用import引用文件，就可以创建对象，表示module内，而module外是指需要使用import文件才能创建对象才能使用 4.open1.可以被任何人使用 2.也可以被override和继承,这是和public的区别]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>访问控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——App整个启动过程分析]]></title>
    <url>%2F2017%2F06%2F28%2FiOS%E2%80%94%E2%80%94App%E6%95%B4%E4%B8%AA%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[你想知道App是怎么显示到我们眼前的吗？你想知道点击Run之后发生了什么吗？你想知道在Main函数之前都还有那些你不知道操作吗？你想知道在Objective-C和Swift混编的时候这么处理AppDelegate吗？你想知道UIApplication都干了撒吗？你想知道怎么优化App启动过程吗？你想知道…..你撒都想知道，那还等什么？ 前言 本文的起因： 前段时间在研究App启动相关内容，还有启动优化相关的东西，网上寻找了一下相关的资料并试着在整理，也自己试着去验证了其中的一些步骤。 公司项目是Objective-C版本的，大部分相关类都已经使用Swift重写了，后期新增的功能都使用的Swift混合开发。但是由于项目庞大又复杂，没有时间也没有精力去完全使用Swift重写。 因为从Swift一出来我就在学习，但是并没有在实际项目中应用到Swift，从1.0到2.0，再到3.0都有了解和学习相关的语法。但是近四年来一直都在使用OC和学习各种技术，以致于Swift其实该忘的也忘得差不多了。网上有句话：Swift从入门到入门。相信你既然都能看到这里，肯定明白其中的原因。所以我又开始重写学了一遍Swift，这一次是Swift3.1开始学，其实Swift4已经出来了，但是和3.1并没有太大的变化。 因为公司每个星期都有一个技术分享，所以我觉得去试一次，希望能把我知道的东西通过口述的方式分享出来。（不过分享的结果很差，毕竟是第一次，所以导致最后连我自己都不知道自己在说什么），同时这也是我在公司内部做的第一次技术分享的主题。 这一次，我希望能彻底从OC转到Swift进行实际开发。 资料地址： iOS——App整个启动过程分析。如果你觉得有用希望能给个star，或者有什么疑问欢迎issuse也欢迎联系我，谢谢！首先申明，本文大部分会以理论和实际分析，不会涉及的太多的代码实战，也不会涉及到太多相关术语的解释，当然部分会给出链接地址，但是力求从下面几个问题并结合实际App的启动过程，让你了解代码之前所干的事情和处理实际开发中遇到的相关问题…. 点击Run之后发生了什么,以致App能够显示在我们的眼前？ Main函数之前苹果还为我们的App做了哪些操作？ OC项目中怎么使用Swift重写AppDelagate？ UIApplication&amp;UIApplicationMain背后做了什么？ 如何优化App启动过程？…… 本文篇幅会比较长，但是如果你能完全掌握里面的内容和应用，足以让你有一个质的提升，当然这是在你不了解上面我提到的情况下。 好了，废话说太多没有什么意思……开干！ 2016 WWDC（苹果提供的启动优化方案） https://developer.apple.com/videos/play/wwdc2016/406/ 优化 App 的启动时间（各个阶段优化与处理） http://ios.jobbole.com/90331/ iOS 程序 main 函数之前发生了什么 http://blog.sunnyxx.com/2014/08/30/objc-pre-main/ 点击 Run 之后发生了什么？（Build类似） http://www.jianshu.com/p/d5cf01424e92 Xcode编译性能优化（各个阶段优化实战与对比） http://blog.csdn.net/qq_25131687/article/details/52194034]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>App整个启动过程分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带你简单理解block和__block的实现？]]></title>
    <url>%2F2017%2F06%2F25%2F%E5%B8%A6%E4%BD%A0%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3block%E5%92%8C-block%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[其实类似block和__block的实现网上随便一搜就能找到无数篇，有些分析的确实非常不错，但是或许有些人刚好就没有那个耐心去看完，有些人就算最后看完也没有理解，甚至还是没能理解其中的核心,所以这里我就根据个人的理解和网上资料的整理，简单的总结一下…… block1.Block其实是闭包 2.Block是基于C语言的拓展 3.Block是基于指针和函数指针实现的， 4.同时他也是一种匿名函数，而且你会发现他和函数其实有很多相似的地方 5.通过打印我们可以知道他其实是一种的结构体 block的实现Block是被设为_NSConcreteStackBlock，在栈上生成。当我们把Block作为全局变量使用时，对应生成的Block将被设为_NSConcreteGlobalBlock Block属性这里还有一点关于block类型的ARC属性。上文也说明了，ARC会自动帮strong类型且捕获外部变量的block进行copy，所以在定义block类型的属性时也可以使用strong，不一定使用copy。也就是以下代码： /** 假如有栈block赋给以下两个属性 **/ // 这里因为ARC，当栈block中会捕获外部变量时，这个block会被copy进堆中 // 如果没有捕获外部变量，这个block会变为全局类型 // 不管怎么样，它都脱离了栈生命周期的约束 @property (strong, nonatomic) Block *strongBlock; // 这里都会被copy进堆中 @property (copy, nonatomic) Block *copyBlock; __blockBlock不允许修改外部变量的值，这里所说的外部变量的值，指的是栈中指针的内存地址。__block 所起到的作用就是只要观察到该变量被 block 所持有，就将“外部变量”在栈中的内存地址放到了堆中。进而在block内部也可以修改外部变量的值。 总结就是：__block对象在block中是可以被修改、重新赋值的。 __block的实现__block其实是堆栈的拷贝， 首先block修饰的变量会变成block_bref_val_0的结构体，它包含实例变量本身__forwarding(用于访问局部变量val)。 block拷贝到堆上的时候： _val_0也会拷贝到堆上，局部变量销毁，block任然能对堆上的局部变量操作 __forwarding替换为堆上的__block变量的地址 栈上的_val_0结构体中的__forwarding指针也会指向堆上的结构体 main函数或者blcok释放的时候，只是释放了栈上的东西，所有对局部变量的操作都已经移到了对上。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>底层分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带你简单理解weak和__weak的实现？]]></title>
    <url>%2F2017%2F06%2F24%2F%E5%B8%A6%E4%BD%A0%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3weak%E5%92%8C-weak%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[其实类似weak和__weak的实现网上随便一搜就能找到无数篇，有些分析的确实非常不错，但是或许有些人刚好就没有那个耐心去看完，有些人就算最后看完也没有理解，甚至还是没能理解其中的核心,所以这里我就根据个人的理解和网上资料的整理，简单的总结一下…… weak字面含义就是弱引用,Objective-C中默认都是强引用的（strong） weak的实现Runtime维护了一个weak表，用于存储指向某个对象的所有weak指针。weak表其实是一个hash（哈希）表，Key是所指对象的地址，Value是weak指针的地址（这个地址的值是所指对象的地址）数组。 weak 的实现原理可以概括一下三步：1、初始化时：runtime会调用objc_initWeak函数，初始化一个新的weak指针指向对象的地址。 2、添加引用时：objc_initWeak函数会调用 objc_storeWeak() 函数， objc_storeWeak() 的作用是更新指针指向，创建对应的弱引用表。 3、释放时，调用clearDeallocating函数。clearDeallocating函数首先根据对象地址获取所有weak指针地址的数组，然后遍历这个数组把其中的数据设为nil，最后把这个entry从weak表中删除，最后清理对象的记录。 __weak__weak修饰符的对象，作用等同于定义为weak的property。他并不会导致循环引用问题（通过苹果文档我们可以得出这样的结论），当原对象没有任何强引用的时候，弱引用指针也会被设置为nil。 __weak的实现简单来说，系统有一个全局的 CFMutableDictionary 实例，来保存每个对象的 weak 指针列表，因为每个对象可能有多个 weak 指针，所以这个实例的值是 CFMutableSet（Array） 类型。 剩下我们要做的，就是在引用计数变成 0 的时候，去这个全局的字典里面，找到所有的 weak 指针，将其值设置成 nil。如何做到这一点呢？Friday QA 上介绍了一种类似 KVO 实现的方式。当对象存在 weak 指针时，我们可以将这个实例指向一个新创建的子类，然后修改这个子类的 release 方法，在 release 方法中，去从全局的 CFMutableDictionary 字典中找到所有的 weak 对象，并且设置成 nil。我摘抄了 Friday QA 上的实现的核心代码，如下： Class subclass = objc_allocateClassPair(class, newNameC, 0); Method release = class_getInstanceMethod(class, @selector(release)); Method dealloc = class_getInstanceMethod(class, @selector(dealloc)); class_addMethod(subclass, @selector(release), (IMP)CustomSubclassRelease, method_getTypeEncoding(release)); class_addMethod(subclass, @selector(dealloc), (IMP)CustomSubclassDealloc, method_getTypeEncoding(dealloc)); objc_registerClassPair(subclass); 总结一句就是：一个通俗的解释就是，在Objective-C的运行时环境中，维护了一种weak表，这张哈希表用对象的首地址作为键，将由若干个weak修饰的指针自身的地址组成的数组作为值。当一个Objective-C对象被释放后，通过这个对象的起始地址来找到所有指向它的weak指针，并将它们指向nil。 __weak的作用在Objective-C中，用__weak修饰的指针，会在所指向的那个Objective-C对象被释放后，自动指向nil。 使用__weak来修饰指针，相比于__unsafe_unretained，可以帮助程序员减小访问野指针的风险，方便了程序员对内存的管理。 block和weak的区别前面提到了block，也大概说了一下其简单实现，所以这里总结一下block和__weak修饰符的区别： 1.__block不管是ARC还是MRC模式下都可以使用，可以修饰对象，还可以修饰基本数据类型。 2.__weak只能在ARC模式下使用，也只能修饰对象（NSString），不能修饰基本数据类型（int）。 3.__block对象可以在block中被重新赋值，__weak不可以。 4.__block对象在ARC下可能会导致循环引用，非ARC下会避免循环引用，__weak只在ARC下使用，可以避免循环引用。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>底层分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分类能添加属性吗？成员变量呢？为什么？]]></title>
    <url>%2F2017%2F06%2F20%2F%E5%88%86%E7%B1%BB%E8%83%BD%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7%E5%90%97%EF%BC%9F%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%91%A2%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[在iOS开发中，如果你要在不改变原来的类内容的基础上，为类增加一些方法，那么苹果提供了一个很好机制，那就是分类，当然我们平时可能比较多的是直接给他添加方法，并且我们清楚一点的是，我们还能给一个分类添加属性（使用关联对象），但是并不能添加成员变量，可是为什么刚好成员变量就不能连接呢…… 分类概念： Category 分类是OC特有的语言，依赖于类。 分类的作用： 在不改变原来的类内容的基础上，为类增加一些方法。 分类增加属性和方法属性方法 这里其实就不用做过多介绍了，只需要知道分类增加方法其实就和一个类增加一个方法一样。 属性 至于分类增加属性，只要使用到的就是Objective-C里面比较底层的一个技术Runtime，Runtime里面有个里面有个关联对象的概念，具体请查看官方或者相关资料，很简单。 成员变量NO，NO，NO，分类是不能增加属性的，一定没办法，如果你有可以来找我，哈哈…. 为什么不能增加成员变量呢？首先我们不能混淆了成员变量和属性的概念.Property是Property，Ivar是Ivar。 分类里面不能添加Ivar是因为分类本身并不是一个真正的类（Objective-C中真正的类是有一个isa存在的），但是分类并没有自己的ISA . 类最开始生成了很多基本属性，比如IvarList，MethodList，分类只会将自己的method attach到主类，并不会影响到主类的IvarList。 这就是为什么分类里面不能增加成员变量的原因” 类和分类的初始化1.当程序启动时，就会加载项目中所有的类和分类，而且加载后会调用每个类和分类的+load方法，只会调用一次； 2.当第一次使用某个类时，就会调用当前类的+initialize方法； 3.先加载父类，再加载子类（先调用父类的+load方法，再调用子类的+load方法，最后调用分类的+load方法），先初始化父类，再初始化子类（先调用父类的+initialize方法，再调用子类的+initialize方法）。 4.注意：在初始化的时候，如果在分类中重写了+initialize方法，则会覆盖掉父类的。 5.重写+initialize方法可以监听类的使用情况。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>底层分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么调用nil的任何方法都不会崩溃？]]></title>
    <url>%2F2017%2F06%2F18%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%B0%83%E7%94%A8nil%E7%9A%84%E4%BB%BB%E4%BD%95%E6%96%B9%E6%B3%95%E9%83%BD%E4%B8%8D%E4%BC%9A%E5%B4%A9%E6%BA%83%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[我们知道，在Objective-C消息和转发机制的背后有这样一个说法：调用没有实现或者不存在的方法，会导致App崩溃，但是如果你比较细心或者专门研究过消息和转发机制那么你应该听过这样的结论：Objective-C中调用nil的任何方法都不会崩溃，但是，为什么就不会崩溃呢？这里就简单分析一下具体的原因和底层的实现方式…… 访问了一个已经被释放的对象我们知道在不使用 ARC 的时候，内存要自己管理，这时重复或过早释放都有可能导致 Crash。 NSObject * aObj = [[NSObject alloc] init]; [aObj release]; NSLog(@&quot;%@&quot;, aObj); 原因aObj 这个对象已经被释放，但是指针没有置空，这时访问这个指针指向的内存就会 Crash。 解决办法使用前要判断非空，释放后要置空。正确的释放应该是: [aObj release]; aObj = nil; 由于ObjC的特性，调用 nil 指针的任何方法相当于无作用，所以即使有人在使用这个指针时没有判断至少还不会挂掉。 那么这里就有一个问题？为什么调用nil的任何方法都不会崩溃呢？ 首先在Objective-C里，nil对象被设计来跟NULL空指针关联的。他们的区别就是nil是一个对象，而NULL只是一个值。而且我们对于nil调用方法，不会产生crash或者抛出异常。这个技术被framework通过多种不同的方式使用。 最主要的就是我们现在在调用方法之前根本无须去检查这个对象是否是nil。假如我们调了nil对象的一个有返回值的方法，那么我们会得到一个nil返回值。 我们先来看看这断代码： - (void) dealloc { self.caption = nil; self.photographer = nil; [super dealloc]; } 具体原因 之所以可以这么做是因为我们给把nil对象设给了一个成员变量，setter就会retain nil对象(当然了这个时候nil对象啥事情也不会做)然后release旧的对象。这个方式来释放对象其实更好，因为这样做的话，成员变量连指向随机数据的机会都没有，而通过别的方式，出现指向随机数据的情形机会不可避免。 注意到我们调用的self.VAR这样的语法，这表示我们正在用setter，而且不会引起任何内存问题。假如我们直接去设值的话，就会有内存溢出： // incorrect. causes a memory leak. // use self.caption to Go through setter caption = nil; 这里进入提到了崩溃，那么就大概整理一下开发中常见的崩溃问题和类型，方便提前预防和部分相关处理一、访问了一个已经被释放的对象：nil，autorelease 二、访问数组类对象越界或插入了空对象：分类或者runtime替换 三、访问了不存在的方法：判断是否有，runtime修改 四、字节对齐：使用 memcpy 来作内存拷贝，而不是直接对指针赋值 五、堆栈溢出（过多的递归会导致栈溢出，过多的 alloc 变量会导致堆溢出。） 六、多线程并发操作：加锁 ，原子，Operation Objects, GCD, Idle-time notifications, Asynchronous functions, Timers, Separate processes。 七、Repeating NSTimer：写了个宏用来释放Timer]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>底层分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XCode9——还有那些你不知道的新特性？]]></title>
    <url>%2F2017%2F06%2F15%2FXCode9%E2%80%94%E2%80%94%E8%BF%98%E6%9C%89%E9%82%A3%E4%BA%9B%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[苹果在每一年的WWDC都有很多惊喜，同时也有让人赞不绝口的新东西，今年同样不例外，除了新品，新系统，新Swift之外，其中一个很重要也是所有开发中必须关注的就是XCode的新特性，那么今年XCode又推出了那些新特性呢？ Xcode是用于为Apple TV，Apple Watch，iPad，iPhone和Mac创建应用程序的完整开发人员工具集。Xcode开发环境采用tvOS SDK，watchOS SDK，iOS SDK和macOS SDK的形式捆绑Instruments分析工具，Simulator和OS框架 Xcode 9.0需要运行MacOS Sierra 10.12.4或更高版本的Mac。 前言苹果在What is New Xcode中详细介绍了Xcode 9中的新特性，其中开篇就有这样一段话 Xcode 9 includes overall quality improvements as well as extensive new features.+ All new editor: Fast, structure-based editor that lets you intelligently highlight and navigate your code. Includes great Markdown support. + Refactoring: Refactoring built right into the editing experience and works across Swift, Objective-C, Interface Builder, and many other file types. + Super-fast search: The Find navigator returns results instantly. + Debugging: Wirelessly debug iOS and tvOS devices over the network, new debuggers for Metal, and more features throughout Xcode. + Source Control: All new source control navigator and integrated support for GitHub accounts for quickly browsing repositories and pushing your repositories to the cloud. + Xcode Server built-in: Continuous integration bots can be run on any Mac with Xcode 9, no need to install macOS Server. + New Playground templates: Includes iOS templates designed to run well in both Xcode and Swift Playgrounds in iPad. + New Build System: An opt-in preview of Xcode&apos;s new build system provides improved reliability and performance. 如果你对英语不熟悉的话，可能看完上面只有有点懵逼，那么我们来看看具体的中文意思，或者很多东西就能很清楚了！ Xcode 9包括整体质量改进以及广泛的新功能。+ 全新编辑: 快速，基于结构的编辑器，可让您智能地突出显示和浏览代码。包括伟大的Markdown支持。 + 重构: 重构内置于编辑体验之中，并可跨Swift，Objective-C，Interface Builder和许多其他文件类型。 + 超快速搜索: “查找”导航器会立即返回结果。 + 调试: 通过网络无线调试ios和tvOS设备，Metal的新调试器以及Xcode中的更多功能。 + 源控制: 所有新的源代码管理导航器和集成的支持GitHub帐户可以快速浏览资源库并将您的存储库推向云端。 + Xcode服务器内置: 连续集成机器人可以在任何具有Xcode 9的Mac上运行，无需安装macOS Server。 + 新游乐场模板: 包括iOS模板，旨在在iPad中的Xcode和swift Playground中运行良好。 + 新建系统: Xcode新的构建系统的选择性预览提供了更高的可靠性和性能。 所以通过上面的这段话，我们可以得知苹果在XCode还是推出了很多不错的东西，值得前线开发中第一时间研究并学习相关内容，所以我们来具体总结一下，XCode 9到底有那些新特性….. 源代码编辑器。代码编辑器的滚动It scrolls at a constantly smooth rate, no matter the files size. 在Xcode中，你会发现不管文件有多大，滚动都会很平滑，老版本的Xcode会时不时的卡顿。 代码样式give you greater control over line spacing, multiple font styles, and even the type of cursor. 在Preference中增加了对行间距和光标样式的修改。 同时还增加了对资产目录使用命名颜色的支持。 增加了对新边距和基线视图约束的支持。 添加了对自动布局安全区域指南的支持。 增加了对全屏WatchOS应用程序的支持。 Command + 点击行为command-click gesture makes it easy to visualize and select sections of code based on structure. 按住Command点击方法，类，变量的时候，交互方式比之前更加清晰。 Issue提示框Issues have been redesigned to flow nicely with your code with Fix-its are grouped together so you can commit multiple changes in a single click. 错误和警告的提示框在界面上做了重新设计，解决了之前的很多细节上的问题。 MarkDown支持In Markdown files, headings, bold and italic text, links, and other formatting are instantly rendered in the editor as you type. The Jump Bar even understands Markdown structure so you can quickly navigate your README.md and documentation files. 加入了对MarkDown格式的支持。 重构和代码转换添加了一个在Swift中编写的新构建系统的预览。 新的Xcode提供了新的重构和代码转换引擎。当你Command + Click时，Xcode会根据上下文提供对应的重构方式和代码转换，转换引擎是开源的，以后应该会有更多来自其他开发者贡献的代码转换特性。 提供更高的可靠性。 捕获许多项目配置问题。 提高整体构建系统性能。 注意，构建系统性能不包括构建系统使用的编译器，链接器和其他工具。 目前可选，并将成为未来版本的Xcode的默认值。 具体操作：要选择项目或工作区的新构建系统，请选择“文件”&gt;“项目设置”或“文件”&gt;“工作区设置”，然后选择“构建系统”类型的“新建构建系统（预览）”。 对Git的支持Git的管理界面直接以navigator的方式集成到Xcode中，可以方便的对自己的Git Repos进行管理。 之前虽然支持Git，但是并不友好，而且使用起来总让人感觉不够爽，最终很多人选择使用第三方的管理工具，比如SoureTree，tower等。 远程调试想要支持远程调试，你的手机必须升级到iOS11。升级后，连接手机，进入Devices and Simulators。 选中Connect via network，再拔掉数据线就可以了。注意一定要在一个局域网中。 具体可以看我这篇文章：WWDC17惊喜——Xcode9无线调试 同时增加了网络调试相关的内容通过WiFi或有线网络调试iOS和tvOS设备。通过Bonjour连接或输入IP地址。需要插入iOS设备才能启用网络调试。 模拟器支持多个模拟器同时开启，方便自动化测试。 适用于iOS和watchOS模拟器的新Chrome包括硬件控件，并允许轻松拖动和调整模拟设备的大小。 Swift4Swift 4和Swift 3，Swift 4和Swift 3目标的一个编译器可以在同一个项目中编译。 改进的迁移者体验，仅支持将选定目标迁移到Swift 4。 主线程检查检测未在主线程上进行的AppKit，UIKit和WebKit方法调用。在调试期间自动启用，并且可以在方案编辑器的“诊断”选项卡中禁用。主线程检查器与Swift和c语言一起使用。 VR支持查看VR提交和左眼/右眼提交的表面。 添加了纹理检查，用于检查渲染目标中各个像素的值，如颜色，alpha，深度等。 添加检查输出顶点属性到缓冲区编辑器。 添加数据提示支持金属对象，如纹理，缓冲区和采样器。 还有一些大家不曾注意的细节自定义新的文件头。 更新了项目中plist文件文本宏的定义方式。同时为项目中的用户,项目或特定用户定义文本宏。 更新了索引引擎，包括在编译文件时编制索引的能力。 设备窗口被分成用于设备和模拟器的单独窗格，对命名颜色支持。 添加了广泛的应用程序图标。为App图标集添加了更大的iOS营销。同时添加了保留图像矢量数据以选择动态类型缩放的选项。增加了HEIF图像的支持。 最后如果你想了解更多关于XCode9相关特性和信息可以点击这里 What is New Xcode xcode9 新功能]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>WWDC</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WWDC17惊喜——Xcode9无线调试]]></title>
    <url>%2F2017%2F06%2F13%2FWWDC17%E6%83%8A%E5%96%9C%E2%80%94%E2%80%94Xcode9%E6%97%A0%E7%BA%BF%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[苹果第28届年度全球开发者大会（WWDC 2017）在6月5日至6月9日（北京时间6月6日凌晨1点）在圣何塞的 McEnery 会议中心举行，到目前为止，我一直在寻找WWDC17中值得开发者庆祝与欢呼的福利…… 其实，苹果几乎在每年WWDC，都会给开发者带来不同的惊喜，从1983年到至今…. WWDC 1983：Lisa开始 WWDC 1998：Mac OS X WWDC 2008：iPhone 3G WWDC 2010：iPhone 4 WWDC 2013：iOS 7 扁平化风 WWDC 2014：Swift问世，以及Swift一路过来的大改版 WWDC 2015：One More Thing WWDC 2016：Siri、iMessage 等软件在多平台的打通 当然还远远不止这些，上面这些都只是在现场产生了欢呼的产品,并且对开发者和用户来说都是非常值得一试的福利，甚至包括其中每一小场中带来的新特性，新功能….. 所以2017年苹果在第28届年度全球开发者大会同样带来了不少的惊喜，比如 macOS High Sierra 苹果音箱HomePod发布 ... 这一届WWDC之后，我第一时间去寻找苹果的各个方面的新特性和新功能，其中发现了一项，值得我放下当下所有任务去研究一下的，那就是：Xcode 9 Beta版的无线调试模式。 如果你曾经是一个iOS开发者或者是学习iOS开发，那么你会发现几个问题。 当我们，每次修改一个东西（方法，一行代码，一个约束，一个资源）都要运行并且拿起手机，运行并测试，当然这个不是重点，重点是你的手机必须使用数据线连接电脑，如果没有链接，那么你撒野干不了，所这个时候可能遇到这样的一些问题。 1.如果你的线坏了，或者解除不良那么又蛋疼了。 2.如果你手机刚刚因为某些原因拔了，那么你又必须重新插上，并且等待链接才能运行测试。 3.如果你有还几个测试机，那么你需要好几条数据线，或者你需要每个分别切换插拔。 4.如果公司某个同事需要一个最新版（比如测试，产品，老板），那么你必须拿到手机插上线，然后Run一下（如果被你发现隐私了怎么办）。 ..... 当然这里面或者你还会遇到一些其他比较特殊的情况，但是这一点苹果怎么会想不到呢？所以WWDC17之后，苹果专门解决了这个问题。那就是我上面提到的，Xcode 9 Beta版的无线调试模式。 那么什么是：无线调试模式呢？ 其实就是你不需要使用数据线链接手机，就可以直接运行一个App到你的手机！ 但是在开始使用的时候，我发现其实还有有一个弊端的，就是第一次始终还是需要链接的，不然没有办法找到你的手机，或者说没有办法配对！ 好了，下面我就通过实际演示来玩转一下这个无线调试模式。 首先请准备好环境。 设备环境：Mac OSX 10.12.5、iOS11、Xcode9 这是WWDC2017的新功能，所以 Mac必须在Mac OSX 10.12.4以上（iOS 9 Beta根本安装不了），这里我是直接升级的，所以直接到了Mac OSX 10.12.5 iOS必须要在iOS11以上 XCode必须在iOS 9 Beta及版以上 配对与测试1. 打开手机，插上数据线，并且能保证手机正常链接电脑和Xcode（如果第一次会有信任的提示） 一般如果链接成功，Mac会自动弹出iTnues，并且显示对应的手机设备。 2. 这个时候，我打开Xcode9 Beta版（如果没有下载请前往Apple developer下载） 这里我Mac中有两个Xcode，那个带BETA标识的就是Xcode9 Beta版，打开之后就可以正式连接配置了！ 打开Xcode导航菜单，然后点击：Windows-&gt;Device and Simulators。找到你已经连接上的设备，把Connect via network选项打勾。 这里iPad和iPhone的连接方式是一样的，没有任何差异！ 3. 点击并选中Connect via network之后，Xcode将会转一会圈圈，耐心等待一会就可以成功了。如果成功你会看到这些标志，没有就代表没有成功，重新再试一次。 此时可以拔掉数据线，但是我们可以看到左侧的设备连接列表上手机仍显示在上面。 4. 同时我们，打开XCode主界面并，点击设备选择的位置，可以看到，已经链接上的设备。 注意，这时候我的数据线已经是没有查上手机的，是不是很神奇！ 然后我就就可以和之前使用数据线链接手机一样直接运行APP，他就会帮我们安装到手机上并且自动启动显示。。 防掉线处理这里我开始以为第一次运行需要链接安装的，验证了一下，发现其实第一次都不需要连接安装，只是第一次验证和配对需要链接数据线…. 但是，是不是到上面就完了呢？其实不然，当我调试了一段时间之后再打开Device and Simulators的时候发现这样的情况！ 有没有发现iPad已经DisConnected了，说明iPad其实已经是自动断开了！ 这个时候我就需要另外做一些配置工作。 1. 回到我们刚刚的设备列表中，选中手机右键，在出来的选项卡中选择一个Connect via IP Address项。 2. 然后输入手机的局域网ip地址。 3. 完成之后，不出意外的话，上面那个问题就解决了。 以后只要之前链接过的手机，并且配置，配对，验证成功的，项目运行之后都可以直接运行起来，并进行测试，不需要再用上面数据线啦，是不是很爽…… 注意点？这里有一点需要注意的 Mac和测试设备（iPhone，iPad，...）必须在同一个局域网下,这个其实应该接不上的都满足的。]]></content>
      <categories>
        <category>WWDC</category>
      </categories>
      <tags>
        <tag>WWDC</tag>
        <tag>WWDC17惊喜</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个偶然的面试机会——我既然懵了]]></title>
    <url>%2F2017%2F06%2F11%2F%E4%B8%80%E4%B8%AA%E5%81%B6%E7%84%B6%E7%9A%84%E9%9D%A2%E8%AF%95%E6%9C%BA%E4%BC%9A%E2%80%94%E2%80%94%E6%88%91%E6%97%A2%E7%84%B6%E6%87%B5%E4%BA%86%2F</url>
    <content type="text"><![CDATA[刚刚辞职没有几天，其实我并没有打算这么早就去找工作的，就是因为有事情要处理所以才辞职，然后准备在家休息几天的时候，既然突然收到一个电话说叫我去面试的，当时已经是委婉的拒绝了的，但是对方好像很礼貌，而且说看了我的博客网站和工作，很希望能去面试一下，或者了解一下，于是我就了解了一下他们公司的情况，最后通过各方面考虑答应了会准时赴约……. 两天之后我就准时去面试了，并且中间发生了一些挺有意义的事情。 第一面的时候，遇到了一个自称为是我粉丝的人，当然我好像比他还要激动😂😂😂 第三面既然发现老板是老乡，只是很早就来广州发展了，于是我们用方言聊了起来。 其中第一面和第二面的时候大部分都是技术型的问题这里根据自己的记忆，做了一下相关的整理。 部分答案会后期再做整理和分享 第一面：在一个小房间等了几分钟之后，来了两位面试官，面带微笑的跟我握了手，并且其中一位说了一句：你就是iCocos。当时我就懵逼了，结果他告诉我，看了我们的博客网站，github，也一直在关注，曾经还给我评论了，发了邮件请教过问题，当时场面有点尴尬，因为我根本想不起来什么了，然后就这样过了，，，，，，， 第一面主要问了下面这些问题： 说说Swift函数式编程和面向协议编程 TCP，UDP，HTTP，Socket之前的一些区别和理解 你都用Runtime做过撒 KOV和KVC的理解还有底层实现？ 100万个中去出其中最大的100个，你会怎么做？说说为什么这么做？ MVVM结合RAC在实际项目中给你带来了什么方便之处。 如何做数据埋点 说说Objective-C中的消息和转发机制 iOS开发中事件处理是怎么实现的，什么是响应链？…… 第二面：面完第一面之后，又在里面等了大概十分钟，来了一个身材很丰满的大哥，说是公司的技术总监，于是我们就聊了起来。 首先聊的是项目，一开始就教我打开项目演示，并且告诉他那些事我做的，亮点和难点在哪里？ 做过或者了解过音视频编解码吗？说说你所知道的。 CI和CD是怎么什么做的，中间遇到了什么问题？你是这么处理这些问题的？ 这么保证我们开发的项目，数据，源码，请求等更加安全？ 为什么HTTP链接是三次握手，关闭需要四次？ 自动自动释池是什么？ 属性与成员变量的区别？ 什么是RunLoop？ 什么是Blcok，使用的时候需要注意什么？还有__block的实现是什么？ 说说多线程，并说说你使用最多的方式，为什么？……… 一二面总结到这里，两轮面试大概就完了，当然上面大概是我所能想起来的一些，其中还有一些随便聊到的，具体问题也不记得了，但是大概能起一下关键字什么的？ 比如： 轮询 Swift FMDB安全 WWDC2017新东西 SwiftJSON Mansory 签名机制 几个常用第三方的理解和实现 第二面：两轮技术面试完了之后，接来下是最后一轮，第三轮，是和老板聊，和老板聊的时候，感觉就不一样了，老板看了我的简历说，我们既然是老乡，然后就直接用起来老家话，聊了一伙，虽然是老乡，但是毕竟人家是老板，我是来面试的，也不能太嚣张，所以一路下来我还是很礼貌变现很正常的回答他的问题，并且最后走的时候还留了他的微信和电话…… 就这样整个面试就结束了，讲真的，这场面试还是有很多东西值得学习的，不管是前面两轮技术上的知识，即使很多我都快忘了。还是后面跟老板聊到的一下生活，理想上的问题，我都有在思考...... 面试已经过去两天了，暂时还没有收到什么消息，虽然我并没有太多期望，我也知道前面技术面试表现并不是很好，不管是因为我知识面不够还有理解的不够深入，我觉得这一次还是值得了，因为至少我知道了自己还有很多方面是不足的！ 之后大概整理一下，上面一些相关的技术问题和部分问题的答案，由于个人能力有限，如果有不对或者误解的地方，还有见谅并指出，谢谢！消息消息机制：忽略-nil-IMP-缓存-方法（重复父-根）-存或者转发-函数指针-实现 转发机制：动态（动态添加），标准（别的对象执行），快速（其他形式执行），发送消息获取签名，非空就转发，否则奔溃退出 事件响应：view-VC/父视图-window-application-丢弃 传递：事件添加到application队列-取出传递给窗口-寻找最适合View（主窗口是否接受-触摸点是否在自己身上-重复子控件）-没有就自己处理调用touches KOV&amp;KVCKVO基于KVC，KVC基于Runtime KVC：字符串非访问器，类型混合指针：方法名-环境变量-结合isa找接口-找实现。检测ket对应的set方法-同名_key成员属性-同名属性_key-undefine. KVO：创建派生类-重写setter方法（isa假的,指向的是派生类），willchange，didchange监听内部path Blockblock（闭包）：C语言的拓展，基于指针和函数指针，一种匿名函数的结构体； 堆栈的拷贝，__block修饰的变量会变成__block_bref_val_0的结构体，它包含实例变量本身__forwarding(用于访问局部变量val)。 block拷贝到堆上的时候： _val_0也会拷贝到堆上，局部变量销毁，block任然能对堆上的局部变量操作 __forwarding替换为堆上的__block变量的地址 栈上的_val_0结构体中的__forwarding指针也会指向堆上的结构体 main函数或者blcok释放的时候，只是释放了栈上的东西，所有对局部变量的操作都已经移到了对上。 Copyblock：MRC传下来的，MRC中block在栈去，copy将其放到堆区，ARC中不写也可以的，编译器对block进行了copy操作 NSString:对应可变类型，防止被修改。 不可变使用strong，防止判断影响性能。不可变的数据类型线程更安全。 GCD基于XNU，在libdispatch库，queue管理block操作，source：处理事件， 基于C语言（NSO基于GCD），只支持FIFO（NSO可调整和设置并发数），依赖复杂（NSO简单且支持KVO），速度快。任务添加到队列，NST使用NSObject的分类实现通讯 RunLoop运行循环（不断处理事件），至少一个时间源，事件接受与分发机制，一步执行不能并行执行，保证程序执行的线程不被终止，有事情做的时候，根据具体事件类型通知应用做出响应，没有就会进入休眠，省电，再次发生会唤醒处理事件（通过Observer监听，并释放自动释放池）。 input：传递异步时间，通讯与传输 timer：传递同步事件 销毁发生在线程结束的时候，很少主动创建，而是把事件添加到runloop。每次RonLoop完成一个缓存都会检测retainCount是否为0 成员变量和属性属性=成员变量+get+set，编译器自动合成，@dy告诉编译器我们自己实现，没有实现编译的时候没有问题，运行的时候就会报错，说找不到对应的方法。 成员变量地址可根据实例的内存地址偏移寻址，属性读写需要函数调用（访问器），相对更慢，C++成员变量更合适（不支持copy等） 多线程情况保证数据一致，同步执行的时候使用成员变量，同步的时候set，get会降低效率，锁影响 成员变量可以直接管理内存，属性进行了多层封装，还能复写，容易出错 默认用属性生成不必要的set，get方法，体积变大 自动释放池（存储指针变量）&amp;AutorreleasePoolautorrelease把对象放入到自动释放池（延迟释放），自动释放池释放的时候，内部的对象引用计数-1， AutorreleasePool：接受对象向他发送的release消息，记录该对象的release消息，自动释放池销毁的时候，想池中记录的对象发送release消息 释放时机：autorrelease的}执行完后，实际是autorrelease对象在当前Runloop（Push，Pop）迭代结束的时候释放 AutorreleasePoolPage（Push，Pop）一个个page组成，4096字节大小，每个AutorreleasePoolPage双向链表链接形成一个自动释放池。 三次和四次服务端接受到客户端的请求信号报文后，可以直接发送信号和应答报文。关闭的是，服务端收到信号报文的时候，很可能不会立即关闭，只能先回一个应答报文，告诉客户端我收到了你的报文，只有等服务端所有报文发送我哪里才会发送关闭的信号报文，所以不能一起发送 总结长轮询：服务端的程序加入到一个死循环，在循环中检测数据的变动 desc：NSLog底层调用，Array答应打印元素，NSObject打印类名和指针 区块链：一串使用密码学方法相关联产生的数据块（包含比特币网络交易信息，验证有效和产生下一个快） KVC：因为使用字符串所以比较慢，无法检测错误 Swift：隐含一个Main函数，会设置并调用全局的C_ARGC C_ARGV，调用由top level code构成的top_level_code（）函数 FMDB安全：创建一个GCD线程队列，读取时调用inDatabase方法，在block锁定数据库，实际对应整个数据库加锁 数组和字典：每个对象或者成为key/value时，对象计数器+1（retain），当字典或者数组销毁的时候，里面所有的元素或者key/value都会被release一次（-1）， Xcode9无线调试，APFS，ARKit， “”，string：常量 format：堆 HTTPS=HTTPS+TLS（运行在TCP之上），TLS有独立的握手，链接，验证机制，任何一个数据包篡改，都失败，当我们使用HTTP协议来解释TLS曾携带的内容就是HTTPS maker加入到blcok，遍历block中约束数组install YYText：Label，Text，CoreT，图文，MacD，表情，编辑，竖 SwiftJSON不要一直判断是否存在，是否是我们想要的class，内部自动对optional拆包 SD在单例情况下，缓存使用url，磁盘使用md5 Alamofire不是类，只是命名空间，通过参数调用Manager具体方法，几乎所有操作都是通过Manager控制 RAC（singal流），RXS（Observable），监听管道sequence（状态之间的依赖，MVC中Controller中的复杂和臃肿，统一消息处理机制） iJK（VideoToolBox，OpenGL ES，AudioQueue），视频（软硬编码），音频（软编码），从解码钱的数据缓冲区中取出一帧数据进行解码，完成后放入相应的解码后的数据缓冲区 load父先子，类先分， cache缓存指针和vtable，加速方法调用，bits存类的方法属性协议等信息 extra_rc存额外的自动引用计数，实际计数在此基础+1，使用isa的extra_rc和SideTable存引用计数 空指针：赋值为nil，僵尸对象：对中已经被释放的对象count=0，野指针：指针没有初始化，只想的空间被释放，OC中没有空指针异常 泄露：提前赋nil，没有配对或者清空，栈区释放了，堆去没有释放 溢出：容量超过限制 类的结构isa最前面，父类的实例变量在子类的实例变量之前 define：编译器，替换，无内存，不检测类型 __block在MRC和ARC中都可以使用，可以是对象和基本类型，__weak只能在ARC中使用，只能是对象。__block可以在block在block中重新复制，但是__weak不行。 签名机制：通过摘要算法得到摘要，用私钥对摘要加密得到密文，密文+原文本+私钥对应的公钥一起发布 Get：1024k UDP：64kb AFN：60s SD:一周 线程：64个]]></content>
      <categories>
        <category>Meeting</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Meeting</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WWDC17——都有那些值得你去了解的？]]></title>
    <url>%2F2017%2F06%2F06%2FWWDC17%E2%80%94%E2%80%94%E9%83%BD%E6%9C%89%E9%82%A3%E4%BA%9B%E5%80%BC%E5%BE%97%E4%BD%A0%E5%8E%BB%E4%BA%86%E8%A7%A3%E7%9A%84%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[苹果第28届年度全球开发者大会（WWDC 2017）在6月5日至6月9日（北京时间6月6日凌晨1点）在圣何塞的 McEnery 会议中心举行…… 苹果WWDC2017Apple Watch 1. 系统watchOS迭代到了第四代，加入了更智能的语音助手Siri表盘。用语音即可操控整块手表，交互进一步升级。 2. 更多迪士尼的经典人物加入表盘内显示，同时还可以根据用户的动作产生互动。比如你甩下手表，那个动画人物就飞出表盘外了。 3. 更智能能的运动App，可以对你的训练提出建议，还可以同时监视用户两项运动数据。对于喜欢健身的朋友来说比较实用。 4. 增加与健身器材的互动。比如手机靠近跑步机，就能读取到跑步机里的数据，当然这对跑步机也有要求。目前苹果已经和部分知名健身器材厂家展开了合作，在相关器材了加入了对Apple Watch的支持。 5. 增加与“音乐”应用的互动，开始运用时音乐会自动播放，还能根据不同的运动切换到不同的音乐。 mac OS 1. 新系统macOS High Sierra登场。命名上毫无创意，在现有的macOS Sierra中间加了个“High”单词。主持人居然还说是在行走高山时触发灵感才想到的…… 2. 浏览器Safari加入了自动屏蔽. 智能防跟踪功能，尽可能地保护你的个人隐私。在此之前主持人惯例商业管理吹一波，表现目前Safari是地表最强. 最快的浏览器。 3. 照片功能加入了新的UI，更方便归类和查找，同时增强了照片编辑功能，但显然不可能达到专业的图片处理软件水平。 4. metal功能升级到metal2，整体调用速度提升十倍，变得更加智能，进行外部显示连接，可以帮助开发者创作VR。所有支持Sierra系统的设备都可以支持High Sierra。 iMac 1. 显示器略有提升，处理器升级到英特尔第七代KabyLake处理器；显卡方面，27英寸版的iMac采用了AMD Radeon 570/580显卡。 2. 21.5 英寸配备Retina 4K显示屏的iMac降价，13英寸的MacBook Pro也降价了。 3. iMac Pro发布！主持人表示这是目前最强大的MAC电脑，把工作站级的性能带到MAC。它配备英特尔8核心XEON处理器，最高选配18核心XEON处理器;搭载AMD Radeon Vega系列显卡，拥有16GB显存，可以实现22Teraflops运算。存储方面，iMac Pro提供了128GB ECC内存. 4TB最高3GB/秒传输率SSD。iMac Pro还可以连接2个5K显示器。 4. 同样配置的工作站大约要7000美刀起，而IMAC PRO只需要4999美刀，并于今年12月开始发货。 iOS 1. iOS11正式发布，主持人说是“大版本更新”。短信功能imessage重新设计app贴纸，可以与其他iOS设备同步。 2. 到年底，美国将有50%以上的商店将支持Apple pay，并且Apple pay现在支持个人转账了!这方面我国的“微信”和“支付宝”早已走在了苹果的前面。 3. Siri通过深度学习变得更加智能，支持英文转中文. 法语. 德语. 意大利语. 西班牙语的翻译功能，支持ios设备的同步。 4. 通知界面改进，支持3d touch展开，也就是说你在锁屏界面时，可以通过不同按压力度打开对应的通知界面，不再单纯依靠上下左右滑动来交互。 5. 相册功能增加。动态图片支持反向播放，直接在相册里编辑还能实现长曝光功能。比如拍摄一组瀑布的动态照片，通过图片编辑就能变成一张长曝光摄像手法的图，无需在事先打开其他特效相机。 6. 地图加入更多的信息，还有支持店铺搜索，就像商场里每一层的店铺导购图那样。不过目前只支持机场的店铺搜索，而且都是美国的机场。 7. 用地图导航时，还支持免打扰功能(黑屏)，这时手机不会受到任何消息，这时别人发短信给你，系统会自动回复我在开车的信息，确保安全。 8. App store重新设计，加入“today(今天)“标签，里面有众多分类。以“游戏”分类为例，有新的应用详情页展示，查看内购项目信息;还可以查看编辑推荐的游戏和攻略。“Home”工具提供全自动控制家中电器的方式，新增音响类型。顺便一提iOS11上的“音乐”应用支持SNS功能，像QQ音乐那种，可以看到你好友最近听什么歌，喜欢听什么类型的歌。 9. “Home”工具提供全自动控制家中电器的方式，新增音响类型。顺便一提iOS11上的“音乐”应用支持SNS功能，像QQ音乐那种，可以看到你好友最近听什么歌，喜欢听什么类型的歌。 10. iOS11特别为中国用户做了优化，比如在锁屏界面上就可以扫描二维码，还支持上海话识别等。 iPad相关 1. 全新iPad Pro发布，第一款10.5英寸iPad Pro，重量更轻，只有前代的一半。 2. iPad Pro的屏幕进一步升级，拥有更广的色域和更高的亮度，支持120Hz刷新率。坦白说高刷新率除了打游戏外，基本没什么luan用，还会增加功耗。 苹果WWDC2017小结：中国式的系统升级 3. 性能方面采用A10X六核处理器，性能提升30%，图像性能提升40%。前置700万+后置1200万摄像头，可以使用USB C接口充电器。价格方面649美刀起售，今天能够预定，下周发货。iPad Pro今年秋季也会升级到IOS11。 4. iOS 11在iPad上加入MAC上的DOCK功能;截屏功能现在支持编辑;点击Apple Pencil上按钮点击后直接进入“笔记”应用，支持摄像头文档扫描。 苹果HomePod相关 1. 苹果音箱HomePod发布，支持各种音效. 声场混合调节，和Apple Music配合还能满足音乐发烧友要求。 2. 通过HomePod内置的6个麦克风可以唤醒Siri功能。默认下，在家里只要喊一声“Hey Siri”就可以HomePod自动播放音乐。 3. HomePod的价格为349美刀，拥有白色和黑色版，今年12月在美国. 英国. 澳大利亚上市。 4. 主持人表示，如果在家里觉得一个HomePod的音效满足不了你，那就买两个。]]></content>
      <categories>
        <category>WWDC</category>
      </categories>
      <tags>
        <tag>WWDC</tag>
        <tag>2017</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift3——Swift3中的Runtime]]></title>
    <url>%2F2017%2F05%2F25%2FSwift3%E2%80%94%E2%80%94Swift3%E4%B8%AD%E7%9A%84Runtime%2F</url>
    <content type="text"><![CDATA[记得学习OC的时候直到第二年才开始接触到Runtime，之前一直都是基础，UI，项目的简单开发，当我真正接触Runtime的时候，有种相见恨晚的感觉，之后再项目中也有经常使用到相关技术，当然15年开始Runtime在面试中也变得非常重要了…… Swift3 Runtime纯Swift类没有动态性，但在方法、属性前添加dynamic修饰可以获得动态性。 Runtime是一套比较底层的纯C语言的API,属于C语言库, 包含了很多底层的C语言API。在我们平时编写的iOS代码中, 最终都是转成了runtime的C语言代码。 所谓运行时，也就是在编译时是不存在的，只是在运行过程中才去确定对象的类型、方法等。利用Runtime机制可以在程序运行时动态修改类、对象中的所有属性、方法等。 还记得我们在网络请求数据处理时，调用了-setValuesForKeysWithDictionary:方法来设置模型的值。这里什么原理呢？为什么能这么做？其实就是通过Runtime机制来完成的，内部会遍历模型类的所有属性名，然后设置与key对应的属性名的值。 我们在使用运行时的地方，都需要包含头文件：#import &lt;objc/runtime.h&gt;。如果是Swift就不需要包含头文件，就可以直接使用了。 Swift中如何使用runtimeSwift代码中已经没有了Objective-C的运行时消息机制, 在代码编译时即确定了其实际调用的方法. 所以纯粹的Swift类和对象没有办法使用runtime, 更不存在method swizzling. 为了兼容Objective-C, 凡是继承NSObject的类都会保留其动态性, 依然遵循Objective-C的运行时消息机制, 因此可以通过runtime获取其属性和方法, 实现method swizzling. 获取对象所有属性名利用运行时获取对象的所有属性名是可以的，但是变量名获取就得用另外的方法了。我们可以通过class_copyPropertyList方法获取所有的属性名称。 对于Swift版，使用C语言的指针就不容易了，因为Swift希望尽可能减少C语言的指针的直接使用，因此在Swift中已经提供了相应的结构体封装了C语言的指针。但是看起来好复杂，使用起来好麻烦。看看Swift版的获取类的属性名称如何做： class Person: NSObject { var name: String = &quot;&quot; var hasBMW = false override init() { super.init() } func allProperties() -&gt;[String] { // 这个类型可以使用CUnsignedInt,对应Swift中的UInt32 var count: UInt32 = 0 let properties = class_copyPropertyList(Person.self, &amp;count) var propertyNames: [String] = [] // Swift中类型是严格检查的，必须转换成同一类型 for var i = 0; i &lt; Int(count); ++i { // UnsafeMutablePointer&lt;objc_property_t&gt;是 // 可变指针，因此properties就是类似数组一样，可以 // 通过下标获取 let property = properties[i] let name = property_getName(property) // 这里还得转换成字符串 let strName = String.fromCString(name); propertyNames.append(strName!); } // 不要忘记释放内存，否则C语言的指针很容易成野指针的 free(properties) return propertyNames; } } 测试一下是否获取正确： let p = Person() p.name = &quot;Lili&quot; // 打印结果：[&quot;name&quot;, &quot;hasBMW&quot;]，说明成功 p.allProperties() 获取对象的所有属性名和属性值对于获取对象的所有属性名，在上面的-allProperties方法已经可以拿到了，但是并没有处理获取属性值，下面的方法就是可以获取属性名和属性值，将属性名作为key，属性值作为value func allPropertyNamesAndValues() -&gt;[String: AnyObject] { var count: UInt32 = 0 let properties = class_copyPropertyList(Person.self, &amp;count) var resultDict: [String: AnyObject] = [:] for var i = 0; i &lt; Int(count); ++i { let property = properties[i] // 取得属性名 let name = property_getName(property) if let propertyName = String.fromCString(name) { // 取得属性值 if let propertyValue = self.valueForKey(propertyName) { resultDict[propertyName] = propertyValue } } } return resultDict } 测试一下： let dict = p.allPropertyNamesAndValues() for (propertyName, propertyValue) in dict.enumerate() { print(&quot;propertyName: (propertyName), propertyValue: (propertyValue)&quot;) } 打印结果与上面的一样，由于array属性的值为nil，因此不会处理。 propertyName: 0, propertyValue: (“name”, Lili) 获取对象的所有方法名通过class_copyMethodList方法就可以获取所有的方法。 func allMethods() { var count: UInt32 = 0 let methods = class_copyMethodList(Person.self, &amp;count) for var i = 0; i &lt; Int(count); ++i { let method = methods[i] let sel = method_getName(method) let methodName = sel_getName(sel) let argument = method_getNumberOfArguments(method) print(&quot;name: (methodName), arguemtns: (argument)&quot;) } } 测试一下调用： p.allMethods() 获取对象的成员变量名称要获取对象的成员变量，可以通过class_copyIvarList方法来获取，通过ivar_getName来获取成员变量的名称。对于属性，会自动生成一个成员变量。 Swift的成员变量名与属性名是一样的，不会生成下划线的成员变量名，这一点与Oc是有区别的。 func allMemberVariables() -&gt;[String] { var count:UInt32 = 0 let ivars = class_copyIvarList(Person.self, &amp;count) var result: [String] = [] for var i = 0; i &lt; Int(count); ++i { let ivar = ivars[i] let name = ivar_getName(ivar) if let varName = String.fromCString(name) { result.append(varName) } } return result } 测试一下： let array = p.allMemberVariables() for varName in array { print(varName) } 打印结果，说明Swift的属性不会自动加下划线，属性名就是变量名： name array 运行时发消息iOS中，可以在运行时发送消息，让接收消息者执行对应的动作。可以使用objc_msgSend方法，发送消息。 很抱歉，似乎在Swift中已经没有这种写法了。如果有，请告诉我。 Category扩展”属性”iOS的category是不能扩展存储属性的，但是我们可以通过运行时关联来扩展“属性”。 Swift版的要想扩展闭包，就比OC版的要复杂得多了。这里只是例子，写了一个简单的存储属性扩展。 let s_HYBFullnameKey = &quot;s_HYBFullnameKey&quot; extension Person { var fullName: String? { get { return objc_getAssociatedObject(self, s_HYBFullnameKey) as? String } set { objc_setAssociatedObject(self, s_HYBFullnameKey, newValue, .OBJC_ASSOCIATION_COPY_NONATOMIC) } } } Objective-C Category 可以随意重写本类的方法, Swift的Extension虽然易用, 但仍然没有Category那样方便的重写方法. Swizzle还是可以在Extension替换掉本类的任意方法. (Swift修改CocoaPods管理的第三库福音) 目前Swift3对于这个并不友好. Swift调用方法的时候是直接访问内存, 而不是在运行时查找地址, 意味着普通的方法, 你需要在方法前加dynamic修饰字, 告诉编译器跳过优化而是转发. 否则你是拦截不到方法.(注:viewDidLoad等方法不用加daynamic也可以截取到方法) class Swizzler { dynamic func originalFunction() -&gt; String { return &quot;Original function&quot; } dynamic func swizzledFunction() -&gt; String { return &quot;Swizzled function&quot; } } let swizzler = Swizzler() print(swizzler.originalFunction()) // prints: &quot;Original function&quot; let classToModify = Swizzler.self let originalMethod = class_getInstanceMethod(classToModify, #selector(Swizzler.originalFunction)) let swizzledMethod = class_getInstanceMethod(classToModify, #selector(Swizzler.swizzledFunction)) method_exchangeImplementations(originalMethod, swizzledMethod) print(swizzler.originalFunction()) // prints: &quot;Swizzled function&quot; 在开发中，我们比较常用的是使用关联属性的方式来扩展我们的“属性”，以便在开发中简单代码。我们在开发中使用关联属性扩展所有响应事件、将代理转换成block版等。比如，我们可以将所有继承于UIControl的控件，都拥有block版的点击响应，那么我们就可以给UIControl扩展一个TouchUp、TouchDown、TouchOut的block等。 对于动态获取属性的名称、属性值使用较多的地方一般是在使用第三方库中，比如MJExtension等。这些三方库都是通过这种方式将Model转换成字典，或者将字典转换成Model。 这里, 要注意Swift的代码与Objective-C代码的语法区别.同时, 对于一般OC代码的method swizzling, 在load方法中执行即可. 而Swift没有load, 所以要在initialize中执行. 使用方式: btn.cs_accpetEventInterval = 1.0 Swift中的@objc和dynamic关键字继承自NSObject的类都遵循runtime, 那么纯粹的Swift类呢? 在属性和方法之前加上@objc关键字, 则一般情况下可以在runtime中使用了. 但有一些情况下, Swift会做静态优化而无法使用runtime. 要想完全使得属性和方法被动态调用, 必须使用dynamic关键字. 而dynamic关键字会隐式地加上@objc来修饰. 获取Swift类的runtime信息的方法, 要加上Swift模块名: id cls = objc_getClass(&quot;DemoSwift.MySwiftClass&quot;)]]></content>
      <categories>
        <category>Swift3</category>
      </categories>
      <tags>
        <tag>Swift3</tag>
        <tag>Swift3中的Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift3——Swift内存管理]]></title>
    <url>%2F2017%2F05%2F23%2FSwift3%E2%80%94%E2%80%94Swift%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[记得学习OC的前期时候内存管理一直是个过不去的坑，虽然我是从ARC开始学起的，但是不管面试，实际开发中特殊问题，还是一些开源的项目大部分还是使用的MRC，导师还是遇到不少的困难，那么Swift重内存管理又是怎样的呢…… 作为一种现代化高级编程语言，Swift为您的应用程序中的分配、释放等内存管理需求提供强有力的支持。它使用的是一种称为自动化引用计数（ARC）的技术。通过本文的学习，你将通过以下内容进一步提升你的Swift开发中的ARC编程水平： 1.分配（从堆栈或堆中分配内存） 2.初始化（init代码运行） 3.使用（使用对象） 4.析构（deinit代码运行） 5.释放（内存又回到了堆栈或堆） 虽然没有直接的钩子技术埋伏到内存分配和内存回收中，但是您可以在init和deinit方法中 使用print语句作为代理手段来监控上述过程。注意，尽管上面过程4和5中的释放和析构两个方法常常交替使用，但实际上它们是在一个对象的生命周期中的两个不同的阶段。 引用计数是当不再需要对象时被释放的机制。这里的问题是：“你何时可以肯定未来不会需要这个对象？”通过保持一个使用次数的统计计数，即“引用计数”即可实现这一管理目的。引用计数存储于每一个对象实例内部。 上面的计数能够确定，有多少“东西”引用了对象。当一个对象的引用计数降为零时，也就是说对象的客户端不再存在；于是，对象被析构和解除内存分配 ARC与GC很多人分不清ARC（Automatic Reference Counting，自动引用计数）跟GC（Garbage Collection，垃圾收集）的区别。其实“引用计数法”也算是一种GC策略，只不过我们现在提到GC的时候一般是指基于“标记－整理”策略的垃圾收集器，譬如主流的JVM（Java虚拟机）几乎都是采用“标记－整理”＋“分代收集”的策略来进行自动内存管理的。标记算法一般是从全局对象图的“根”出发进行可达性分析，对象的生死会被批量地标记出来，之后再在某个时间批量地释放死对象。显然，这是一种“全局＋延时”的管理策略。 而与之相对的，引用计数是一种“局部＋即时”的内存管理策略。它不需要全局的对象信息，一般每个被管理的对象都会跟一个引用计数器关联，这个计数器保存着当前对象被引用的次数，一旦创建一个新的引用指向该对象，引用计数就加1，每当指向该对象的某个引用失效引用计数就减1，直到引用计数为0，就立即释放该对象。使用引用计数法管理内存的语言也不止OC和Swift，还有诸如CPython之类的GC也是基于引用计数的。 早年OC是采用MRC（手动引用计数）的，当然其实现在也有人还在用，它跟ARC的主要区别在于它需要手动管理引用计数器，而ARC是自动管理的。所以其实MRC也不能让你直接释放对象的，只是控制引用罢了。 ARC的功能在每一次一个新的类实例被创建时ARC分配一块内存以存储信息 init() 关于实例类型和其值的信息存储在存储器中 当类实例不再需要它自动由 deinit() 释放，用于进一步类实例的存储和检索的存储空间 ARC保存在磁道当前参照类实例的属性，常量和变量，使得 deinit() 仅适用于那些不使用的实例。 ARC维护“强引用”这些类实例属性，常量和变量来限制释放当当前的类实例正在使用。 Swift中内存管理包括哪些呢？1、内存管理，weak和unowned 2、@autoreleasepool 3、C 指针内存管理 1、内存管理，weak和unowned1.Swift中的unowned等效于OC中的unsafe_unretained，而Swift中的weak就是OC中的weak。如果能够确定在访问时不会已被释放，就尽量使用unowned；如果存在被释放的可能，那就选择用weak。 2.被标记为weak的变量一定需要是Optional值。 3.闭包和循环引用 lazy var printName: () —&gt; () = { [weak self] in if let strongSelf = self { print(“The name is \(strongSelf.name)”) } } //self持有闭包，闭包又持有self，循环引用。为了解决这种闭包内的循环引用，我们需要在闭包开始的时候添加一个标注，来表示这个闭包内的某些要素应该以何种特定的方式来使用，比如像这里的[weak self]。 这种在闭包参数的位置进行标注的语法结构是将要标注的内容放在原来参数的前面，并使用括号括起来。如果有多个需要标注的元素的话，在同一个中括号内用逗号隔开。 { [unowned self, weak someObject] (number: Int) —&gt; Bool in //…… return true } 2、@autoreleasepoolSwift中的自动释放池的创建语法： autoreleasepool { let data = NSData.dataWithContentsOfFile(path, options: nil, error: nil) //dataWithContentsOfFile返回的autorelease对象。在Swift中更提倡的是用初始化方法而不是用像上面那样的类方法来生成对象，而且从Swift 1.1开始，因为加入了可以返回nil的初始化方法，像上面例子中那样的工厂方法都已经从API中删除了。 } let data = NSData(contentsOfFile: path) //使用初始化方法的话，我们就不需要面临自动释放的问题了，每次在超过作用域后，自动内存管理都将为我们处理好内存相关的事情。 3、C 指针内存管理在Swift中C指针的内存需要自己手动管理。 class Employee { ① var no : Int var name : String var job : String var salary : Double init(no : Int, name: String, job : String, salary : Double) { ② self.no = no self.name = name self.job = job self.salary = salary println(&quot;员工\(name) 已经构造成功。&quot;) ③ } deinit { ④ println(&quot;员工\(name) 已经析构成功。&quot;) ⑤ } } var ref1: Employee? ⑥ var ref2: Employee? ⑦ var ref3: Employee? ⑧ ref1 = Employee(no: 7698, name: &quot;Blake&quot;, job :&quot;Salesman&quot;, salary : 1600) ⑨ ref2 = ref1 ⑩ ref3 = ref1 ⑪ ref1 = nil ⑫ ref2 = nil ⑬ ref3 = nil ⑭ 代码解释上述代码第①行声明了Employee类，第②行代码是定义构造器，在构造器中初始化存储属性，并且在代码第③行输出构造成功信息。第④行代码是定义析构器，并在代码第⑤行输出析构成功信息。 代码第⑥~⑧行是声明3个Employee类型变量，这个时候还没有创建Employee对象分配内存空间。代码第⑨行是真正创建Employee对象分配内存空间，并把对象的引用分配给ref1变量，ref1与对象建立“强引用”关系，“强引用”关系能够保证对象在内存中不被释放，这时候它的引用计数是1。第⑩行代码ref2 = ref1是将对象的引用分配给ref2，ref2也与对象建立“强引用”关系，这时候它的引用计数是2。第⑪行代码ref3 = ref1是将对象的引用分配给ref3，ref3也与对象建立“强引用”关系，这时候它的引用计数是3。 然后在代码第⑫行通过ref1 = nil语句断开ref1对Employee对象的引用，这时候它的引用计数是2。以此类推，ref2 = nil时它的引用计数是1，ref3 = nil时它的引用计数是0，当引用计数为0的时候Employee对象被释放。 我们可以测试一下看看效果，如果设置断点单步调试，会发现代码运行完第⑨行后控制台输出： 员工Blake 已经构造成功。 析构器输出的内容直到运行完第⑭行代码才输出： 员工Blake 已经析构成功。 这说明只有在引用计数为0的情况下才调用析构器，释放对象。 在 Swift 中，对引用描述的关键字有三个：strong，weak 和 unowned，所有的引用没有特殊说明都是 strong 强引用类型。在 ARC 中，只有指向一个实例的所有 strong 强引用都断开了，这个实例才会被销毁。 循环强引用（Strong Reference Cycles）但是，在某些情况下，一个类实例的强引用数永远不能变为 0，例如两个类实例互相持有对方的强引用，因而每个类实例都让对方一直存在，这就是所谓的强引用循环（Strong Reference Cycles）。 什么时候使用 weak？当两个实例是 optional 关联在一起时，确保其中的一个使用 weak 弱引用，就像上面所说的那个例子一样。 unowned 无主引用在某些情况下，声明的变量总是有值得时候，我们需要使用 unowned 无主引用。 什么时候使用 unowned 无主引用？两个实例 A 和 B，如果实例 A 必须在实例 B 存在的前提下才能存在，那么实例 A 必须用 unowned 无主引用指向实例 B。也就是说，有强制依赖性的那个实例必须对另一个实例持有无主引用。 例如上面那个例子所说，银行客户可能没有信用卡，但是每张信用卡总是绑定着一个银行客户，所以信用卡这个类就需要用 unowned 无主引用。 无主引用以及隐市解析可选属性 还有一种情况，两个属性都必须有值，并且初始化完成之后永远不会为 nil。在这种情况下，需要一个类使用 unowned 无主引用，另一个类使用隐式解析可选属性。闭包引起的循环强引用 在 Swift 中，闭包和函数都属于引用类型。并且闭包还有一个特性：可以在其定义的上下文中捕获常量或者变量。所以，在一个类中，闭包被赋值给了一个属性，而这个闭包又使用了这个类的实例的时候，就会引起循环强引用。 Swift 提供了一种方法来解决这个问题：闭包捕获列表（closure capture list）。在定义闭包的同时定义捕获列表作为闭包的一部分，捕获列表定义了闭包体内捕获一个或者多个引用类型的规则。跟解决两个类实例之间的循环强引用一样，声明每个捕获的引用为弱引用或者无主引用。 捕获列表中的每一项都由一对元素组成，一个元素是 weak 或者 unowned 关键字，另一个元素是类实例的引用（例如最常见得是 self），这些在方括号内用逗号隔开。 何时使用 weak，何时使用 unowned在闭包和捕获的实例总是相互引用并且总是同时销毁的时候，将闭包内的捕获定义为 unowned 无主引用。 在被捕获的实例可能变成 nil 的情况下，使用 weak 弱引用。如果被捕获的引用绝对不会变成 nil，应该使用 unowned 无主引用，而不是 weak 弱引用。Garbage Collection（GC，垃圾回收） 其实 ARC 应该也算 GC 的一种，不过我们一谈到 GC，大多都会想到 Java 中的垃圾回收机制，相比较 GC，ARC 简单得许多。以后有机会可以讨论一下 Java 中的内存管理。 另外，需要注意的一点是，这里所讲的都是针对于引用类型，结构体和枚举在 Swift 中属于值类型，不在 ARC 的考虑范围之内。 Swift内存管理机制总结swift同样使用自动计数（ARC）会制动释放内存。swift有3种引用方式： 在实例的生命周期中，如果某些时候引用没有值，那么弱引用可以阻止强引用环。如果整个生命周期内引用都有值，那么相应的用无主引用， 强引用 会增加实例的引用计数。 弱引用 弱引用不会增加实例的引用计数，因此不会阻止ARC销毁被引用的实例。这种特性使得引用不会变成强引用环。声明属性或者变量的时候，关键字weak表明引用为弱引用 无主引用 和弱引用相似，无主引用也不强持有实例。但是和弱引用不同的是，无主引用默认始终有值。 最后贴上一段使用的demo import UIKit class Person: NSObject { var name: String? var age: Int? // block 可能的循环引用 var block: ((Void)-&gt;Void)? = nil override init() { super.init() // weak 只能修改变量 ，其值在运行期间会被修改 // 闭包造成的循环引用([unowned self, weak delegate = self.delegate] 无主引用解决这个问题) // 遇见代理的时候我们还需要weak来修饰。注意内存泄漏 weak var weakself = self; self.block = { [unowned self] in weakself?.name = &quot;修改&quot;; } self.block!() } deinit { // 动态绑定， 因为第51行(p3)创建出来的对象没有name, self.name强制拆包会崩溃 if let name = self.name { print(name + &quot;被解放了&quot;); } } } class ViewController: UIViewController { var name: String? override func viewDidLoad() { super.viewDidLoad() // 引用计数 var p = Person() // 0 －&gt; 1 p.name = &quot;小王&quot; var p1 = p // 1 -&gt; 2 var p2 = p // 2 -&gt; 3 // 因为类型不匹配，无法赋值nil. 只能修改指针的指向让p释放 let p3 = Person() p1 = p3 // 3 -&gt; 2 p2 = p3 // 2 -&gt; 1 p = p3 } // 两个类相互引用 // var stu = student() // var tea = teachet() // tea.student = stu // student.tea = tea override func didReceiveMemoryWarning() { super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. } /* 对于闭包内的引用，何时使用弱引用，何时使用无主引用呢？ 如果在一个值的生命周期中可能没有值，我们就使用weak，weak可选 ,weak必须被申明为变量，在运行时可能被修改 如果一只值在生命周期一只有值，我们使用无主引用 , 无主是非可选类型 ，非可选类型不能赋值为nil */ }]]></content>
      <categories>
        <category>Swift3</category>
      </categories>
      <tags>
        <tag>Swift3</tag>
        <tag>Swift内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift3——Swift从入门到入门]]></title>
    <url>%2F2017%2F05%2F20%2FSwift3%E2%80%94%E2%80%94Swift%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[自从14年Swift出来之后，苹果就一直保持对它的快速更新与迭代，也正是因为这样，导致我们几乎是每年学习一门语言，从1.0到2.0，再从2.0到3.0…… 至于Swift1，Swift2的东西，这里就说这没撒说的了，有很多即使还是一样的知识点，但是用到3里面还是不是你当初所了解的哪有，所以…… 之前 Apple 在 WWDC 上已将 Swift 3 整合进了 Xcode 8 beta 中，而本月苹果发布了 Swift 3 的正式版。这也是自 2015 年底Apple开源Swift之后，首个发布的主要版本（Swift 3.0），该版本实现了 Swift 演变过程中所讨论并通过的90多个提议。这里我对 Swift 3 的新特性、新变化进行一个总结。 原文:Swift - Swift 3 新特性汇总（不同于以往版本的新变化） 语法列表： 学习笔记： 由于Swift是开源的，所以关于这门语言所有的更新内容可以从GitHub上找到详细的解释。 Swift 3改变可以分为四个大的部分1. 移除在Swift 2.2中弃用的方法 2. Swift 3 的新特性 3. 一些语法的修改 4. 语言更加安全，优雅（正确的废话） 特性http://www.jianshu.com/p/ca8e05150068http://www.tuicool.com/articles/NVJryi6 一、彻底移除在 Swift 2.2 就已经弃用的特性这些特性在我们使用 Xcode 7.3 的时候就已经有告警提示，在 Swift 3 中已将其彻底移出。 1，弃用 ++ 与 – 操作符过去我们可以使用 ++ 与 – 操作符来实现自增自减，现已废弃。 var i = 0 i++ ++i i-- --i 可以使用复合加法运算（+=）与减法运算（-=），或者使用普通的加法运算（+）与减法运算（-）实现同样的功能。 //使用复合加法运算（+=）与减法运算（-=） var i = 0 i += 1 i -= 1 //使用普通的加法运算（+）与减法运算（-） i = i + 1 i = i - 1 2，废除C语言风格的for循环我们过去可能习惯下面风格的 for 循环，现在也已废弃。 for var i=1; i&lt;100; i++ { print(&quot;\(i)&quot;) } 现在可以使用 for-in 循环，或者使用 for-each 加闭包的写法实现同样的功能。 //for-in循环 for i in 1...10 { print(i) } //for-each循环 (1...10).forEach { print($0) } 3，移除函数参数的 var 标记在 Swift 函数中，参数默认是常量。过去可以在参数前加关键字 var 将其定义为变量，这样函数内部就可以对该参数进行修改（外部的参数任然不会被修改）。 var age = 22 add(age) func add(var age:Int) { age += 1 } 现在这种做法已经被废弃，Swift 3 不再允许开发者这样来将参数标记为变量了。 4，所有函数参数都必须带上标签过去如果一个函数有多个参数，调用的时候第一个参数无需带标签，而从第二个参数开始，必须要带标签。 let number = additive(8, b: 12) func additive(a:Int, b:Int) -&gt; Int{ return a + b } 现在为了确保函数参数标签的一致性，所有参数都必须带上标签。 let number = additive(a: 8, b: 12) func additive(a:Int, b:Int) -&gt; Int{ return a + b } 这个变化可能会造成我们的项目代码要进行较大的改动，毕竟涉及的地方很多。所以苹果又给出了一种不用给第一个参数带标签的解决方案。即在第一个参数前面加上一个下划线。（不过这个只是方便我们代码从 Swift2 迁移到 Swift3 的一个折中方案，可以的话还是建议将所有的参数都带上标签。） let number = additive(8, b: 12) func additive(_ a:Int, b:Int) -&gt; Int{ return a + b } 5，函数声明和函数调用都需要括号来包括参数我们可以使用函数类型作为参数 ，对于一个参数是函数、返回值也是函数的函数。原来我们可能会这么写： func g(a: Int -&gt; Int) -&gt; Int-&gt;Int { ... } 当这样非常难以阅读，很难看出参数在哪里结束，返回值又从哪里开始。在 Swift 3 中变成这么定义这个函数： func g(a:(Int) -&gt; Int) -&gt; (Int) -&gt; Int { ... } 6，Selector 不再允许使用 String假设我们给按钮添加一个点击事件响应，点击后执行 tapped 函数。以前可以这么写： button.addTarget(responder, action: &quot;tapped&quot;, forControlEvents: .TouchUpInside) 但由于按钮的 selector 写的是字符串。如果字符串拼写错了，那程序会在运行时因找不到相关方法而崩溃。所以 Swift 3 将这种写法废除，改成 #selecor()。这样就将允许编译器提前检查方法名的拼写问题，而不用再等到运行时才发现问题。 button.addTarget(self, action:#selector(tapped), for:.touchUpInside) 二、Swift 3 的新特性1，内联序列函数sequenceSwift 3 新增了两个全局函数：sequence(first: next:) 和 sequence(state: next:)。使用它们可以返回一个无限序列。下面是一个简单的使用样例，更详细的介绍可以关注我后续的文章。 // 从某一个树节点一直向上遍历到根节点 for node in sequence(first: leaf, next: { $0.parent }) { // node is leaf, then leaf.parent, then leaf.parent.parent, etc. } // 遍历出所有的2的n次方数（不考虑溢出） for value in sequence(first: 1, next: { $0 * 2 }) { // value is 1, then 2, then 4, then 8, etc. } 2， key-path不再只能使用String这个是用在键值编码（KVC）与键值观察（KVO）上的，具体 KVC、KVO 相关内容可以参考我原来写的这篇文章：Swift - 反射（Reflection）的介绍与使用样例（附KVC介绍）我们还是可以继续使用 String 类型的 key-Path： //用户类 class User: NSObject{ var name:String = &quot;&quot; //姓名 var age:Int = 0 //年龄 } //创建一个User实例对象 let user1 = User() user1.name = &quot;hangge&quot; user1.age = 100 //使用KVC取值 let name = user1.value(forKey: &quot;name&quot;) print(name) //使用KVC赋值 user1.setValue(&quot;hangge.com&quot;, forKey: &quot;name&quot;) 但建议使用新增的 #keyPath() 写法，这样可以避免我们因为拼写错误而引发问题。 //使用KVC取值 let name = user1.value(forKeyPath: #keyPath(User.name)) print(name) //使用KVC赋值 user1.setValue(&quot;hangge.com&quot;, forKeyPath: #keyPath(User.name)) 3，Foundation 去掉 NS 前缀比如过去我们使用 Foundation 相关类来对文件中的 JSON 数据进行解析，这么写： let file = NSBundle.mainBundle().pathForResource(&quot;tutorials&quot;, ofType: &quot;json&quot;) let url = NSURL(fileURLWithPath: file!) let data = NSData(contentsOfURL: url) let json = try! NSJSONSerialization.JSONObjectWithData(data!, options: []) print(json) 在 Swift 3 中，将移除 NS 前缀，就变成了： let file = Bundle.main.path(forResource: &quot;tutorials&quot;, ofType: &quot;json&quot;) let url = URL(fileURLWithPath: file!) let data = try! Data(contentsOf: url) let json = try! JSONSerialization.jsonObject(with: data) print(json) 4，除了M_PI 还有 .pi在过去，我们使用 M_PI 常量来表示 π。所以根据半径求周长代码如下： let r = 3.0 let circumference = 2 * M_PI * r 在 Swift 3 中，π 提供了 Float，Double 与 CGFloat 三种形式（Float.pi、Double.pi、CGFloat.pi），所以求周长还可以这么写： let r = 3.0 let circumference = 2 * Double.pi * r //我们还可以将前缀省略，让其通过类型自动推断 let r = 3.0 let circumference = 2 * .pi * r 5，简化GCD的写法关于 GCD，我原来写过一篇相关文章：Swift - 多线程实现方式（3） - Grand Central Dispatch（GCD）过去写法采用 C 语言的风格，初学者可能会不大适应。比如创建一个简单的异步线程： let queue = dispatch_queue_create(&quot;Swift 2.2&quot;, nil) dispatch_async(queue) { print(&quot;Swift 2.2 queue&quot;) } Swift 3 取消了这种冗余的写法，而采用了更为面向对象的方式： let queue = DispatchQueue(label: &quot;Swift 3&quot;) queue.async { print(&quot;Swift 3 queue&quot;) } 6，Core Graphics的写法也更加面向对象化Core Graphics 是一个相当强大的绘图框架，但是和 GCD 一样，它原来的 API 也是 C 语言风格的。比如我们要创建一个 view，其内部背景使用 Core Graphics 进行绘制（红色边框，蓝色背景）。过去我们这么写： class View: UIView { override func drawRect(rect: CGRect) { let context = UIGraphicsGetCurrentContext() let blue = UIColor.blueColor().CGColor CGContextSetFillColorWithColor(context, blue) let red = UIColor.redColor().CGColor CGContextSetStrokeColorWithColor(context, red) CGContextSetLineWidth(context, 10) CGContextAddRect(context, frame) CGContextDrawPath(context, .FillStroke) } } let frame = CGRect(x: 0, y: 0, width: 100, height: 50) let aView = View(frame: frame) 在 Swift 3 中改进了写法，只要对当前画布上下文解包，之后的所有绘制操作就都基于解包对象。 class View: UIView { override func draw(_ rect: CGRect) { guard let context = UIGraphicsGetCurrentContext() else { return } let blue = UIColor.blue.cgColor context.setFillColor(blue) let red = UIColor.red.cgColor context.setStrokeColor(red) context.setLineWidth(10) context.addRect(frame) context.drawPath(using: .fillStroke) } } let frame = CGRect(x: 0, y: 0, width: 100, height: 50) let aView = View(frame: frame) 7，新增的访问控制关键字：fileprivate、open在 Swift 3 中在原有的 3 个访问控制关键字 private、public、internal 外。又添加了2个新关键字 fileprivate、open。它们可以看成是对原来 private 和 public 的进一步细分。具体使用方法和介绍可以关注我的后续文章。 三、一些语法的修改:Swift 3 的新特性1，数组排序：sort()与sorted()过去数组排序的两个方法：sortInPlace() 和 sort()，现在分别改名成 sort() 和 sorted()sort() 是直接对目标数组进行排序。sorted() 是返回一个排序后的数组，原数组不变。 var array1 = [1, 5, 3, 2, 4] array1.sort() print(array1) //[1, 2, 3, 4, 5] var array2 = [1, 5, 3, 2, 4] let sortedArray = array2.sorted() print(array2) //[1, 5, 3, 2, 4] print(sortedArray) //[1, 2, 3, 4, 5] 2，reversed()与enumerated()过去 reverse() 方法实现数组反转，enumerate() 方法实现遍历。现这两个方法都加上 ed 后缀（reversed、enumerated） for i in (1...10).reversed() { print(i) } let array = [1, 5, 3, 2, 4] for (index, value) in array.enumerated() { print(&quot;\(index + 1) \(value)&quot;) } 3，CGRect、CGPoint、CGSize过去的 CGRectMake、CGPointMake、CGSizeMake 已废弃。现改用 CGRect、CGPoint、CGSize 代替。 //Swift 2 let frame = CGRectMake(0, 0, 20, 20) let point = CGPointMake(0, 0) let size = CGSizeMake(20, 20) //Swift 3 let frame = CGRect(x: 0, y: 0, width: 20, height: 20) let point = CGPoint(x: 0, y: 0) let size = CGSize(width: 20, height: 20) 4，移除了API中多余的单词XCPlaygroundPage.currentPage 改为 PlaygroundPage.current button.setTitle(forState) 改为 button.setTitle(for) button.addTarget(action, forControlEvents) 改为 button.addTarget(action, for) arr.minElement() 改为 arr.min() arr.maxElement() 改为 arr.max() attributedString.appendAttributedString(anotherString) 改为 attributedString.append(anotherString) names.insert(&quot;Jane&quot;, atIndex: 0) 改为 names.insert(&quot;Jane&quot;, at: 0) NSBundle.mainBundle() 改为 Bundle.main UIDevice.currentDevice() 改为 UIDevice.current NSData(contentsOfURL) 改为 Data(contentsOf) NSJSONSerialization.JSONObjectWithData() 改为 JSONSerialization.jsonObject(with) UIColor.blueColor() 改为 UIColor.blue 5，枚举成员变成小写字母开头Swift 3 将枚举成员当做属性来看，所以现在使用小写字母开头而不是以前的大写字母。 .system //过去是：.System .touchUpInside //过去是：.TouchUpInside .fillStroke //过去是：.FillStroke .cgColor //过去是：.CGColor 6，@discardableResult在 Swift 3 中，如果一个方法有返回值。而调用的时候没有接收该方法的返回值，Xcode 会报出警告，告诉你这可能会存在潜在问题。 原文:Swift - Swift 3 新特性汇总（不同于以往版本的新变化） 除了可以通过接收返回值消除警告。还可以通过给方法声明 @discardableResult 来达到消除目的。 import UIKit class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() printMessage(message: &quot;Hello Swift 3!&quot;) } @discardableResult func printMessage(message: String) -&gt; String { let outputMessage = &quot;Output : \(message)&quot; return outputMessage } override func didReceiveMemoryWarning() { super.didReceiveMemoryWarning() } } 迁移的坑 官方资料]]></content>
      <categories>
        <category>Swift3</category>
      </categories>
      <tags>
        <tag>Swift3</tag>
        <tag>Swift从入门到入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin——和Swift像得一塌糊涂]]></title>
    <url>%2F2017%2F05%2F18%2Fkotlin%E2%80%94%E2%80%94%E5%92%8CSwift%E5%83%8F%E5%BE%97%E4%B8%80%E5%A1%8C%E7%B3%8A%E6%B6%82%2F</url>
    <content type="text"><![CDATA[今天大概看了一下网上关于Google I/O的详细内容，当然主要还是关于kotlin，随便找打之前的的小demo，突然又想到上周深圳的Swift大会，顿时感觉以后Swift和kotlin与占有很大一部分市场，就寻找了一份关于kotlin和Swift代码的异同之处，也好方便kotlin和Swift程序员区分与学习….. | | | 下面是一些关于Swift和Kotlin语法和细节上的区别，出自网络！ Hello WorldSwiftprint(&quot;Hello, world!&quot;) kotlinprintln(&quot;Hello, world!&quot;) Variables And ConstantsSwiftvar myVariable = 42 myVariable = 50 let myConstant = 42 kotlinvar myVariable = 42 myVariable = 50 val myConstant = 42 Explicit TypesSwiftlet explicitDouble: Double = 70 kotlinval explicitDouble: Double = 70.0 Type CoercionSwiftlet label = &quot;The width is &quot; let width = 94 let widthLabel = label + String(width) kotlinval label = &quot;The width is &quot; val width = 94 val widthLabel = label + width String InterpolationSwiftlet apples = 3 let oranges = 5 let fruitSummary = &quot;I have \(apples + oranges) &quot; + &quot;pieces of fruit.&quot; kotlinval apples = 3 val oranges = 5 val fruitSummary = &quot;I have ${apples + oranges} &quot; + &quot;pieces of fruit.&quot; Range OperatorSwiftlet names = [&quot;Anna&quot;, &quot;Alex&quot;, &quot;Brian&quot;, &quot;Jack&quot;] let count = names.count for i in 0..&lt;count { print(&quot;Person \(i + 1) is called \(names[i])&quot;) } // Person 1 is called Anna // Person 2 is called Alex // Person 3 is called Brian // Person 4 is called Jack kotlinval names = arrayOf(&quot;Anna&quot;, &quot;Alex&quot;, &quot;Brian&quot;, &quot;Jack&quot;) val count = names.count() for (i in 0..count - 1) { println(&quot;Person ${i + 1} is called ${names[i]}&quot;) } // Person 1 is called Anna // Person 2 is called Alex // Person 3 is called Brian // Person 4 is called Jack Inclusive Range OperatorSwiftfor index in 1...5 { print(&quot;\(index) times 5 is \(index * 5)&quot;) } // 1 times 5 is 5 // 2 times 5 is 10 // 3 times 5 is 15 // 4 times 5 is 20 // 5 times 5 is 25 kotlinfor (index in 1..5) { println(&quot;$index times 5 is ${index * 5}&quot;) } // 1 times 5 is 5 // 2 times 5 is 10 // 3 times 5 is 15 // 4 times 5 is 20 // 5 times 5 is 25 ArraysSwiftvar shoppingList = [&quot;catfish&quot;, &quot;water&quot;, &quot;tulips&quot;, &quot;blue paint&quot;] shoppingList[1] = &quot;bottle of water&quot; ### kotlin val shoppingList = arrayOf(&quot;catfish&quot;, &quot;water&quot;, &quot;tulips&quot;, &quot;blue paint&quot;) shoppingList[1] = &quot;bottle of water&quot; MapsSwiftvar occupations = [ &quot;Malcolm&quot;: &quot;Captain&quot;, &quot;Kaylee&quot;: &quot;Mechanic&quot;, ] occupations[&quot;Jayne&quot;] = &quot;Public Relations&quot; kotlinval occupations = mutableMapOf( &quot;Malcolm&quot; to &quot;Captain&quot;, &quot;Kaylee&quot; to &quot;Mechanic&quot; ) occupations[&quot;Jayne&quot;] = &quot;Public Relations&quot; Empty CollectionsSwiftlet emptyArray = [String]() let emptyDictionary = [String: Float]() kotlinval emptyArray = arrayOf&lt;String&gt;() val emptyMap = mapOf&lt;String, Float&gt;() FunctionsSwiftfunc greet(_ name: String,_ day: String) -&gt; String { return &quot;Hello \(name), today is \(day).&quot; } greet(&quot;Bob&quot;, &quot;Tuesday&quot;) kotlinfun greet(name: String, day: String): String { return &quot;Hello $name, today is $day.&quot; } greet(&quot;Bob&quot;, &quot;Tuesday&quot;) Tuple ReturnSwiftfunc getGasPrices() -&gt; (Double, Double, Double) { return (3.59, 3.69, 3.79) } kotlindata class GasPrices(val a: Double, val b: Double, val c: Double) fun getGasPrices() = GasPrices(3.59, 3.69, 3.79) Variable Number Of ArgumentsSwiftfunc sumOf(_ numbers: Int...) -&gt; Int { var sum = 0 for number in numbers { sum += number } return sum } sumOf(42, 597, 12) kotlinfun sumOf(vararg numbers: Int): Int { var sum = 0 for (number in numbers) { sum += number } return sum } sumOf(42, 597, 12) // sumOf() can also be written in a shorter way: fun sumOf(vararg numbers: Int) = numbers.sum() Function TypeSwiftfunc makeIncrementer() -&gt; (Int -&gt; Int) { func addOne(number: Int) -&gt; Int { return 1 + number } return addOne } let increment = makeIncrementer() increment(7) kotlinfun makeIncrementer(): (Int) -&gt; Int { val addOne = fun(number: Int): Int { return 1 + number } return addOne } val increment = makeIncrementer() increment(7) // makeIncrementer can also be written in a shorter way: fun makeIncrementer() = fun(number: Int) = 1 + number MapSwiftlet numbers = [20, 19, 7, 12] numbers.map { 3 * $0 } kotlinval numbers = listOf(20, 19, 7, 12) numbers.map { 3 * it } Sort Swiftvar mutableArray = [1, 5, 3, 12, 2] mutableArray.sort() kotlinlistOf(1, 5, 3, 12, 2).sorted() Named ArgumentsSwiftfunc area(width: Int, height: Int) -&gt; Int { return width * height } area(width: 2, height: 3) kotlinfun area(width: Int, height: Int) = width * height area(width = 2, height = 3) // This is also possible with named arguments area(2, height = 2) area(height = 3, width = 2) DeclarationSwiftclass Shape { var numberOfSides = 0 func simpleDescription() -&gt; String { return &quot;A shape with \(numberOfSides) sides.&quot; } } kotlinclass Shape { var numberOfSides = 0 fun simpleDescription() = &quot;A shape with $numberOfSides sides.&quot; } UsageSwiftvar shape = Shape() shape.numberOfSides = 7 var shapeDescription = shape.simpleDescription() kotlinvar shape = Shape() shape.numberOfSides = 7 var shapeDescription = shape.simpleDescription() SubclassSwiftclass NamedShape { var numberOfSides: Int = 0 let name: String init(name: String) { self.name = name } func simpleDescription() -&gt; String { return &quot;A shape with \(numberOfSides) sides.&quot; } } class Square: NamedShape { var sideLength: Double init(sideLength: Double, name: String) { self.sideLength = sideLength super.init(name: name) self.numberOfSides = 4 } func area() -&gt; Double { return sideLength * sideLength } override func simpleDescription() -&gt; String { return &quot;A square with sides of length &quot; + sideLength + &quot;.&quot; } } let test = Square(sideLength: 5.2, name: &quot;square&quot;) test.area() test.simpleDescription() kotlinopen class NamedShape(val name: String) { var numberOfSides = 0 open fun simpleDescription() = &quot;A shape with $numberOfSides sides.&quot; } class Square(var sideLength: BigDecimal, name: String) : NamedShape(name) { init { numberOfSides = 4 } fun area() = sideLength.pow(2) override fun simpleDescription() = &quot;A square with sides of length $sideLength.&quot; } val test = Square(BigDecimal(&quot;5.2&quot;), &quot;square&quot;) test.area() test.simpleDescription() Checking TypeSwiftvar movieCount = 0 var songCount = 0 for item in library { if item is Movie { movieCount += 1 } else if item is Song { songCount += 1 } } kotlinvar movieCount = 0 var songCount = 0 for (item in library) { if (item is Movie) { ++movieCount } else if (item is Song) { ++songCount } } Pattern MatchingSwiftlet nb = 42 switch nb { case 0...7, 8, 9: print(&quot;single digit&quot;) case 10: print(&quot;double digits&quot;) case 11...99: print(&quot;double digits&quot;) case 100...999: print(&quot;triple digits&quot;) default: print(&quot;four or more digits&quot;) } kotlinval nb = 42 when (nb) { in 0..7, 8, 9 -&gt; println(&quot;single digit&quot;) 10 -&gt; println(&quot;double digits&quot;) in 11..99 -&gt; println(&quot;double digits&quot;) in 100..999 -&gt; println(&quot;triple digits&quot;) else -&gt; println(&quot;four or more digits&quot;) } DowncastingSwiftfor current in someObjects { if let movie = current as? Movie { print(&quot;Movie: &apos;\(movie.name)&apos;, &quot; + &quot;dir. \(movie.director)&quot;) } } kotlinfor (current in someObjects) { if (current is Movie) { println(&quot;Movie: &apos;${current.name}&apos;, &quot; + &quot;dir. ${current.director}&quot;) } } ProtocolSwiftprotocol Nameable { func name() -&gt; String } func f&lt;T: Nameable&gt;(x: T) { print(&quot;Name is &quot; + x.name()) } kotlininterface Nameable { fun name(): String } fun f&lt;T: Nameable&gt;(x: T) { println(&quot;Name is &quot; + x.name()) } Extensions### Swiftextension Double { var km: Double { return self * 1_000.0 } var m: Double { return self } var cm: Double { return self / 100.0 } var mm: Double { return self / 1_000.0 } var ft: Double { return self / 3.28084 } } let oneInch = 25.4.mm print(&quot;One inch is \(oneInch) meters&quot;) // prints &quot;One inch is 0.0254 meters&quot; let threeFeet = 3.ft print(&quot;Three feet is \(threeFeet) meters&quot;) // prints &quot;Three feet is 0.914399970739201 meters&quot; kotlinval Double.km: Double get() = this * 1000 val Double.m: Double get() = this val Double.cm: Double get() = this / 100 val Double.mm: Double get() = this / 1000 val Double.ft: Double get() = this / 3.28084 val oneInch = 25.4.mm println(&quot;One inch is $oneInch meters&quot;) // prints &quot;One inch is 0.0254 meters&quot; val threeFeet = 3.0.ft println(&quot;Three feet is $threeFeet meters&quot;) // prints &quot;Three feet is 0.914399970739201 meters&quot;]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin——要火了❤️，你还在等什么？]]></title>
    <url>%2F2017%2F05%2F18%2Fkotlin%E2%80%94%E2%80%94%E8%A6%81%E7%81%AB%E4%BA%86%E2%9D%A4%EF%B8%8F%EF%BC%8C%E4%BD%A0%E8%BF%98%E5%9C%A8%E7%AD%89%E4%BB%80%E4%B9%88%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[其实在去年我就开发在了解Kotlin，只是由于项目的原因，还有一些人根本不知道他的存在，然后推荐给了不少人，都被否决了！ 百度发音：kotlin——科特林 前言： 今早睡一醒来打开手机一看，发现朋友圈被刷屏了！ 其实在去年我就开发在了解Kotlin，只是由于项目的原因，还有一些人根本不知道他的存在，然后推荐给了不少人，都被否决了！ kotlin要火了，昨晚的Google I/O大会，Google宣布正式其实kotlin。 这个小时对几乎所有Android的猿类来说，应该是最震惊的，为什么呢？ 因为你又有一门新的语言可以学习了，就像Swift对iOS程序员的意义意义！ 当然这个消息不仅对Android程序员比较震惊，对几乎所有做iOS开发的程序也是一个值得关注的消息？为什么呢？ 那你的问问Swift为什么和他长得这么像！ 先来看看昨晚Google I/O 2017有哪些亮点？TPU（用于深度学习的处理器） Google Lens （新API，摄像头直接支持图像识别） Google Assistan新功能 Google Home新功能 Google Photos新功能 Android支持分屏 Android支持Kotlin开发 Tango（AR）进展 Daydream（VR）进展 Google工作搜索 想了解更多请看官方发布视频与相关总结！ 有人用一句话总结AI已经无处不在了 这里是主要阐述kotlin的，上面两点中“Android支持Kotlin开发”也是我非常关注和值得开心的一件！ 所以，Let`s Go首先有任何想了解kotlin的，建议最好先看官方教程：http://kotlinlang.org/ Kotlin是什么Kotlin 是一个基于 JVM 的新的编程语言，由 JetBrains 开发。 Kotlin可以编译成Java字节码，也可以编译成JavaScript，方便在没有JVM的设备上运行。 JetBrains，作为目前广受欢迎的Java IDE IntelliJ 的提供商，在 Apache 许可下已经开源其Kotlin 编程语言。 众所周知Android程序是运行在Java虚拟机之上的，因此从技术上来说，可以运行在JVM之上的一切都可用于开发Android应用。现在已经有很多可以生成JVM能够执行的字节码的语言，其中一些语言开始崭露头角并逐步流行起来。现存的计算机编程语言有好几千种，JVM上的语言也有十几种(比如NBJL/Clojure/Groovy/Scala/Fantom)，所以大可不必为没听说过的编程语言感到惊奇,我也就听过Groovy/Scala/Kotlin，scala比较和C语言接近，而Groovy和java很相似你肯定对gradle不陌生吧，但是Kotlin就是其中的佼佼者。 近日召开的 Google IO 2017 ， Google 将 Kotlin 列为 Android 官方开发语言了，Android Studio 3.0 也默认集成了 Kotlin plugin kotlin的历史历史2011 年 7 月，JetBrains 推出 Kotlin 项目，这是一个面向 JVM 的新语言，它已被开发一年之久。JetBrains 负责人Dmitry Jemerov 说，大多数语言没有他们正在寻找的特性，Scala 除外，他指出了 Scala 的编译时间慢这一明显缺陷。Kotlin 的既定目标之一是像 Java 一样快速编译。 2012 年 2 月，JetBrains 以 Apache 2 许可证开源此项目，Jetbrains 希望这个新语言能够推动 IntelliJ IDEA 的销售。 Kotlin v1.0 于 2016 年 2 月 15 日发布。这被认为是第一个官方稳定版本，并且 JetBrains 已准备从该版本开始的长期向后兼容性。 在 Google I/O 2017 中，Google 宣布在 Android 上为 Kotlin 提供支持。 Kotlin设计的目的创建一种兼容Java的语言 让它比Java更安全，能够静态检测常见的陷阱。如：引用空指针 让它比Java更简洁，通过支持variable type inference，higher-order functions (closures)，extension functions，mixins and first-class delegation等实现。 让它比最成熟的竞争对手Scala语言更加简单 java的缺陷：对象可以赋值null造成NPE 受检异常(checked exception) 属性getter，setter太烦 接口不能有实现（java8 fixed） 缺乏Lambda(java8 fixed) 方法Overloading对可读性和动态调用造成伤害。 语言层缺乏模块化支持 并发支持很糟糕 原始类型不是对象&gt; Kotlin优势：创建一种兼容Java的语言 让它比Java更安全，能够静态检测常见的陷阱。如：引用空指针 让 它比Java更简洁，通过支持variable type inference，higher-order functions (closures)，extension functions，mixins and first-class delegation等实现。 语言特性轻量级： 这一点对于Android来说非常重要。项目所需要的库应该尽可能的小。Android对于方法数量有严格的限制，Kotlin只额外增加了大约6000个方法。 互操作： Kotlin可与Java语言无缝通信。这意味着我们可以在Kotlin代码中使用任何已有的Java库；因此，即便这门语言还很年轻，但却已经可以使用成百上千的库了。除此之外，Kotlin代码还可以为Java代码所用，这意味着我们可以使用这两种语言来构建软件。你可以使用Kotlin开发新特性，同时使用Java实现代码基的其他部分。 强类型： 我们很少需要在代码中指定类型，因为编译器可以在绝大多数情况下推断出变量或是函数返回值的类型。这样就能获得两个好处：简洁与安全。 Null安全： Java最大的一个问题就是null。如果没有对变量或是参数进行null判断，那么程序当中就有可能抛出大量的NullPointerException，然而在编码时这些又是难以检测到的。Kotlin使用了显式的null，这会强制我们在必要时进行null检查。 适用平台只要能用Java的地方就能用Kotlin， Kotlin支持所有主要的开发工具以及服务，比如： * IntelliJ IDEA、Android Studio和Eclipse； * Maven、Gradle和Ant； * spring Boot（Kotlin 支持今天正式发布！）； * GitHub，Slack，甚至Minecraft。 分类整理一下 Kotlin VS Java语法简单不啰嗦Kotlin的一个主要优点是它的简洁。 你用更少的代码获得更多的功能。 ① Kotlin 支持类型推断，没有 Java 那样的啰嗦。 ② 用 var 表示变量，val 表示常量更加的简洁 ③ 方法也很简单，连 function 都缩写成了 fun ④ 类的继承和实现很简单，使用:即可 ⑤ Kotlin 每个句子都不需要加分号 (;) 避免空指针异常在许多编程语言中最大的痛苦 - 空指针异常。 但是使用Kotlin，这个问题得到了很好的解决 ① 在类型上的处理，即在类型后面加上?，即表示这个变量或参数以及返回值可以为 null，否则不允许为变量参数赋值为 null 或者返回 null ② 对于一个可能是 null 的变量或者参数，在调用对象方法或者属性之前，需要加上?，否则编译无法通过。 支持方法拓展Kotlin有一个聪明的解决方案 - 扩展功能 ，帮助你摆脱所有的util类一劳永逸。扩展函数几乎是一个通常的Kotlin函数。 但是当你声明它，你需要指定的实例将具有扩展功能的类。 注意：Kotlin 的方法扩展并不是真正修改了对应的类文件，而是在编译器和 IDE 方面做得处理。使我们看起来像是扩展了方法。 高阶函数， 函数式编程支持所谓的高阶函数就是：可以接受函数作为参数，也可以返回函数作为结果。 Kotlin 支持了 Streams API 和方法引用，这样函数式编程更加方便。比如下面的代码就是我们结合 Jsoup，来抓取某个 proxy 网站的数据，代码更加简单，实现起来也快速。 关于性能Kotlin 的执行效率和 Java 代码的执行效率理论上一致的。有时候 Kotlin 可能会显得高一些。比如 Kotlin 提供了方法的 inline 设置，可以设置某些高频方法进行 inline 操作，减少了运行时的进栈出栈和保存状态的开销。 与Java互操作Kotlin 在设计时就考虑了 Java 互操作性。可以从 Kotlin 中自然地调用现存的 Java 代码，并且在 Java 代码中也可以 很顺利地调用 Kotlin 代码。 总结Kotlin的特性有很多，总的来说， Kotlin这门语言简化了Java , 完全是从一个是实用派的角度，而不是学院派的角度。 相比于JRuby , Jython这些一移植到JVM上的语言， Kotlin 和Java 和互操作感觉更加自然。 每个语言的流行都需要一个引爆点，就像Ruby on Rails 引爆了Ruby 一样， Android 也许就是之前不那么流行的Kotlin的引爆点。 这里有一篇不错的入门实战教程，非常简单：http://www.jianshu.com/p/cf1f96c56150 Kotlin这里就不说了，太乏味了，最后一句话总结一下kotlin Android届的Swift（请深刻理解其中的含义） 各位Android的同仁们，是时候了，不管是为了喜好还是为了以后的规划，你都应该停下手上的活，抽出一切空余时间进攻kotlin，相信我，不学你会后悔的，哈哈！当然有机会我也会去了解，接触一些kotlin开发的知识，哪怕我不会转到哪上面去，这就是我们所谓的广度优先！ 如果想简单入门kotlin语法和一些特点可以看这里：http://www.jianshu.com/p/1ea733ea197d 学习资源： 1.kotlin官方中文翻译文档网址 2.Kotlin官网 3.kotlin中文官网 4.kotlin的gitbook网址 在线学习 Kotlin官方文档]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
        <tag>Google I/O</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017@Swift——后感]]></title>
    <url>%2F2017%2F05%2F15%2F2017-Swift%E2%80%94%E2%80%94%E5%90%8E%E6%84%9F%2F</url>
    <content type="text"><![CDATA[2017@Swift——中国开发者大会（第二站） 会议时间：2017年5月13日-5月14日， 地址：深圳凯宾斯基酒店， 人数：400人 嘉宾：18人，其中8位国外，8位国内。 第一天所有外国嘉宾的演讲时间，第二天是国内大牛的演讲时间！ 记得第一站是去年在北京举行，当时项目太赶，就没有去，今年有幸能参加此次大会，并且收获真心不少。因此这里稍微整理了一下这两天最大的感触，和所学到的东西！ 当然关于技术的分享，后期会有专门的文章与结合简单的实战整理一并分享出来，敬请期待……. 更多信息请点2017@Swift——中国开发者大会,同时后面也会抽空整理一下会议中讲到的内容，底层，细节与实现，敬请期待！ 2017@Swift——后感 这种收获真不是一两句话或者一两篇文章就能说清楚的，如果你有事吗疑问或者想了解先关内容也可以直接关注我，联系我！ 第二届 @Swift 中国开发者大会 英语能力 交友 技术 英语为什么这里我把英语能力放在最前面，肯定是有原因的。 1. 开会第一天所有都是老外，所有人都直接用英语讲，几乎听不太懂，所以导致很多东西根本没有听到重点与细节 2. 会后交流，与提问，人家都能听懂，甚至都能提出自己的问题与观点，甚至还能通嘉宾进行更多更加升入的交流与讨论，而我却只能翻译或者发呆 3. 技术的学习，几乎所有的最好，最新的技术资料都是从英文开始的，当你开始看中文翻译资料或者开始研究的时候，人家已经换了一种技术 4. 后期的规划问题，出国旅游，出国发展（有点长远，当然也不是没有可能的），或者有机会接触外国朋友。 总结：针对程序员，哪怕只有一点基础的，技术这种东西都可以慢慢学，或者在实际项目中提高，如果你英文不好很多事情真的很难进行下去，除非你没有什么长远的目标或者没有自己个人的规划。 交友经过这次会议之后，看到了很多牛人，也认识了不少牛人之后才知道自己的渺小，才知道自己原来离期望中太远太远。 1. 最有名的Swift框架RXSwift的作者 2. Google工程师 3. 腾讯，美团，礼物说，阿里等一些非常厉害的架构师，同时也是技术迷 4. 不少技术书籍的作者，其中有一位是我非常喜欢的巧哥@唐巧 5. 不同公司的技术主管，开发人员，初入门的程序员 6. 两天的会议中认识到了不少来自去全国各地参会者，也结下了不少好友！ 总结：永远不要觉得自己多牛逼，当你真的看到牛人之后你就会发现，其实自己真的很low，哪怕你做过再多项目，写过再多代码，不思考，不提升依然是个菜鸟。 技术1. 主题就是Swift：iOS，后台肯定是重心 2. Swift实现AI，智能，机器学习，树莓派的结合，后期的转行。 3. 实现属于自己的东西，小的方向比如小框架，静态或者动态库，大的话其中有人自己写了一个Swift转H5的编译器 4. App性能的提升，多线程，锁，MVVM, 自动化（测试，脚本） 5. 包括开发，集成，测试，发布，维护需要有一套完成的规范与流程。 总之，程序员是一个需要时刻保持学习的职业，不学你就将被淘汰，不管学习技术，管理，社交，英语或者学习别人成功或失败的经验 未来的路还很长，希望一路上的坎坷能让我足够强大。 说说我接下来的规划（我只谈短期1-2年）： 1. 学习英语，不管是自学还是报班这都是现阶段最最最重要的任务,同时也会长期的坚持下去。 2. 着手Swift进行项目实战，对PHP实战后台开发进一步的提升，同时去了解Swift实现后台开发 3. iOS深挖：深入解析Max OS X &amp; iOS操作系统 4. 学习Python，了解机器学习等技术]]></content>
      <categories>
        <category>2017@Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>大会后感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017@Swift——中国开发者大会（第二天）]]></title>
    <url>%2F2017%2F05%2F15%2F2017-Swift%E2%80%94%E2%80%94%E4%B8%AD%E5%9B%BD%E5%BC%80%E5%8F%91%E8%80%85%E5%A4%A7%E4%BC%9A%EF%BC%88%E7%AC%AC%E4%BA%8C%E5%A4%A9%EF%BC%89%2F</url>
    <content type="text"><![CDATA[首先介绍一下会议信息 会议时间：2017年5月13日-5月14日， 地址：深圳凯宾斯基酒店， 人数：400人 嘉宾：18人，其中8位国外，8位国内。 第一天所有外国嘉宾的演讲时间，第二天是国内大牛的演讲时间！ 更多信息请点2017@Swift——中国开发者大会,同时后面也会抽空整理一下会议中讲到的内容，底层，细节与实现，敬请期待！ ============================================================================= 唐巧（小猿搜题产品技术负责人）Richards 和 Deltablue 是衡量语言运算速度的两个主流的评测代码。Swift 在这两个评测中，显示出远超 Objective-C 的性能。特别是 Richards 评测，Swift 比 Objective-C 快了 4 倍。那么，为什么 Swift 这么快呢？本次分享，我将从编译器优化，内存分配优化，引用计数优化，方法调用优化，面向协议编程的实现细节等方面来介绍 Swift 在性能上所做的努力。如果可能，我们也会一起看看编译器处理后的源码，加深我们对于这些优化的理解。 小猿搜题产品技术负责人，资深 iOS 开发者，曾开发过网易邮箱、网易微博、有道云笔记、猿题库、小猿搜题。喜欢写作和分享，维护着中国关注者最多的iOS领域的微信公众号「iOS开发by唐巧」，产出了超过 100 篇原创的 iOS 技术文章，出版了一本 iOS 进阶读物《iOS开发进阶》。 Swift 为什么这么快1. 第二天中，唯一一个使用英文演讲的国内大牛，挑战自我。 2. 从不同方便说明为什么swift比OC好：引用数，struct的内存布局，性能优化，编译器、内存、消息转发机制、引用数和protocol。 ============================================================================= 戴铭（滴滴出行技术专家） github.com/ming1016 结合实例介绍如何用 LLVM IR 中间语言和编译前端的语法解析来设计一门简洁易用支持多平台的 DSL 语言，从而提高开发效率。介绍如何使用 Swift 开发一个类似 Clang 并且支持插件的简版编译前端，从而优化代码，提高工程质量。此外还会简单介绍一些有趣的实践。 微博@戴铭。滴滴出行技术专家，技术上主要负责滴滴出行 iOS 相关的开发工作。时常会将对新技术的深入研究和工作的经验总结发在微博上。对 ReactiveCocoa，RxSwift，软件架构，性能优化和算法有着浓厚的兴趣。最近正在研究iOS编译相关底层技术，用来解决工程优化问题，到时会将成果分享出来。 学习 iOS 编译原理能做哪些有意思的事情1. 这哥们可谓是有着一双被编程耽误了的画手，不但主题，技术吸引人，所画出来的作品更是让人回味。 2. 先讲了一个关于flexbox布局的web代码，自己使用swift写了一个解析器。 3. 结合上面的实现个性化的讲解了一下编译器前后端，及编译的整个过程 ============================================================================= 柯灵杰（腾讯公司iOS开发）图片组件可以说是app开发中使用最多的组件之一，它既简单也不简单，如何设计和开发一个具有高扩展性，高性能的图片组件呢？本次分享将会从架构设计到性能优化等多方面，全面解析一个优秀图片组件的设计和开发原理，以及在性能优化和架构设计方面的一些经验和探索。 柯灵杰（lingtonke），腾讯公司 iOS 开发。腾讯学院认证讲师，主要讲授课程《设计模式》。曾参加过 QQ、QZone、微云、企鹅 MV、闪咖等的开发。他主导开发的图片组件，在腾讯内被多个项目使用，获得公司内多项优秀组件奖，目前已着手对业内开源。同时他还是数项技术发明专利的发明人，曾参加过程序员 LiveShow《有码的开发哥无码的直播》。目前是腾讯 QZone 团队 iOS 开发。 打造易扩展的高性能图片组件1. 如何设计高性能易拓展的图片组件，一步一步的优化。 2. 综合分析的不同框架，不同实现方案，不同技术的优缺点。 3. 当时我会中问到是否开源，回答是会，并且预计年底会开源。 ============================================================================= 王文槿（UC资深开发工程师）来自 UC 浏览器的 iPhone 组，参与了 UC 浏览器，UC 头条和夸克浏览器相关产品的开发，工作中主要使用 OC 和 Weex 。不过业余是不折不扣的 Swift 爱好者，自诩 Swift 的函数式编程的布道师。曾经先后通过文章&amp;演讲的形式分享了 Swift 异步串行/并行编程以及函数式的设计模式等话题。 一个轻量级 FRP 框架的诞生记1. 之前UC面试过一次，可惜挂了 2. 主要结合实际以一个很简单的Demo演示了MVVM，并且很清晰的解答了众多为止疑惑的参会者。 ============================================================================= 赵恩生（美团点评高级工程师）随着业务拆分和组件化的完成，美团 iOS 客户端在集成和交付的道路上越发艰难。在业务代码下放后，如何能保证客户端的安全稳定；面对千万用户，如何能快速优雅地组建并交付一个完整的客户端，这一切的一切都值得思考和深究。 希望通过本次分享，和各位一起探讨如何玩转大业务体量下的众多组件、如何搭建整个客户端的发布流程。 美团点评高级工程师，曾维护美团 iOS 客户端，现负责 iOS 发布流程相关工作，专业打杂，通过对复杂业务下组件发布集成的踩坑总结，对 CI CD 有一定的认识和理解。闲暇时喜欢捣鼓乱七八糟的东西，自学习得包括疏通下水道，手机贴膜，设备维修在内的一些奇怪技能。 组件 + 组建 = 美团 iOS 客户端1. 美团开发，集成，打包，测试，发布整个流程的工作与注意点。 2. 组件式的开发方式，规范性的流程与测试形成一个闭环 3. 校验，避错，后期的修复的考虑及解决方案 4. CI的基本流程介绍 ============================================================================= 傅若愚（ThoughtWorks 高级咨询师）是的，你一定听说过 Metal，或者你还写过一些 Metal 的 Shader。不过，说实话，喝了两杯啤酒之后，面对 Xcode，我们能做点儿更有趣的东西么？要不要来试试？ 来自 ThoughtWorks，刚睡醒的移动开发者，喝高了的 Tech Lead，SwiftyJSON 的作者（但这家伙已经弃坑……Oh，别担心，其他人还在维护）。业余喜读书，文史哲无所禁忌，爱美食与啤酒（最近爱上了 American Pale Ale），今年大概 17 岁的样子。 一些跟 Metal 有关系，肯定有趣但多半没用的东西1. 主要是机器学习，高逼格式的讲解了神经网络 2. 输入图片，视频染色然后渲染并输出对应的效果。 3. 主要是一些基础的概念，理论知识。 ============================================================================= 尹航（Google 工程师）深度学习总是让人联想到成吨的数据、笨重的服务器。但在移动端，我们能不能利用深度学习做一点有趣的事情呢？本次分享，让我们看看如何在iOS上运行起工业级的深度学习框架TensorFlow吧。 一个技能树歪掉的开发者。iOS 首个游戏辅助“叉叉助手”作者，也曾经编写《Cocos2d-x高级开发教程》，目前兴趣有移动安全和机器学习，Google 工程师，从事 Gmail 语义理解相关开发。 TensorFlow+iOS=❤️: 造一个颜文字输入法1. 机器学习，实战了一个emoji表情的输出。 2. 介绍了TensorFlow，介绍了他的一些特性与简单的应用 ============================================================================= 唐晓轩（礼物说联合创始人）Live Coding 礼物说联合创始人，全栈打杂工程师，公众号糖炒小虾，热衷于折腾各种黑技术。 当 Swift 遇上树莓派1. swift和树莓派之间的交互。 2. Swift+ARM，展示了一个watch跑的超级玛丽。 3. 展示数个小Demo，演示怎么与实际相结合，并提到为了对小米设备的实际应用 ============================================================================= 第二天尾声…到此整个会议已经全部结束，这一天在技术，底层，架构等方面收获就完全不一样了，同时后期会有文章介绍相关内容！ 随后，大家都纷纷离开准备回家或者会工作的城市！]]></content>
      <categories>
        <category>2017@Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>大会</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017@Swift——中国开发者大会（第一天）]]></title>
    <url>%2F2017%2F05%2F15%2F2017-Swift%E2%80%94%E2%80%94%E4%B8%AD%E5%9B%BD%E5%BC%80%E5%8F%91%E8%80%85%E5%A4%A7%E4%BC%9A%EF%BC%88%E7%AC%AC%E4%B8%80%E5%A4%A9%EF%BC%89%2F</url>
    <content type="text"><![CDATA[首先介绍一下会议信息 会议时间：2017年5月13日-5月14日， 地址：深圳凯宾斯基酒店， 人数：400人 嘉宾：18人，其中8位国外，8位国内。 第一天所有外国嘉宾的演讲时间，第二天是国内大牛的演讲时间！ 更多信息请点2017@Swift——中国开发者大会,同时后面也会抽空整理一下会议中讲到的内容，底层，细节与实现，敬请期待！ ================================================================================================================================= Tuomas Artman（Uber 移动架构和框架组负责人）Uber 使用 Swift 重写了 app，在这个分享中，Tuomas 会介绍如何在上百人的团队中使用 Swift 进行开发，并介绍 Uber 重写过程中遇到的各种问题和解决方法。Tuomas 是 Uber 移动架构和框架组的负责人。在来湾区之前，他创立了一家芬兰知名的数字资讯公司，还在上海的一家公司工作过一年，开发游戏和多用户技术平台。 Swift with hundreds of engineers1. 使用swift重构Uber的过程中good，bad，ugly。 2. 对架构重新设计了，并且将他成为router-&gt;interaction-&gt;builder简称RIBs。适用于Android和iOS双平台。 3. 重构后Uber的崩溃率降到了0.01%，这确实是一个非常理想的数据。 4. binary size关于Uber包的大小。 5. 关于如何缩短Uber的编译时间 6. 最后聊了一下unit test。 ================================================================================================================================= Sam Davies（RayWenderlich CTO）从基础的 NSOperation 一直到 Grand Central Dispatch，彻底讲明白 iOS 并发。此外还会涉及一些高级内容，比如 dispatch group 和线程安全。 Concurrency on iOS1. 异步并发。 2. 提出了开发中经常遇到的一些问题和解决方案 3. 提到了反转优先级 ================================================================================================================================= Igor Jerkovic（前 Facebook 资深开发者）Igor 在 Facebook 的视频团队工作了五年，非常熟悉国外大公司的那一套理论。他会在这次分享中介绍如何提高开发效率和代码质量。 我很喜欢编程，也喜欢学习新东西，尝试不同的方法。2011-2013 年我在 Facebook 实习，负责开发 iOS 项目。2014 年我正式加入 Facebook，一直在视频团队工作到 2016年。现在我在 Bellabeat 工作，这是一家和健康相关的创业公司，在旧金山、深圳和萨格勒布都有办公室。 iOS development efficiency at Facebook1. Facebook的开发流程，包括各种开发中的规范 2. 介绍了很多实用的工具Buck... ================================================================================================================================= Sommer Panage（Chorus Fitness 核心 iOS）在这个分享中，我会介绍无障碍和 VoiceOver。首先说明为什么无障碍支持很重要，然后通过一个权威的 iOS 应用了解你可以实现哪些无障碍功能。接着我会介绍 iOS 无障碍 API 以及如何对接 VoiceOver。最后，我会补充一些有趣的无障碍知识，除了支持 VoiceOver，我们还能做得更好。 Sommer Panage 目前是 Chorus Fitness 的核心 iOS 开发。在这之前，她做了两年 iOS freelancer，与此同时她还成为了一名马戏表演者和教练。更早的时候，她在 Twitter 和 Apple 的无障碍团队工作。Sommer 对心理学和计算机科学两个领域都有涉猎。在编写代码之余，她还会做绳索训练、高空秋千、倒立、跑步和抱石。你可以在 Twitter 上关注她，@sommer。 From Zero to Hero: Making your iOS App Accessible to VoiceOver and Beyond1. 主要是无障碍应用开发 2. 讲了iOS中的accessibility programing，并演示了对失明者的交互与使用。 3. 通过code演示了一些使用方式 ================================================================================================================================= Krunoslav Zaher（RxSwift 框架作者）我会介绍开发 Rx 的初衷、我对 Rx 的看法、Rx 的特点以及 Rx 和传统编程方式的区别。我还会介绍 Rx 的性能、不同设计模式的实现方式以及如何关联 Rx 和状态机。 在行业内摸爬滚打了 16 年。做过很多东西，增强现实引擎、BPM 系统、手机应用、机器人……最近在研究函数式编程和链式编程。白天我会帮准妈妈们听婴儿的心跳，晚上我会哄自己的宝贝女儿睡觉。 Thinking in Rx way1. 主要是对rx的用法介绍。 2. 提到了他写RX的初衷 ================================================================================================================================= Marius Rackwitz（CocoaPods、Realm 核心开发者）Marius 从大学毕业开始就从事移动端和 web 应用开发。最近他开始专注移动端开发，尤其是 iOS 和 Objective-C，以及后起之秀 Swift。当然，作为 CocoaPods 核心成员，他也没有抛弃 Ruby。加入 Realm 之后，他在社区中更加活跃，参与了很多大会。 JavaScript for Swift Developer1. 这哥们整个演讲的过程中很是激情，但是却让在场大部分参会者归为叛徒的了（哈哈，开个玩笑）。 2. JavaScript for Swift Developer主要是两者之间的不同。 ================================================================================================================================= Kyle Jessup（Perfect 框架作者，CTO）Perfect 作者，Lasso 编程语言（被苹果的子公司 Claris 收购）的服务端核心开发者。Kyle 自学能力很强，对 Swift、Java 和 C++ 都有深入了解。 小时候，Kyle 的父亲——一名曾在美国海军潜艇上服役的核工程师——送给他一台雅达利 800 个人电脑。从那时起，他就对技术产生兴趣，一直延续到现在。 Kyle 在德克萨斯的达拉斯出生，2015 年搬到加拿大，加入 PerfectlySoft 团队。 Swift作为后端开发相关1. 演示并分享了Swift实现后端开发的利弊 2. 介绍了了Perfect ================================================================================================================================= Saul Mora（流利说 iOS 工程师，MagicalRecord 作者）从上古时代开始接触 iOS，熟悉手动内存管理、编译器宏、pthread 和 头文件。Saul Mora 为了表达对编程前辈的尊重，在 Swift 中使用带可选变量的 Nib 编写 UI。掌握了 Objective C 之后，Saul 开始环游世界，进行历练。为了应对前方的算法挑战，Saul 积极拥抱 Swift。最近，Saul 生活在现代中国的核心城市——上海。他在流利说寺修行，开发这款优秀的 app，帮助中国用户学习英语。 Building Confidence: Testing iOS applications1. 以一个很滑稽很有乔布斯风格的开场吸引住了在场的参会者 2. 分析并深入讲解了测试的重要性和原则 ============================================================================= 第一天尾声…第一天的会议也就这样结束了，整个会议中大家谈论最多的问题就是关于英语的能力，这个后面会有相关的文章详细说明！]]></content>
      <categories>
        <category>2017@Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>大会</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——自动打包上传]]></title>
    <url>%2F2017%2F04%2F21%2FiOS%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[为了不去每次都做这些繁琐的操作，我们只能做一个懒得程序狗，也就是将整个过程进行脚本化…… 之前写过一篇关于自动打包上传代码的教程，最近又开始需要上线APP，发现新版的Mac对之前的教程不支持了，就换了一种方式，这次试用fir. http://al1020119.github.io/blog/2016/12/26/ios-daobao/ 工作中一般两种情况，1.打包Ad-Hoc给测试人员，或者内部人员测试 2.打包product发布到App Store 所以，为了不去每次都做这些繁琐的操作，我们只能做一个懒得程序狗，也就是将整个过程进行脚本化 大概的步骤是写个bash脚本，执行自动打包iOS版本，到指定的目录 （有条件的公司，可以自己搭个小服务器，这样谁都可以随时随地的打包） 将打包好的文件上传到fir.im (当然上传到自己公司的服务器或者任何地方都行，只是fir.im我一直用，觉得比较方便) 开发一个内部使用的类似APPStore，上面放着自己公司的所有APP,每次有更新的时候，测试童鞋直接通过这个自己下载新APP就可以了 主要命令编译workspacexcodebuild -workspace workspacename -scheme schemename -configuration [-configuration configurationname] clean build SYMROOT=(SYMROOT) 编译projectxcodebuild -target targetname -configuration [-configuration configurationname] clean build SYMROOT=(SYMROOT) 查看配置信息xcodebuild -list xcrun打包ipaxcrun -sdk iphoneos PackageApplication -v projectName.app -o ipaName.ipa 其他在终端输入：xcodebuild –help 或 –h查看具体的选项 显示xcodebuildversion：xcodebuild –version 显示当前系统安装的sdk：xcodebuild –showsdks 显示当前目录下project Information：xcodebuild –list xcodebuild&amp;xcrunxcodebuild-&gt;Build xcrun-&gt;Api 终端查看对应版本iCocosdeiMac:115科技 iCocos$ xcrun --version xcrun version 31. iCocosdeiMac:115科技 iCocos$ xcodebuild -version Xcode 8.2.1 Build version 8C1002 xcodebuild 是苹果提供的打包项目或者工程的命令需要在包含 name.xcodeproj 的目录下执行 xcodebuild 命令，且如果该目录下有多个 projects，那么需要使用 -project 指定需要 build 的项目。 在不指定 build 的 target 的时候，默认情况下会 build project 下的第一个 target 当 build workspace 时，需要同时指定 -workspace 和 -scheme 参数，scheme 参数控制了哪些 targets 会被 build 以及以怎样的方式 build。 有一些诸如 -list, -showBuildSettings, -showsdks 的参数可以查看项目或者工程的信息，不会对 build action 造成任何影响，放心使用。 使用xcodebuild和xcrun打包签名我这里就使用公司项目作为测试，方便查找问题和后续打包上传 1. 终端输入xcodebuild -project T 115科技.xcodeproj -target 115科技 -configuration Release xcodebuild -project T 曹理鹏(iCocos)-梦工厂.xcodeproj -target 曹理鹏(iCocos)-梦工厂 -configuration Debug 这是骚等所有走完之后就能看到对应的信息，表示build成功Signing Identity: &quot;iPhone Developer: xxx(59xxxxxx)&quot; Provisioning Profile: &quot;iOS Team Provisioning Profile: *&quot; 且在该目录下会多出一个 build 目录，该目录下有 Release-iphoneos 和 曹理鹏(iCocos)-梦工厂.build 文件，根据我们 build -configuration 配置的参数不同，Release-iphoneos 的文件名会不同。在 Release-iphoneos 文件夹下，有我们需要的曹理鹏(iCocos)-梦工厂.app文件，但是要安装到真机上，我们需要将该文件导出为ipa文件，这里使用 xcrun 命令。 xcrun -sdk iphoneos -v PackageApplication ./build/Release-iphoneos/曹理鹏(iCocos)-梦工厂.app -o ~/Desktop/曹理鹏(iCocos)-梦工厂.ipa 这个时候桌面上就会出现一个曹理鹏(iCocos)-梦工厂.ipa文件，这就是我们平时Archive之后的问题，也正是我们所需要的ipa包 但是xcodebuild期间我出现了一个这样的错误ld: library not found for -lAFNetworking clang: error: linker command failed with exit code 1 (use -v to see invocation) ** BUILD FAILED ** The following build commands failed: Ld build/曹理鹏(iCocos)-梦工厂.build/Release-iphoneos/曹理鹏(iCocos)-梦工厂.build/Objects-normal/armv7/曹理鹏(iCocos)-梦工厂 normal armv7 Ld build/曹理鹏(iCocos)-梦工厂.build/Release-iphoneos/曹理鹏(iCocos)-梦工厂.build/Objects-normal/arm64/曹理鹏(iCocos)-梦工厂 normal arm64 (2 failures) 貌似是linker command failed with exit code 1经典错误，但是然并卵，于是看了一下pingpong从零开始写个自动打包IPA脚本中的build方式，也有类似的问题。多谢pingpong帮我解决了这个问题。iCocosdeiMac ios (develop) $ xcodebuild 2016-05-02 13:05:04.623 xcodebuild[1015:16272] [MT] PluginLoading: Required plug-in compatibility UUID ACA8656B-FEA8-4B6D-8E4A-93F4C95C362C for plug-in at path &apos;~/Library/Application Support/Developer/Shared/Xcode/Plug-ins/XcodeColors.xcplugin&apos; not present in DVTPlugInCompatibilityUUIDs 2016-05-02 13:05:04.625 xcodebuild[1015:16272] [MT] PluginLoading: Required plug-in compatibility UUID ACA8656B-FEA8-4B6D-8E4A-93F4C95C362C for plug-in at path &apos;~/Library/Application Support/Developer/Shared/Xcode/Plug-ins/OMColorSense.xcplugin&apos; not present in DVTPlugInCompatibilityUUIDs === BUILD TARGET xxx OF PROJECT xxx WITH THE DEFAULT CONFIGURATION (Release) === Check dependencies Write auxiliary files write-file /Users/iCocos/Documents/code/xxx/ios/build/xxx.build/Release-iphoneos/xxx.build/xxx.hmap write-file /Users/iCocos/Documents/code/xxx/ios/build/xxx.build/Release-iphoneos/xxx.build/xxx-own-target-headers.hmap write-file /Users/iCocos/Documents/code/xxx/ios/build/xxx.build/Release-iphoneos/xxx.build/Script-492B764475E022A63FB67F55.sh 解决方案是：执行xcodebuild需要指定你所需要对应的workspace和schemexcodebuild -workspace /Users/iCocos/Desktop/MBA/最新Git源代码/曹理鹏(iCocos)-梦工厂/曹理鹏(iCocos)-梦工厂.xcworkspace -scheme 曹理鹏(iCocos)-梦工厂 执行前，先查看下-list,这个可以知道xcodebuild命令下对应的参数需要填写的内容iCocosdeiMac ios (develop) $ xcodebuild -list 2016-05-02 15:24:26.656 xcodebuild[16535:154176] [MT] PluginLoading: Required plug-in compatibility UUID ACA8656B-FEA8-4B6D-8E4A-93F4C95C362C for plug-in at path &apos;~/Library/Application Support/Developer/Shared/Xcode/Plug-ins/XcodeColors.xcplugin&apos; not present in DVTPlugInCompatibilityUUIDs 2016-05-02 15:24:26.661 xcodebuild[16535:154176] [MT] PluginLoading: Required plug-in compatibility UUID ACA8656B-FEA8-4B6D-8E4A-93F4C95C362C for plug-in at path &apos;~/Library/Application Support/Developer/Shared/Xcode/Plug-ins/OMColorSense.xcplugin&apos; not present in DVTPlugInCompatibilityUUIDs Information about project &quot;xxx&quot;: Targets: xxx xxxTests Build Configurations: Debug Release If no build configuration is specified and -scheme is not passed then &quot;Release&quot; is used. Schemes: xxx 然后，成功了,如下：Entitlements: { &quot;application-identifier&quot; = &quot;L64TE3S9T9.com.曹理鹏(iCocos)-梦工厂.shaoshang&quot;; &quot;aps-environment&quot; = development; &quot;com.apple.developer.pass-type-identifiers&quot; = ( &quot;L64TE3S9T9.*&quot; ); &quot;com.apple.developer.team-identifier&quot; = L64TE3S9T9; &quot;get-task-allow&quot; = 1; } builtin-productPackagingUtility -entitlements -format xml -o /Users/iCocos/Library/Developer/Xcode/DerivedData/曹理鹏(iCocos)-梦工厂-aqiwhxodbfeztuebgnzgbgicurgl/Build/Intermediates/曹理鹏(iCocos)-梦工厂.build/Debug-iphoneos/曹理鹏(iCocos)-梦工厂.build/曹理鹏(iCocos)-梦工厂.app.xcent CodeSign /Users/iCocos/Library/Developer/Xcode/DerivedData/曹理鹏(iCocos)-梦工厂-aqiwhxodbfeztuebgnzgbgicurgl/Build/Products/Debug-iphoneos/曹理鹏(iCocos)-梦工厂.app cd /Users/iCocos/Desktop/MBA/最新Git源代码/曹理鹏(iCocos)-梦工厂 export CODESIGN_ALLOCATE=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/codesign_allocate export PATH=&quot;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/Users/iCocos/.rvm/gems/ruby-2.3.0/bin:/Users/iCocos/.rvm/gems/ruby-2.3.0@global/bin:/Users/iCocos/.rvm/rubies/ruby-2.3.0/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Users/iCocos/.rvm/bin:/usr/local/mysql/bin/mysql&quot; Signing Identity: &quot;iPhone Developer: Songbai He (73N6HPPJDP)&quot; Provisioning Profile: &quot;iOS Team Provisioning Profile: com.曹理鹏(iCocos)-梦工厂.shaoshang&quot; (34c1d23b-ade5-4d0f-9329-7b16009b30c2) /usr/bin/codesign --force --sign F8BAED0C84DB84AAA84769FED9FEAA9E80825C29 --entitlements /Users/iCocos/Library/Developer/Xcode/DerivedData/曹理鹏(iCocos)-梦工厂-aqiwhxodbfeztuebgnzgbgicurgl/Build/Intermediates/曹理鹏(iCocos)-梦工厂.build/Debug-iphoneos/曹理鹏(iCocos)-梦工厂.build/曹理鹏(iCocos)-梦工厂.app.xcent --timestamp=none /Users/iCocos/Library/Developer/Xcode/DerivedData/曹理鹏(iCocos)-梦工厂-aqiwhxodbfeztuebgnzgbgicurgl/Build/Products/Debug-iphoneos/曹理鹏(iCocos)-梦工厂.app Validate /Users/iCocos/Library/Developer/Xcode/DerivedData/曹理鹏(iCocos)-梦工厂-aqiwhxodbfeztuebgnzgbgicurgl/Build/Products/Debug-iphoneos/曹理鹏(iCocos)-梦工厂.app cd /Users/iCocos/Desktop/MBA/最新Git源代码/曹理鹏(iCocos)-梦工厂 export PATH=&quot;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/Users/iCocos/.rvm/gems/ruby-2.3.0/bin:/Users/iCocos/.rvm/gems/ruby-2.3.0@global/bin:/Users/iCocos/.rvm/rubies/ruby-2.3.0/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Users/iCocos/.rvm/bin:/usr/local/mysql/bin/mysql&quot; export PRODUCT_TYPE=com.apple.product-type.application builtin-validationUtility /Users/iCocos/Library/Developer/Xcode/DerivedData/曹理鹏(iCocos)-梦工厂-aqiwhxodbfeztuebgnzgbgicurgl/Build/Products/Debug-iphoneos/曹理鹏(iCocos)-梦工厂.app ** BUILD SUCCEEDED ** 下面就是验证你全栈的时候到了，其实也没有那么难，就是一点脚本而已先git 指令，pull到最新的分支# git update git checkout $BRANCHNAME if [ $? -ne 0 ]; then exit 1 fi git pull #pod update --verbose --no-repo-update if [ $? -ne 0 ]; then exit 1 fi 成功之后你同意会看到提示信息logout Saving session... ...copying shared history... ...saving history...truncating history files... ...completed. Deleting expired sessions...118 completed. xcodebuild进行编译xcodebuild \ -workspace $SORCEPATH/曹理鹏(iCocos)-梦工厂.xcworkspace \ -scheme $SCHEMENAMEPLQ \ -configuration Debug \ CODE_SIGN_IDENTITY=&quot;iPhone Developer: Songbai He(73N6HPPJDP)” \ PROVISIONING_PROFILE=&quot;com.曹理鹏(iCocos)-梦工厂.shaoshang&quot; \ clean \ build \ -derivedDataPath $IPAPATH/$BRANCHNAME/$DATE 测试与发布只需要更改对应的参数即可-configuration Debug -configuration Release 用xcrun打包成ipa包xcrun -sdk iphoneos PackageApplication \ -v $IPAPATH/Build/Products/Debug-iphoneos/$SCHEMENAME.app \ -o $IPAPATH/$IPANAME 生成ipa包，上传到fir.im一：1.注册fir.拿到tokenfir.im官网：https://fir.im 注册号账号，点击右上角个人信息，进入API token 拿到token，并保存 二：安装fir-clifir-cli 使用 Ruby 构建, 无需编译, 只要安装相应 gem 即可. $ ruby -v # &gt; 1.9.3 $ gem install fir-cli 三：Mac新版之后可能由于源的问题导致无法安装（由于10.11引入了 rootless, 无法直接安装 fir-cli）一般都是这么安装的：使用 Homebrew 及 RVM 安装 Ruby, 再安装 fir-cli Install Homebrew: $ ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; Install RVM: $ \curl -sSL https://get.rvm.io | bash -s stable --ruby Install fir-cli: $ gem install fir-cli 四：在终端登录并查看信息 $ fir login 按照提示输入token,然后 iCocosdeiMac:曹理鹏(iCocos)-梦工厂 iCocos$ fir login Please enter your fir.im API Token: 849ad212b94683b4c3087248d422d124 I, [2017-04-18T13:58:01.184043 #14531] INFO -- : Login succeed, previous user&apos;s email: al10201119@163.com I, [2017-04-18T13:58:01.185131 #14531] INFO -- : Login succeed, current user&apos;s email: al10201119@163.com I, [2017-04-18T13:58:01.185223 #14531] INFO -- : $fir me 登录成功,就会显示用户信息 I, [2017-04-18T13:58:21.876164 #14545] INFO – : Login succeed, current user’s email: al10201119@163.com I, [2017-04-18T13:58:21.876246 #14545] INFO – : Login succeed, current user’s name: al10201119 I, [2017-04-18T13:58:21.876261 #14545] INFO – : 使用fir指令，上传我们的ipa包 fir login -T c525718a775b954882xxxxxxxx # fir.im token fir publish $IPAPATH/Develop/xxx.ipa 最后你会看到 恭喜！！！上传fir.im成功！ 也可以直接使用执行脚本#author iCocos #注意：脚本目录和xxxx.xcodeproj要在同一个目录，如果放到其他目录，请自行修改脚本。 #工程名字(Target名字) Project_Name=&quot;Target名字，系统默认和工程名字一样&quot; #配置环境，Release或者Debug Configuration=&quot;Release&quot; #AdHoc版本的Bundle ID AdHocBundleID=&quot;com.xxx&quot; #AppStore版本的Bundle ID AppStoreBundleID=&quot;com.xxx&quot; #enterprise的Bundle ID EnterpriseBundleID=&quot;com.xxx&quot; # ADHOC #证书名#描述文件 ADHOCCODE_SIGN_IDENTITY=&quot;iPhone Distribution: xxxx&quot; ADHOCPROVISIONING_PROFILE_NAME=&quot;xxxx-xxxx-xxxx-xxxx&quot; #AppStore证书名#描述文件 APPSTORECODE_SIGN_IDENTITY=&quot;iPhone Distribution: xxxx&quot; APPSTOREROVISIONING_PROFILE_NAME=&quot;xxxx-xxxx-xxxx-xxxx&quot; #企业(enterprise)证书名#描述文件 ENTERPRISECODE_SIGN_IDENTITY=&quot;iPhone Distribution: xxxxx&quot; ENTERPRISEROVISIONING_PROFILE_NAME=&quot;xxxx-xxxx-xxxx-xxxx&quot; #加载各个版本的plist文件 ADHOCExportOptionsPlist=./ADHOCExportOptionsPlist.plist AppStoreExportOptionsPlist=./AppStoreExportOptionsPlist.plist EnterpriseExportOptionsPlist=./EnterpriseExportOptionsPlist.plist ADHOCExportOptionsPlist=${ADHOCExportOptionsPlist} AppStoreExportOptionsPlist=${AppStoreExportOptionsPlist} EnterpriseExportOptionsPlist=${EnterpriseExportOptionsPlist} echo &quot;~~~~~~~~~~~~选择打包方式(输入序号)~~~~~~~~~~~~~~~&quot; echo &quot; 1 appstore&quot; echo &quot; 2 adhoc&quot; echo &quot; 3 enterprise&quot; # 读取用户输入并存到变量里 read parameter sleep 0.5 method=&quot;$parameter&quot; # 判读用户是否有输入 if [ -n &quot;$method&quot; ] then #clean下 xcodebuild clean -xcodeproj ./$Project_Name/$Project_Name.xcodeproj -configuration $Configuration -alltargets if [ &quot;$method&quot; = &quot;1&quot; ] then #appstore脚本 xcodebuild -project $Project_Name.xcodeproj -scheme $Project_Name -configuration $Configuration -archivePath build/$Project_Name-appstore.xcarchive clean archive build CODE_SIGN_IDENTITY=&quot;${APPSTORECODE_SIGN_IDENTITY}&quot; PROVISIONING_PROFILE=&quot;${APPSTOREROVISIONING_PROFILE_NAME}&quot; PRODUCT_BUNDLE_IDENTIFIER=&quot;${AppStoreBundleID}&quot; xcodebuild -exportArchive -archivePath build/$Project_Name-appstore.xcarchive -exportOptionsPlist $AppStoreExportOptionsPlist -exportPath ~/Desktop/$Project_Name-appstore.ipa elif [ &quot;$method&quot; = &quot;2&quot; ] then #adhoc脚本 xcodebuild -project $Project_Name.xcodeproj -scheme $Project_Name -configuration $Configuration -archivePath build/$Project_Name-adhoc.xcarchive clean archive build CODE_SIGN_IDENTITY=&quot;${ADHOCCODE_SIGN_IDENTITY}&quot; PROVISIONING_PROFILE=&quot;${ADHOCPROVISIONING_PROFILE_NAME}&quot; PRODUCT_BUNDLE_IDENTIFIER=&quot;${AdHocBundleID}&quot; xcodebuild -exportArchive -archivePath build/$Project_Name-adhoc.xcarchive -exportOptionsPlist $ADHOCExportOptionsPlist -exportPath ~/Desktop/$Project_Name-adhoc.ipa elif [ &quot;$method&quot; = &quot;3&quot; ] then #企业打包脚本 xcodebuild -project $Project_Name.xcodeproj -scheme $Project_Name -configuration $Configuration -archivePath build/$Project_Name-enterprise.xcarchive clean archive build CODE_SIGN_IDENTITY=&quot;${ENTERPRISECODE_SIGN_IDENTITY}&quot; PROVISIONING_PROFILE=&quot;${ENTERPRISEROVISIONING_PROFILE_NAME}&quot; PRODUCT_BUNDLE_IDENTIFIER=&quot;${EnterpriseBundleID}&quot; xcodebuild -exportArchive -archivePath build/$Project_Name-enterprise.xcarchive -exportOptionsPlist $EnterpriseExportOptionsPlist -exportPath ~/Desktop/$Project_Name-enterprise.ipa else echo &quot;参数无效....&quot; exit 1 fi fi 这里还有一个大神使用PHP干了一票，虽然还在学习PHP中，但是有机会也要试一下 这里目前只是实现了Ad-Hoc打包上传，关于App Store其实也就是更改参数，和对应的地址，后续会退出相应的文章界面具体实战……]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>自动打包上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——ipv6(客户端)]]></title>
    <url>%2F2017%2F04%2F20%2FiOS%E2%80%94%E2%80%94ipv6-%E5%AE%A2%E6%88%B7%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[此篇文章的起源是由最近一次APP被拒引起的，就在上周，我们App因为ipv6的问题被拒了，当时我就纳闷了，前一次都没有被拒，这一次只改功能，逻辑，界面并没有涉及第三方或者网络相关集成，于是不得不整理一番…… 如果你想了解服务器对ipv6支持，请查看上一节：iOS——ipv6(客户端) 引言总的来说有三个方面需要进行检查和修改： 1、项目里面涉及和网络有关的网络请求是否支持ipv6。 2、项目里面涉及和网络有关的sdk是否支持ipv6。 3、项目的服务器是否支持ipv6。 IPv6的简介IPv4 和 IPv6的区别就是 IP 地址前者是 .（dot）分割，后者是以 :（冒号）分割的（更多详细信息自行搜索）。 PS：在使用 IPv6 的热点时候，记得手机开飞行模式哦，保证手机只在 Wi-Fi 下上网，以免手机在连接不到网络时候，会默认跳转到使用 蜂窝移动网络（即2G、3G、4G流量） 上网。 IPV6，是对IPV4地址空间的扩充。目前当我们用iOS设备连接上Wifi、4G、3G等网络时，设备被分配的地址均是IPV4地址，但是随着运营商和企业逐渐部署IPV6 DNS64/NAT64网络之后，设备被分配的地址会变成IPV6的地址，而这些网络就是所谓的IPV6-Only网络，并且仍然可以通过此网络去获取IPV4地址提供的内容。客户端向服务器端请求域名解析，首先通过DNS64 Server查询IPv6的地址，如果查询不到，再向DNS Server查询IPv4地址，通过DNS64 Server合成一个IPV6的地址，最终将一个IPV6的地址返回给客户端。 本地如何搭建IPv6环境测试你的APPhttp://jingyan.baidu.com/article/e75057f2f33cffebc91a89a3.html ipv6介绍与实现一、IPV6-Only支持是啥？首先IPV6，是对IPV4地址空间的扩充。目前当我们用iOS设备连接上Wifi、4G、3G等网络时，设备被分配的地址均是IPV4地址，但是随着运营商和企业逐渐部署IPV6 DNS64/NAT64网络之后，设备被分配的地址会变成IPV6的地址，而这些网络就是所谓的IPV6-Only网络，并且仍然可以通过此网络去获取IPV4地址提供的内容。客户端向服务器端请求域名解析，首先通过DNS64 Server查询IPv6的地址，如果查询不到，再向DNS Server查询IPv4地址，通过DNS64 Server合成一个IPV6的地址，最终将一个IPV6的地址返回给客户端。如图所示： 二、Apple如何审核支持IPV6-Only？首先第一点：这里说的支持IPV6-Only网络，其实就是说让应用在 IPv6 DNS64/NAT64 网络环境下仍然能够正常运行。但是考虑到我们目前的实际网络环境仍然是IPV4网络，所以应用需要能够同时保证IPV4和IPV6环境下的可用性。从这点来说，苹果不会去扫描IPV4的专有API来拒绝审核通过，因为IPV4的API和IPV6的API调用都会同时存在于代码中。 其次第二点：Apple官方声明iOS9开始向IPV6支持过渡，在iOS9.2+支持IPV4地址合成IPV6地址。其提供的Reachability库在iOS8系统下，当从IPV4切换到IPV6网络，或者从IPV6网络切换到IPV4，是无法监控到网络状态的变化。也有一些开发者针对这些Bug询问Apple的审核部门，给予的答复是只需要在苹果最新的系统上保证IPV6的兼容性即可。 最后第三点：只要应用的主流程支持IPV6，通过苹果审核即可。对于不支持IPV6的模块，考虑到我们现实IPV6网络的部署还需要一段时间，短时间内不会影响我们用户的使用。但随着4G网络IPV6的部署，这部分模块还是需要逐渐安排人力进行支持。 三、应用如何支持IPV6-Only？对于如何支持IPV6-Only，官方给出了如下几点标准：（这里就不对其进行解释了，大家看上面的参考链接即可） Use High-Level Networking Frameworks; Don’t Use IP Address Literals; Check Source Code for IPv6 DNS64/NAT64 Incompatibilities;4. Use System APIs to Synthesize IPv6 Addresses;3.1 NSURLConnection是否支持IPV6？ 官方的这句话让我们疑惑顿生： using high-level networking APIs such as NSURLSession and the CFNetwork frameworks and you connect by name, you should not need to change anything for your app to work with IPv6 addresses 只说了NSURLSession和CFNetwork的API不需要改变，但是并没有提及到NSURLConnection。 从上文的参考资料中，我们看到NSURLSession、NSURLConnection同属于Cocoa的url loading system，可以猜测出NSURLConnection在ios9上是支持IPV6的。 应用里面的API网络请求，大家一般都会选择AFNetworking进行请求发送，由于历史原因，应用的代码基本上都深度引用了AFHTTPRequestOperation类，所以目前API网络请求均需要通过NSURLConnection发送出去，所以必须确认NSURLConnection是否支持IPV6. 经过测试，NSURLConnection在最新的iOS9系统上是支持IPV6的。 3.2 Cocoa的URL Loading System从iOS哪个版本开始支持IPV6？目前我们的应用最低版本还需要支持iOS7，虽然苹果只要求最新版本支持IPV6－Only，但是出于对用户负责的态度，我们仍然需要搞清楚在低版本上URL Loading System的API是否支持IPV6.（to fix me, make some experiments）待续～～～ 3.3 Reachability是否需要修改支持IPV6？我们可以查到应用中大量使用了Reachability进行网络状态判断，但是在里面却使用了IPV4的专用API。 在Pods:Reachability中 AF_INET Files:Reachability.m struct sockaddr_in Files:Reachability.h , Reachability.m 那Reachability应该如何支持IPV6呢？ （1）目前Github的开源库Reachability的最新版本是3.2，苹果也出了一个Support IPV6 的Reachability的官方样例，我们比较了一下源码，跟Github上的Reachability没有什么差异。（2）我们通常都是通过一个0.0.0.0 (ZeroAddress)去开启网络状态监控，经过我们测试，在iOS9以上的系统上IPV4和IPV6网络环境均能够正常使用；但是在iOS8上IPV4和IPV6相互切换的时候无法监控到网络状态的变化，可能是因为苹果在iOS8上还并没有对IPV6进行相关支持相关。（但是这仍然满足苹果要求在最新系统版本上支持IPV6的网络）。 （3）当大家都在要求Reachability添加对于IPV6的支持，其实苹果在iOS9以上对Zero Address进行了特别处理，官方发言是这样的： reachabilityForInternetConnection: This monitors the address 0.0.0.0,which reachability treats as a special token that causes it to actuallymonitor the general routing status of the device, both IPv4 and IPv6. + (instancetype)reachabilityForInternetConnection { struct sockaddr_in zeroAddress; bzero(&amp;zeroAddress, sizeof(zeroAddress)); zeroAddress.sin_len = sizeof(zeroAddress); zeroAddress.sin_family = AF_INET; return [self reachabilityWithAddress: (const struct sockaddr *) &amp;zeroAddress]; } 综上所述，Reachability不需要做任何修改，在iOS9上就可以支持IPV6和IPV4，但是在iOS9以下会存在bug，但是苹果审核并不关心。 四、底层的socket API如何同时支持IPV4和IPV6？由于在应用中使用了网络诊断的组件，大量使用了底层的 socket API，所以对于IPV6支持，这块是个重头戏。如果你的应用中使用了长连接，其必然会使用底层socket API，这一块也是需要支持IPV6的。 对于Socket如何同时支持IPV4和IPV6，可以参考谷歌的开源库CocoaAsyncSocket. 下面我针对我们的开源 网络诊断组件, 说一下是如何同时支持IPV4和IPV6的。开源地址：https://github.com/Lede-Inc/LDNetDiagnoService_IOS.git 这个网络诊断组件的主要功能如下： 本地网络环境的监测（本机IP＋本地网关＋本地DNS＋域名解析）； 通过TCP Connect监测到域名的连通性； 通过Ping 监测到目标主机的连通耗时； 通过traceRoute监测设备到目标主机中间每一个路由器节点的ICMP耗时； 4.1 IP地址从二进制到符号的转化之前我们都是通过inet_ntoa()进行二进制到符号，这个API只能转化IPV4地址。而inet_ntop()能够兼容转化IPV4和IPV6地址。 写了一个公用的in6_addr的转化方法如下： //for IPV6 +(NSString *)formatIPV6Address:(struct in6_addr)ipv6Addr{ NSString *address = nil; char dstStr[INET6_ADDRSTRLEN]; char srcStr[INET6_ADDRSTRLEN]; memcpy(srcStr, &amp;ipv6Addr, sizeof(struct in6_addr)); if(inet_ntop(AF_INET6, srcStr, dstStr, INET6_ADDRSTRLEN) != NULL){ address = [NSString stringWithUTF8String:dstStr]; } return address; } //for IPV4 +(NSString *)formatIPV4Address:(struct in_addr)ipv4Addr{ NSString *address = nil; char dstStr[INET_ADDRSTRLEN]; char srcStr[INET_ADDRSTRLEN]; memcpy(srcStr, &amp;ipv4Addr, sizeof(struct in_addr)); if(inet_ntop(AF_INET, srcStr, dstStr, INET_ADDRSTRLEN) != NULL){ address = [NSString stringWithUTF8String:dstStr]; } return address; } 4.2 本机IP获取支持IPV6 相当于我们在终端中输入ifconfig命令获取字符串，然后对ifconfig结果字符串进行解析，获取其中en0（Wifi）、pdp_ip0（移动网络）的ip地址。 注意： （1）在模拟器和真机上都会出现以FE80开头的IPV6单播地址影响我们判断，所以在这里进行特殊的处理（当第一次遇到不是单播地址的IP地址即为本机IP地址）。（2）在IPV6环境下，真机测试的时候，第一个出现的是一个IPV4地址，所以在IPV4条件下第一次遇到单播地址不退出。 + (NSString *)deviceIPAdress { while (temp_addr != NULL) { NSLog(@&quot;ifa_name===%@&quot;,[NSString stringWithUTF8String:temp_addr-&gt;ifa_name]); // Check if interface is en0 which is the wifi connection on the iPhone if ([[NSString stringWithUTF8String:temp_addr-&gt;ifa_name] isEqualToString:@&quot;en0&quot;] || [[NSString stringWithUTF8String:temp_addr-&gt;ifa_name] isEqualToString:@&quot;pdp_ip0&quot;]) { //如果是IPV4地址，直接转化 if (temp_addr-&gt;ifa_addr-&gt;sa_family == AF_INET){ // Get NSString from C String address = [self formatIPV4Address:((struct sockaddr_in *)temp_addr-&gt;ifa_addr)-&gt;sin_addr]; } //如果是IPV6地址 else if (temp_addr-&gt;ifa_addr-&gt;sa_family == AF_INET6){ address = [self formatIPV6Address:((struct sockaddr_in6 *)temp_addr-&gt;ifa_addr)-&gt;sin6_addr]; if (address &amp;&amp; ![address isEqualToString:@&quot;&quot;] &amp;&amp; ![address.uppercaseString hasPrefix:@&quot;FE80&quot;]) break; } } temp_addr = temp_addr-&gt;ifa_next; } } } 4.3 设备网关地址获取获取支持IPV6其实是在IPV4获取网关地址的源码的基础上进行了修改，初开把AF_INET－&gt;AF_INET6, sockaddr -&gt; sockaddr_in6之外，还需要注意如下修改，就是拷贝的地址字节数。去掉了ROUNDUP的处理。 （解析出来的地址老是少了4个字节，结果是偏移量搞错了，纠结了半天），具体参考源码库。 /* net.route.0.inet.flags.gateway */ int mib[] = {CTL_NET, PF_ROUTE, 0, AF_INET6, NET_RT_FLAGS, RTF_GATEWAY}; if (sysctl(mib, sizeof(mib) / sizeof(int), buf, &amp;l, 0, 0) &lt; 0) { address = @&quot;192.168.0.1&quot;; } .... //for IPV4 for (i = 0; i &lt; RTAX_MAX; i++) { if (rt-&gt;rtm_addrs &amp; (1 &lt;&lt; i)) { sa_tab[i] = sa; sa = (struct sockaddr *)((char *)sa + ROUNDUP(sa-&gt;sa_len)); } else { sa_tab[i] = NULL; } } //for IPV6 for (i = 0; i &lt; RTAX_MAX; i++) { if (rt-&gt;rtm_addrs &amp; (1 &lt;&lt; i)) { sa_tab[i] = sa; sa = (struct sockaddr_in6 *)((char *)sa + sa-&gt;sin6_len); } else { sa_tab[i] = NULL; } } 4.4 设备DNS地址获取支持IPV6IPV4时只需要通过res_ninit进行初始化就可以获取，但是在IPV6环境下需要通过res_getservers()接口才能获取。 +(NSArray *)outPutDNSServers{ res_state res = malloc(sizeof(struct __res_state)); int result = res_ninit(res); NSMutableArray *servers = [[NSMutableArray alloc] init]; if (result == 0) { union res_9_sockaddr_union *addr_union = malloc(res-&gt;nscount * sizeof(union res_9_sockaddr_union)); res_getservers(res, addr_union, res-&gt;nscount); for (int i = 0; i &lt; res-&gt;nscount; i++) { if (addr_union[i].sin.sin_family == AF_INET) { char ip[INET_ADDRSTRLEN]; inet_ntop(AF_INET, &amp;(addr_union[i].sin.sin_addr), ip, INET_ADDRSTRLEN); NSString *dnsIP = [NSString stringWithUTF8String:ip]; [servers addObject:dnsIP]; NSLog(@&quot;IPv4 DNS IP: %@&quot;, dnsIP); } else if (addr_union[i].sin6.sin6_family == AF_INET6) { char ip[INET6_ADDRSTRLEN]; inet_ntop(AF_INET6, &amp;(addr_union[i].sin6.sin6_addr), ip, INET6_ADDRSTRLEN); NSString *dnsIP = [NSString stringWithUTF8String:ip]; [servers addObject:dnsIP]; NSLog(@&quot;IPv6 DNS IP: %@&quot;, dnsIP); } else { NSLog(@&quot;Undefined family.&quot;); } } } res_nclose(res); free(res); return [NSArray arrayWithArray:servers]; } 4.4 域名DNS地址获取支持IPV6在IPV4网络下我们通过gethostname获取，而在IPV6环境下，通过新的gethostbyname2函数获取。 //ipv4 phot = gethostbyname(hostN); //ipv6 phot = gethostbyname2(hostN, AF_INET6); 4.5 ping方案支持IPV6Apple的官方提供了最新的支持IPV6的ping方案，参考地址如下：https://developer.apple.com/library/mac/samplecode/SimplePing/Introduction/Intro.html只是需要注意的是： （1）返回的packet去掉了IPHeader部分，IPV6的header部分也不返回TTL（Time to Live）字段； （2）IPV6的ICMP报文不进行checkSum的处理； 4.6 traceRoute方案支持IPV6其实是通过创建socket套接字模拟ICMP报文的发送，以计算耗时；两个关键的地方需要注意： （1）IPV6中去掉IP_TTL字段，改用跳数IPV6_UNICAST_HOPS来表示； （2）sendto方法可以兼容支持IPV4和IPV6，但是需要最后一个参数，制定目标IP地址的大小；因为前一个参数只是指明了IP地址的开始地址。千万不要用统一的sizeof(struct sockaddr), 因为sockaddr_in 和 sockaddr都是16个字节，两者可以通用，但是sockaddr_in6的数据结构是28个字节，如果不显式指定，sendto方法就会一直返回－1，erroNo报22 Invalid argument的错误。 关键代码如下：（完整代码参考开源组件） //构造通用的IP地址结构stuck sockaddr NSString *ipAddr0 = [serverDNSs objectAtIndex:0]; //设置server主机的套接口地址 NSData *addrData = nil; BOOL isIPV6 = NO; if ([ipAddr0 rangeOfString:@&quot;:&quot;].location == NSNotFound) { isIPV6 = NO; struct sockaddr_in nativeAddr4; memset(&amp;nativeAddr4, 0, sizeof(nativeAddr4)); nativeAddr4.sin_len = sizeof(nativeAddr4); nativeAddr4.sin_family = AF_INET; nativeAddr4.sin_port = htons(udpPort); inet_pton(AF_INET, ipAddr0.UTF8String, &amp;nativeAddr4.sin_addr.s_addr); addrData = [NSData dataWithBytes:&amp;nativeAddr4 length:sizeof(nativeAddr4)]; } else { isIPV6 = YES; struct sockaddr_in6 nativeAddr6; memset(&amp;nativeAddr6, 0, sizeof(nativeAddr6)); nativeAddr6.sin6_len = sizeof(nativeAddr6); nativeAddr6.sin6_family = AF_INET6; nativeAddr6.sin6_port = htons(udpPort); inet_pton(AF_INET6, ipAddr0.UTF8String, &amp;nativeAddr6.sin6_addr); addrData = [NSData dataWithBytes:&amp;nativeAddr6 length:sizeof(nativeAddr6)]; } struct sockaddr *destination; destination = (struct sockaddr *)[addrData bytes]; //创建socket if ((recv_sock = socket(destination-&gt;sa_family, SOCK_DGRAM, isIPV6?IPPROTO_ICMPV6:IPPROTO_ICMP)) &lt; 0) if ((send_sock = socket(destination-&gt;sa_family, SOCK_DGRAM, 0)) &lt; 0) //设置sender 套接字的ttl if ((isIPV6? setsockopt(send_sock,IPPROTO_IPV6, IPV6_UNICAST_HOPS, &amp;ttl, sizeof(ttl)): setsockopt(send_sock, IPPROTO_IP, IP_TTL, &amp;ttl, sizeof(ttl))) &lt; 0) //发送成功返回值等于发送消息的长度 ssize_t sentLen = sendto(send_sock, cmsg, sizeof(cmsg), 0, (struct sockaddr *)destination, isIPV6?sizeof(struct sockaddr_in6):sizeof(struct sockaddr_in)); 第三方Reachability按照苹果开发者中心提示，这个必须换。 新的sdk包将这个方法干掉了：reachabilityForLocalWiFi，只要自己的代码中干掉就行了，没什么影响。 原因如下介绍： #pragma mark reachabilityForLocalWiFi //reachabilityForLocalWiFi has been removed from the sample. See ReadMe.md for more information. //+ (instancetype)reachabilityForLocalWiFi; 新浪微博根据官网提示，这个新的sdk支持了ipv6，所以进行替换。 替换后： 根据比较，新旧sdk只有上述变化，替换后command＋B编译无错误提示。应该没事。 连连支付按照连连支付官方文档 最新的sdk包是支持ipv6的，但是旧包也是支持的。项目中用的是2.4.0，官网上最新包是2.4.7，最后我们做了替换。 在新的方法里面添加了一个判断支付类型的参数。 根据项目中报错的两个地方，第一个是快捷支付，第二个是认证支付。按照之前的进行了修改。command＋B编译无错误提示。应该没事。 但是实际上还是遇到了崩溃的bug。然后我们换回了2.4.0版本，应为连连支付官网上说之前的版本也支持ipv6，我们之前的版本没有问题，所以换了回来，看看上线能成功不。 友盟按照友盟官方sdk文档描述，需要更换新的sdk包。 按照需要，勾选了如下： md，搞错了，项目里面的友盟是友盟分析，上边那个是友盟分享。。。 但是根据官方文档，好像我们的不用替换，因为涉及到什么IDFA，我们项目好像不涉及这个。 微信按照微信最新sdk包1.7版本里面的README.txt，最新的sdk包支持ipv6 而我们项目中的微信是1.5版本的。应该进行替换。command＋B编译无错误提示。应该没事。 比较可笑的是微信的sdk包是支持ipv6的，但是微信本身并不支持ipv6，所以说，即便你替换了最新的sdk包，在ipv6网络下还是不能用微信分享，因为你的app应用在ipv6网络环境下调不起微信，也就分享不了了，这个问题微信应该意识到了，估计后边的版本应该也是支持ipv6的吧。 QQ官方文档好像也没有说ipv6的事啊 次奥！支付宝sdk支持了ipv6，上午下载的时候没看见！！！可是下载的时候总是打不开.zip的压缩包。。。叫别人帮忙下载了一份 command＋B编译无错误提示。应该没事。 百度地图根据比较，新的sdk包没有了bundle文件。需要将旧包的bundle文件拷贝进来。 总之，对于ipv6_Only的处理就是这样办的，从两大方面进行自己审核：自身网络请求和三方涉及网络请求。 关于AFNetworking是否支持ipv－6 可见，AFNetworking是支持ipv－6的。 注意： 1.ios9 和 mac os 10.11以后NSURLSession和CFNetwork自动将ipv4合成ipv6进行请求 2.AFN升级3.3就可以实现ipv4 所以对于客户端来说三点即可 1. 检查你所用的库，想AFN3.0以上等，其他的库自己搜索是否支持ipv6 2. 确保所用的SDK支持ipv6，一般文档都会有说明，到目前为止，应该大部分第三方SDK都已经支持ipv6 3. 测试 dig + nocomd + nostats 你的域名 这里主要是看服务器ipv6下是否有相应 如果你有事吗疑问，关于ipv6，关于iOS开发，或者关于PHP学习，欢迎直接联系我，或者在下面留言，希望能一起交流学习！]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>ipv6(客户端)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——ipv6(服务器)]]></title>
    <url>%2F2017%2F04%2F20%2FiOS%E2%80%94%E2%80%94ipv6-%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[此篇文章的起源是由最近一次APP被拒引起的，就在上周，我们App因为ipv6的问题被拒了，当时我就纳闷了，前一次都没有被拒，这一次只改功能，逻辑，界面并没有涉及第三方或者网络相关集成，于是不得不整理一番…… 当时情形是这样的：在2月份之前公司已经上线了一个App，当时我并不知道已经上线的App知否支持ipv6，在我重写整个App，并在上线前对苹果审核规则细查的时候也想到了，当时正好因为去年年末苹果的一份给所有开发中的邮件，我就略过了这一步，结果也上线成功的，现在在发现我这是误打误撞亦或者是运气问题…… 就在第二个版本，上线的时候，既然被拒了，当时我就纳闷了，经过思考与讨论才知道，原来2月份之前上线的App中，服务器是已经搭建的ipv6环境的，但是我们上线第一个版本也是有ipv6的，就在上线第二个版本之前，老板问了我是否需要还需要ipv6支持，当时我只想到了苹果的那份邮件：苹果延迟ipv6的支持。所以就回复不需要的，就这样服务器就删除了ipv6环境….. 上线之后才发现，之前服务器支持ipv6，客户端大部分支持ipv6。先删除服务器ipv6的支持，导致苹果开启客户端ipv6测试的时候，很多操作都无法实现，没办法只能让服务器重新ipv6，并且客户端做相关细节处理….. 好了，废话不多说,本次讲以服务器和客户端讲解ipv6支持的实现，处理，细节。客户端将在下节介绍。 首先我们来为服务器量身定制的解决方案提供最快捷、稳定、高效、安全、可靠的IPv6解决方法. 苹果AppStore审核员在美国的IPv6-Only环境下对APP进行访问（审核），如果APP Server支持IPv6，则可直接访问；如果APP Server不支持IPv6，则通过DNS64 +NAT64进行访问；很明显，大部分开发者的APP服务器都是不支持IPv6直接访问的，所以基本是用NAT64+DNS64进行访问的。那么我们就先了解NAT64+DNS64的访问机制吧，直接看图： 从这里看出审核的关键在于能不能获取一个有效的Server IPv6地址。当苹果公司的APP审核员在进行审核时，由于国内大部分开发者的APPserver没有IPv6地址，只能通过苹果公司自己的NAT64+DNS64服务器进行测试，而最关键的是苹果的服务器不能有效的给APPserver返回一个IPv6地址，这就导致了审核失败，APP被拒。 就国内目前来说审核被拒的主要原因有第三个： 1、国内大部分APP服务器没有IPv6地址，导致DNS无法解析； 2、苹果公司的审核环境不能自动将中国APP内URL转换成IPv6可访问的格式，导致访问失败； 3、由于国际线路带宽严重拥堵等原因造成访问不稳定，失败率高 那么该如何解决这些问题呢？ 方案一就目前国内的现状，能够提供这种服务的当属教育网了，中国教育网坐拥全国几百所高校，拥有真实的IPv6骨干网络，国际出口，IPv6资源丰富，服务质量好。 因此解决方案就是使用教育网的NAT64+DNS64服务，方案示意图如下： 具体的操作步骤就是使用教育网的NAT64+DNS64，把您的域名发给我们，帮你解析出IPv6地址（全球可达的地址），您只需在您的域名管理中添加一条4A记录即可，之后就可以提交审核了，一天之后你就会发现审核通过了！ 解决方案二既然审核被拒是因为IPV6，那么我们就让服务器支持就可以了，但是很多运营商的服务器不提供IPv6地址，这样的话就要使用IPv6隧道技术,通过建立隧道使自己的服务器通过IPv6隧道来支持IPv6,方案示意图如下： 使用IPv6隧道服务APP服务器必须满足三个条件： ① 服务器拥有公网IPv4地址 ② 服务器支持IPv6协议 ③ 服务器放行6in4协议 具体的配置如下：（这里只是举个例子） 确认申请了IPv6隧道服务并按照上述模板进行配置完成后，请检查防火墙（iptables）是否放行了6in4协议，并确认(/etc/sysctl.conf)中IPv6转发已打开。如果上述操作都已正确完成，那么在你的服务器上应该可以看到如下结果： 至此，IPv6隧道搭建完毕，服务器已经支持IPv6了，赶紧提交审核去吧！ 目前来说，服务器对ipv6支持的的实现，大部分公司或者技术人员都可以做，要求并不高。 下节将介绍客户端实现，处理，细节等。 如果你有事吗疑问，关于ipv6，关于iOS开发，或者关于PHP学习，欢迎直接联系我，或者在下面留言，希望能一起交流学习！]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>ipv6(服务器)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[直播--技术原理篇]]></title>
    <url>%2F2017%2F03%2F20%2F%E7%9B%B4%E6%92%AD-%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E7%AF%87%2F</url>
    <content type="text"><![CDATA[最近在做直播的App，但是使用的是腾讯云，大部分东西都被封装好了，曾经也想过整理一下关于腾讯云的使用，但是最后想想还是没有必要，官方说的那么好，虽然也会遇到一些坑。所以就找了一些之前留意过的关于直播的东西，整理一下。 视频直播1：采集：AVCaptureSession，显示：AVCaptureVideoPreviewLayer 2：MP4：MP4 是一种视频容器格式 MP4文件中的所有数据都装在box(QuickTime中为atom)中,也就是说MP4文 件由若干个box组成,每个box有类型和长度,可以将box理解为一个数据对象 MP4 件格式是ISO-14496-12基础 件格式的衍 品,14496-14 中对-12协议进 了扩充与进 步定义。 重要的是该“14496-12 基础 件格式”协议如果认祖归宗,我们发现这种 件 格式最初是由Apple公司的QuickTime媒体格式发展 来的。 即,mov格式发展出了“ISO 14496 – 12协议”,再由该协议衍 出了 mp4,f4v,ismv,3gp等我们常见的媒体封装格式。 因此上述标志位的poster位,在14496-12中并没有见到描述, 在Apple的协 议中却看到了准确定义 H264：H.264 是一种图像编码标准。H264是一种高压缩率的编码标准,如何压缩嘞?一般的视频采集都是25帧/秒, 也就是每秒截图25次,其实每一张图片的内容都相差不大,压缩的办法就是利用算 法,只将每张图片变动差异化的部分保存下来,这样视频文件就小多了 三种帧在H264协议里定义了三种帧,完整编码的帧叫I帧,参考之前的I帧生成的只包含差 异部分编码的帧叫P帧,还有一种参考前后的帧编码的帧叫B帧。 H264结构中,一个视频图像编码后的数据叫做一帧,一帧由一个片(slice)或多 个片组成,一个片由一个或多个宏块(MB)组成,一个宏块由16×16的yuv数据 组成。宏块作为H264编码的基本单位。 H264采用的核心算法是帧内压缩和帧间压缩,帧内压缩是生成I帧的算法,帧间压 缩是生成B帧和P帧的算法。 + I帧:帧内编码帧 ,I帧表示关键帧,你可以理解为这一帧画面的完整保留;解码时只 需要本帧数据就可以完成(因为包含完整画面) + P帧:前向预测编码帧。P帧表示的是这一帧跟之前的一个关键帧(或P帧)的差别, 解码时需要用之前缓存的画面叠加上本帧定义的差别,生成最终画面。(也就是差 别帧,P帧没有完整画面数据,只有与前一帧的画面差别的数据) + B帧:双向预测内插编码帧。B帧是双向差别帧,也就是B帧记录的是本帧与前后帧的 差别(具体比较复杂,有4种情况,但我这样说简单些),换言之,要解码B帧,不 仅要取得之前的缓存画面,还要解码之后的画面,通过前后画面的与本帧数据的叠 加取得最终的画面。B帧压缩率高,但是解码时CPU会比较累。 一个序列的第一个图像叫做 IDR 图像(立即刷新图像),IDR 图像都是 I 帧图像。 H.264 引入 IDR 图像是为了解码的重同步,当解码器解码到 IDR 图像时,立即将 参考帧队列清空,将已解码的数据全部输出或抛弃,重新查找参数集,开始一个新 的序列。这样,如果前一个序列出现重大错误,在这里可以获得重新同步的机会。 IDR图像之后的图像永远不会使用IDR之前的图像的数据来解码。 一个序列就是一段内容差异不太大的图像编码后生成的一串数据流。当运动变化比 较少时,一个序列可以很长,因为运动变化少就代表图像画面的内容变动很小,所 以就可以编一个I帧,然后一直P帧、B帧了。当运动变化多时,可能一个序列就比 较短了,比如就包含一个I帧和3、4个P帧。 H264编码后的数据分为两层:1. VCL(video coding layer)视频编码层:它是对核心算法引擎,块,宏块 及片的语法级别的定义,最终输出编码完的数据 SODB。 2. NAL(network abstraction layer)网络提取层:定义片级以上的语法级别 (如序列参数集和图像参数集,针对网络传输),同时支持以下功能:独立 片解码,起始码唯一保证,SEI以及流格式编码数据传送,NAL层将SODB打 包成RBSP然后加上NAL头,组成一个NALU(NAL单元)。 分层的好处显而易见,对于RTMP传输数据,我们只需了解NAL层就足够了。 H264硬编原理想要采用硬件加速编码视频,苹果提供的只有 AVAssetWriter 类,而它只能写入编码后的文件到指定路径的文件中。我们如果想要实时硬编码,例如将视频流输出到网络,这时就需要从输出文件中不断读取新的编码后视频数据。 实现AVEncoder 通过使用 GCD Dispatch Source 监听文件的内容改变,通 过此方式高效的读取编码后的数据,然而简单的读取 raw data 并不能满足我们的 需求,因此在代码中根据Mp4的文件结构(要看懂这里就需要前面介绍的知识 了),每次读取一个完整的 NALU 后再将数据通过 block 传递给外部调用者处理。 AVEncoder -&gt; 读入CMBu er -&gt; 调用 AVAssetWriter 编码Bu er -&gt; 设置 header 的 FileHandler -&gt; 获得第一帧(moov[sps, pps]),切换写入文件(寻 找mdat),重设FileHandle -&gt; [输入数据 -&gt; 编码 处理循环 ] -&gt; 发送给调用者 处理。 FLVFLV里面是由多个Tag构成的:[[tag1][tag2][tag3][tag4]…] 而Tag多种类型,最常见的是 Metainfo Tag , Video Tag , Audio Tag 。 Flv Header 是文件的头部,用 FLV 字符串标明了文件的类型,以及是否有音频、 视频等信息。之后会有几个字节告诉接下来的包字节数。 Metainfo 中用来描述Flv中的各种参数信息,例如视频的编码格式、分辨率、采样 率等等。如果是本地文件(非实时直播流),还会有偏移时间戳之类的信息用于支 持快进等操作。 VideoTag 存放视频数据。对于H.264来说,第一帧发送的NALU应为 SPS和PPS, 这个相当于H.264的文件头部,播放器解码流必须先要找到这个才能进行播放。之 后的数据为I帧或P帧。 AudioTag 存放音频数据。对于AAC来说,我们只需要在每次硬编码完成后给数据 加上adts头部信息即可 VLC：（MobileVLCKit.framework）VLC Media Player (VideoLAN) 为 Windows、Linux、OS X、Android、iOS、Windows Phone等平台提供 个视频播放 器、解码器。它可以播放来 络、摄像头、磁盘、光驱的 件, 持包括MPEG 1/2/4, H264, VC-1, DivX, WMV, Vorbis, AC3, AAC等格式的解码。在 Windows 和 Linux 上的 VLC 是使 C++/Qt写成,提供了 致的 户体验。同时 VLC 还专门 为 OS X 提供了原 版本,OS X 版的 VLC 的 户界 使 Cocoa框架编写,在 OS X 下拥有卓越的原 体验。 VLC优秀的封装,源码中最核 的部分,被封装成了独 的库,基于FFmpeg,Live555提供完整的媒体播放库,你只 需要定制 的界 , 持CocoaPods导 库,开发 个简单界 的播放器,你只需要 代码, 乎覆盖所有媒体格 式!http://www.videolan.org/vlc/download-ios.html 直播博客推荐 [基于RTMP的视频推流](http://www.jianshu.com/p/8ea016b2720e) [高仿&lt;喵播APP&gt;](http://www.jianshu.com/p/b8db6c142aad) [高仿&lt;喵播APP&gt;](http://www.jianshu.com/p/b8db6c142aad) [吖了个峥](http://www.jianshu.com/users/b09c3959ab3b/latest_articles) [七牛云技术(三方直播)](http://www.jianshu.com/users/342c4dafa482/latest_articles) [原文](http://www.cocoachina.com/ios/20161111/18050.html)]]></content>
      <categories>
        <category>Live</category>
      </categories>
      <tags>
        <tag>Live</tag>
        <tag>技术原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法--合并两个链表]]></title>
    <url>%2F2017%2F03%2F12%2F%E7%AE%97%E6%B3%95-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[之前面试的时候遇到了算法的问题，想了很久都没有想出最好的方案，最终还是放弃了，最后想想，毕竟没有要求我当场写代码，就这样认输真心有点佩服自己。 非递归做法非递归的做法思想是：先判断两个链表头，以决定哪个链表头作为新链表的链表头指针；然后同时遍历两个链表，直到其中一个链表尾，比较时，值小的接入到新的链表中，同时向后移动该链表的头指针和新链表的指针；当遍历完毕后，哪个链表不为空，就直接将剩余部分接入到新链表尾即可。递归做法 递归做法，其实就是每次判断哪个值小，值小的作为头，然后递归构造next部分。 求最小的K个数100w个数中找出最大的100个数。 方案1：在前面的题中，我们已经提到了，用一个含100个元素的最小堆完成。复杂度为O(100w*lg100)。 方案2：冒泡排序， 冒出前100个。复杂度为O(100w*100)。 1. 算法如下：根据快速排序划分的思想 (1) 递归对所有数据分成[a,b）b（b,d]两个区间，(b,d]区间内的数都是大于[a,b)区间内的数 (2) 对(b,d]重复(1)操作，直到最右边的区间个数小于100个。注意[a,b)区间不用划分 (3) 返回上一个区间，并返回此区间的数字数目。接着方法仍然是对上一区间的左边进行划分，分为[a2,b2）b2（b2,d2]两个区间，取（b2,d2]区间。如果个数不够，继续(3)操作，如果个数超过100的就重复1操作，直到最后右边只有100个数为止。 2. 先取出前100个数，维护一个100个数的最小堆，遍历一遍剩余的元素，在此过程中维护堆就可以了。具体步骤如下： step1：取前m个元素（例如m=100），建立一个小顶堆。保持一个小顶堆得性质的步骤，运行时间为O（lgm);建立一个小顶堆运行时间为m*O（lgm）=O(m lgm); step2:顺序读取后续元素，直到结束。每次读取一个元素，如果该元素比堆顶元素小，直接丢弃 如果大于堆顶元素，则用该元素替换堆顶元素，然后保持最小堆性质。最坏情况是每次都需要替换掉堆顶的最小元素，因此需要维护堆的代价为(N-m)*O(lgm); 最后这个堆中的元素就是前最大的10W个。时间复杂度为O(N lgm）。 3. 分块查找 先把100w个数分成100份，每份1w个数。先分别找出每1w个数里面的最大的数，然后比较。找出100个最大的数中的最大的数和最小的数，取最大数的这组的第二大的数，与最小的数比较。。。。从N个数中查找最小的前K个数，最常规的办法就是进行全排序，所有取前K个最小的即可，但是这样做的话，效率是比较低下的，很有可能过不了。 总结：而题目中要求取的是前k个最小的数，那么我们可以采用最小堆排序，每次调整完堆，堆顶都是本次调整的堆中最小的数，因此只需要调整K次就可以得到最终答案了。 同样，如果是取最大的K个数，就采用最大堆排序就可以了！]]></content>
      <categories>
        <category>Algo</category>
      </categories>
      <tags>
        <tag>Algo</tag>
        <tag>合并两个链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试被虐总结二]]></title>
    <url>%2F2017%2F03%2F12%2F%E9%9D%A2%E8%AF%95%E8%A2%AB%E8%99%90%E6%80%BB%E7%BB%93%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[年后因为各种原因只能重新找工作，期间进攻了UC，CVTE，酷狗还有其他一些比较大一点的公司，一路过来，被虐的不要不要的。 性能优化实战nstrumentsnstruments有三件套(Time Profiler、Core Animation、GPU Driver)，秒把U（GPU、CPU）来搞。 如果想在地铁上用手机也能调BUG，也可以使用HeapInspector，支持OC和Swift，比Beagle更强大。能监测Leak、Retain cycles、dirty memory、对象生命周期（PS：最难调的BUG，往往跟生命周期有关） 解决问题一：App进入一个界面比较慢，尤其是首次进入： 聊天界面 创建Controller及相关类 读取消息列表 渲染消息 通过Instrument Profile过后，发现当时App有相当一部分时间花费在了CoreText的渲染上。当时App的文本消息是使用CoreText绘制的，而CoreText整个绘制流程当中有一步占比最重：文本消息的高度宽度计算及超链接检测。 解决1：以空间换时间，把文字高宽度和超链接的信息都存入database，这样下次启动的时候不用重新计算计算完之后，再启动一个后台任务在子线程当中把计算好的信息（dirty message）存入database。 ### App页面卡顿：滑动中出现严重卡顿问题 用一个倾斜90°的tableview来做，简单，不用自己维护重用队列，每个cell放一个 vc 的view 就可以了。 ### 经测试发现严重卡顿。 用scrollView来写，自己来维护重用队列，具体做法大家可以参考 UIScrollView 实践经验 （3.重用） 。最后“完美”地实现了需求，开始做别的需求去了。 上线一个多月之后发现。我在使用过程中。在scrollView滚动的时候，明显的感觉到了卡帧，然后就开始优化。 ### 解决思路 1.尼玛，该不会是 UIScrollView的重用 没写好？ 断点验证了下，vc只会创建3个，重用没问题呀。 2.因为涉及重用，所有vc里面tableview的内容肯定不是一下子全请求出来的，每滚动一次才会去请求下个页面的数据，以及初始化页面。然后再看nice，忽然发现它滚动的时候，状态栏居然没有网络请求的小菊花！！难不成是一次请求的？应该不会吧，这么多数据呀。为了验证这种猜想，用 Charles 拦截下，结果nice也是每滚动次发次请求的： github，博客，stackOverFlow，各种google，发现都是一些关于tableView优化规范而已。 ### 只能靠自己一点点琢磨了。 先跑下Instruments三件套吧(Time Profiler,Core Animation,GPU Driver)。 1.排除了GPU的问题：关于渲染，OPenGL ES Driver中检测 2.排除了CPU的问题：cellForRowCPU使用30%，头像的地方 ### 只能从代码了： cell的高度没有缓存，这肯定有影响 发现refreshData的success block回调居然执行2次，这岂不是意味着tableview要reloadData两次，短时间刷新2次，肯定会卡啊 ## 三（四）次握手 ### 其实有个问题，为什么连接的时候是三次握手，关闭的时候却是四次挥手？ 因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手 ## 崩溃记录 1、数组越界导致的崩溃。 -[__NSArrayI objectAtIndex:]: index 100 beyond bounds [0 .. 99]’ 2、数据集合类型，如字典、数组中插入元素时，插入空指针nil。 3、调用当前对象类中不存在的方法导致崩溃。 ‘-[AppDelegate button1]: unrecognized selector sent to instance 0x8c764c0’ 4、数据接收时，服务器返回数据不规范，如字典或数组元素中存在null，且客户端没做处理导致的崩溃。 5、内存管理不当，向野指针发送消息导致的崩溃。（此类bug最难解决，所以编码时谨慎） 一般报错为：EXC_BAD_ACCESS ## 疑难杂症 认定消息已经发送成功：二次握手，非心跳包 网络请求失败：域名解析错误，使用ip+host MOV-MP4-&gt;android:使用ijk底层编码H264 文件上传：32位的MD5结合文件的前8个字节的16位+文件的后8个字节的16位=64位 ### 总结 一、客户端发送的请求数量和服务端接收的数量不一致。原因可能是服务端并发请求数量设置的过小。 二、利用循环请求数据时小概率的引起程序崩溃。原因可能是两个线程同时对一个数据源进行了操作。 三、绘制分时、k线时线条模糊，举行时会出现四条边不一样粗细。原因就是IOS绘机制的问题。 四、利用tableView的headerViewForSection:方法获取headerView时一直是nil。原因应该是设置headerView时利用- (UIView *)tableView: viewForHeaderInSection:的代理方法返回的UIView应该是UITableViewHeaderFooterView类型的，很多时候被他的返回值（UIView *）误导了。 五、由于项目比较大，页面多而且复杂，有时就需要从当前的responder通过nextResponder（一个甚至多个）找到深层次的VeiwController。 六、项目中需要用到循环刷新数据，利用NSTimer来实现，但是想在VC销毁时停掉timer（就是在dealloc方法中停掉），结果发现dealloc根本不调用，原本以为是引用计数没有减到0，可是问题不在此，而就在NSTimer这。结果在viewDidDisappear:停掉timer后就调用dealloc方法了。 七、利用viewWithTag:寻找子View时，出现绝对性的错误，对象类型都不对。问题出现在设置的tag有重复，要注意的是子View在包括子View的子View的tag都不可以重复，所以建议另外创建一个文件专门设定tag，就像android中的R.java文件一样来确保tag的唯一。 ### 准确机制 二次握手：而心跳机制，是为了确保客户端跟服务器链接没问题，客户端定时的给服务器发送空字符串或额定格式的消息（一般而言，不会太多内容，节省流量），然后客户端根据返回的结果判断（超时、正常、断线）而做重连与否的操作 非心跳包：二次握手是指小心接收发送都得遵循的，是指一个消息的传递，如A给B发一个消息，A发送到服务器，服务器发给B ，B根据消息告诉服务器已经收到，服务器再传递给A（最后一步可要可不要）；这样一个流程下来才叫一个消息传递成功 ## 关于tableView性能优化 正确使用reuseIdentifier来重用cells 尽量使所有的view opaque，包括cell自身 避免渐变，图片缩放，后台选人 缓存行高 如果cell内现实的内容来自web，使用异步加载，缓存请求结果 使用shadowPath来画阴影 减少subviews的数量 尽量不适用cellForRowAtIndexPath:，如果你需要用到它，只用一次然后缓存结果 使用正确的数据结构来存储数据 使用rowHeight, sectionFooterHeight 和 sectionHeaderHeight来设定固定的高，不要请求delegate ### 只定义一种Cell。 ``` bash 提前计算并缓存每个Cell的高度。 提前创建真正显示的、需要加工的数据并缓存。 缓存View！ 在UITableView的Delegate、DataSource方法中，减少任何不必要的操作 最常用的就是cell的重用， 注册重用标识符如果不重用cell时，每当一个cell显示到屏幕上时，就会重新创建一个新的cell 如果有很多数据的时候，就会堆积很多cell。如果重用cell，为cell创建一个ID 每当需要显示cell 的时候，都会先去缓冲池中寻找可循环利用的cell，如果没有再重新创建cell 设置正确的reuseIdentifer以重用cell 避免cell的重新布局cell的布局填充等操作 比较耗时，一般创建时就布局好 如可以将cell单独放到一个自定义类，初始化时就布局好 提前计算并缓存cell的属性及内容在cellForRowAtIndexPath:中尽量做更少的操作。如果需要做一些处理，那么最好做过一次之后，就将结果缓存起来。 当我们创建cell的数据源方法时，编译器并不是先创建cell 再定cell的高度 而是先根据内容一次确定每一个cell的高度，高度确定后，再创建要显示的cell，滚动时，每当cell进入凭虚都会计算高度，提前估算高度告诉编译器，编译器知道高度后，紧接着就会创建cell，这时再调用高度的具体计算方法，这样可以方式浪费时间去计算显示以外的cell 减少cell中控件的数量尽量使cell得布局大致相同，不同风格的cell可以使用不用的重用标识符，初始化时添加控件， 不适用的可以先隐藏 不要使用ClearColor，无背景色，透明度也不要设置为0渲染耗时比较长 尽量将view设置为不透明，包括cell本身。 使用局部更新如果只是更新某组的话，使用reloadSection进行局部更新 加载网络数据，下载图片，使用异步加载，并缓存如果cell显示的内容来此网络，那么确保这些内容是通过异步来获取的 少使用addView 给cell动态添加view按需加载cell，cell滚动很快时，只加载范围内的cell注意正确使用懒加载 不要实现无用的代理方法，tableView只遵守两个协议非必要的代理或者数据源方法可以省略，比如numberofsention 缓存行高：如果row的高度不相同，那么将其缓存下来 estimatedHeightForRow不能和HeightForRow里面的layoutIfNeed同时存在，这两者同时存在才会出现“窜动”的bug。所以我的建议是：只要是固定行高就写预估行高来减少行高调用次数提升性能。如果是动态行高就不要写预估方法了，用一个行高的缓存字典来减少代码的调用次数即可 避免渐变，图像缩放以及离屏绘制使用shadowPath来设置阴影。使用适当的数据结构来保存需要的信息。不同的结构会带来不同的操作代价。使用rowHeight, sectionFooterHeight 和 sectionHeaderHeight 来设置一个恒定 高度，而不要从delegate中获取。使用富文本标签代价是很昂贵的tableView性能优化总结入门级（这是些你一定会经常用在你app开发中的建议）1. 用ARC管理内存 2. 在正确的地方使用reuseIdentifier 3. 尽可能使Views不透明 4. 避免庞大的XIB 5. 不要block主线程 6. 在Image Views中调整图片大小 7. 选择正确的Collection 8. 打开gzip压缩 中级（这些是你可能在一些相对复杂情况下可能用到的）9. 重用和延迟加载Views 10. Cache, Cache, 还是Cache！ 11. 权衡渲染方法 12. 处理内存警告 13. 重用大开销的对象 14. 使用Sprite Sheets 15. 避免反复处理数据 16. 选择正确的数据格式 17. 正确地设定Background Images 18. 减少使用Web特性 19. 设定Shadow Path 20. 优化你的Table View 21. 选择正确的数据存储选项 进阶级（这些建议只应该在你确信他们可以解决问题和得心应手的情况下采用）22. 加速启动时间 23. 使用Autorelease Pool 24. 选择是否缓存图片 25. 尽量避免日期格式转换]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>面试二</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试被虐总结一]]></title>
    <url>%2F2017%2F03%2F12%2F%E9%9D%A2%E8%AF%95%E8%A2%AB%E8%99%90%E6%80%BB%E7%BB%93%E4%B8%80%2F</url>
    <content type="text"><![CDATA[年后因为各种原因只能重新找工作，期间进攻了UC，CVTE，酷狗还有其他一些比较大一点的公司，一路过来，被虐的不要不要的。 消息机制关于消息机制简单实现：isa-&gt;class-&gt;selector是否忽略（mac垃圾忽略retain，release）-&gt;是否nil（nil执行方法忽略，运行时忽略掉：我们给把nil对象设给了一个成员变量，setter就会retain nil对象(当然了这个时候nil对象啥事情也不会做)然后release旧的对象）-&gt;查找类的IMP-&gt;缓存列表中-&gt;方法列表中-&gt;父类中（重复上面，直到根类）-&gt;任何一处找到加入缓存，方便下次-&gt;通过方法中的函数指针跳转到对应的函数执行-&gt;都找不到就开始转发 Runtime消息机制完整实现首先通过obj的isa指针找到obj对应的class。 首先检测这个 selector 是不是要忽略。比如 Mac OS X 开发，有了垃圾回收就不理会 retain，release 这些函数。 检测这个 selector 的 target 是不是 nil，Objc 允许我们对一个 nil 对象执行任何方法不会 Crash，因为运行时会被忽略掉。 如果上面两步都通过了，那么就开始查找这个类的实现 IMP， 在Class中先去cache中 通过SEL查找对应函数method，找到就执行对应的实现。 若cache中未找到，再去methodList中查找，找到就执行对应的实现。 若methodlist中未找到，则取superClass中查找（重复执行以上两个步骤），直到找到最根的类为止。 若任何一部能找到，则将method加 入到cache中，以方便下次查找，并通过method中的函数指针跳转到对应的函数中去执行。 如果以上都不能找到，则会开始进行消息转发 消息转发：（动态：resolveInstanceMethod，给机会添加实现）检测是否动态添加方法-&gt;（快速：forwardingTargetForSelector，别的对象执行函数）是否实现了forward。方法-&gt;（标准：forwardInvocation，目标函数以其他形式执行）Runtime发送消息获取签名-&gt;非空就inv转发，否则崩溃退出（doesNotRecognizeSelector） 消息转发完整实现1.动态方法解析：向当前类发送 resolveInstanceMethod: 信号，检查是否动态向该类添加了方法。（迷茫请搜索：@dynamic） 2.快速消息转发：检查该类是否实现了 forwardingTargetForSelector: 方法，若实现了则调用这个方法。若该方法返回值对象非nil或非self，则向该返回对象重新发送消息。 3.标准消息转发：runtime发送methodSignatureForSelector:消息获取Selector对应的方法签名。返回值非空则通过forwardInvocation:转发消息，返回值为空则向当前对象发送doesNotRecognizeSelector:消息，程序崩溃退出 动态特性：动态类型：程序直到执行时才能确定所属的类。 动态绑定：程序直到执行时才能确定实际要调用的方法。 动态加载：根据需求加载所需要的资源 总结就是： 在一个函数找不到时，OC提供了三种方式去补救： 1、调用resolveInstanceMethod给个机会让类添加这个实现这个函数 2、调用forwardingTargetForSelector让别的对象去执行这个函数 3、调用forwardInvocation（函数执行器）灵活的将目标函数以其他形式执行。 如果都不中，调用doesNotRecognizeSelector抛出异常。 事件处理###应用如何找到最合适的控件来处理事件？ 1.首先判断主窗口（keyWindow）自己是否能接受触摸事件 2.判断触摸点是否在自己身上 3.子控件数组中从后往前遍历子控件，重复前面的两个步骤（所谓从后往前遍历子控件，就是首先查找子控件数组中最后一个元素，然后执行1、2步骤） 4.view，比如叫做fitView，那么会把这个事件交给这个fitView，再遍历这个fitView的子控件，直至没有更合适的view为止。 5.如果没有符合条件的子控件，那么就认为自己最合适处理这个事件，也就是自己是最合适的view 事件的传递和响应的区别：+ 事件的传递是从上到下（父控件到子控件），事件的响应是从下到上（顺着响应者链条向上传递：子控件到父控件。 响应者链的事件传递过程:1&gt;如果当前view是控制器的view，那么控制器就是上一个响应者，事件就传递给控制器；如果当前view不是控制器的view，那么父视图就是当前view的上一个响应者，事件就传递给它的父视图 2&gt;在视图层次结构的最顶级视图，如果也不能处理收到的事件或消息，则其将事件或消息传递给window对象进行处理 3&gt;如果window对象也不处理，则其将事件或消息传递给UIApplication对象 4&gt;如果UIApplication也不能处理该事件或消息，则将其丢弃 事件处理的整个流程总结： 1.触摸屏幕产生触摸事件后，触摸事件会被添加到由UIApplication管理的事件队列中（即，首先接收到事件的是UIApplication）。 2.UIApplication会从事件队列中取出最前面的事件，把事件传递给应用程序的主窗口（keyWindow）。 3.主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件。（至此，第一步已完成) 4.最合适的view会调用自己的touches方法处理事件 5.touches默认做法是把事件顺着响应者链条向上抛。 view-&gt;控制器/父视图-&gt;window-&gt;UIApplication-&gt;丢弃时间传递：事件添加到UIApplication队列-&gt;取出传递给窗口-&gt;窗口中查找最合适的View（主窗是否接受触摸-&gt;触摸点是否在自己身上-&gt;重复上面步骤在子控件中-&gt;没有就自己处理）-&gt;调用自己的touches处理事件 NSObiect-&gt;UIResponser-&gt;UIView（VC）/UIApp-&gt;UIControl-&gt;UIButton。。 Block：Block介绍：栈地址和对地址值的拷贝，其实里面存储了指向函数体中包含定义block时的代码块的函数指针，以及block外部上下文变量等信息的结构体+ Block是“带有自动变量值的匿名函数” + 对于一般的block来说，它的数据就是传入的参数和在定义这个block时截获的变量。而它的算法，就是我们往里面写的那些方法、函数调用等。 + 被编译为C语言里的普通的struct结构体来实现的 + 一共是四个结构体，显然一个block对象被编译为了一个__main_block_impl_0类型的结构体。这个结构体由两个成员结构体和一个构造函数组成。两个结构体分别是__block_impl和__main_block_desc_0类型的 + 当block需要截获自动变量的时候，首先会在__main_block_impl_0结构体中增加一个成员变量并且在结构体的构造函数中对变量赋值 +在block被执行的时候，把__main_block_impl_0结构体，也就是block对象作为参数传入__main_block_func_0结构体中，取出其中的val的值，进行接下来的操作。 1. 为什么block中不能修改普通变量的值？int val = __cself-&gt;val; 当然这并没有什么影响，甚至还有好处，因为int val变量定义在栈上，在block调用时其实已经被销毁，但是我们还可以正常访问这个变量。但是试想一下，如果我希望在block中修改变量的值，那么受到影响的是int val而非__cself-&gt;val，事实上即使是__cself-&gt;val，也只是截获的自动变量的副本，要想修改在block定义之外的自动变量，是不可能的事情 由于无法直接获得原变量，技术上无法实现修改，所以编译器直接禁止了。 2.__block的作用就是让变量的值在block中可以修改么？只是把val封装在了一个结构体中而已 __Block_byref_val_0 *val; 由于__main_block_impl_0结构体中现在保存了一个指针变量，所以任何对这个指针的操作，是可以影响到原来的变量的。 进一步，我们考虑截获的自动变量是Objective-C的对象的情况。在开启ARC的情况下，将会强引用这个对象一次。这也保证了原对象不被销毁，但与此同时，也会导致循环引用问题。 需要注意的是，在未开启ARC的情况下，如果变量附有__block修饰符，将不会被retain，因此反而可以避免循环引用的问题。 都可以用来让变量在block中可以修改，但是在非ARC模式下，block修饰符会避免循环引用。注意：block的循环引用并非block修饰符引起，而是由其本身的特性引起的。 __block底层实现__block:传值和传址,Block_byref_a_0对象包装局部变量，block拷贝到堆时__Block_byref_a_0也会被底层拷贝到堆，即使局部变量所在堆被销毁，block依然能对堆中的局部变量进行操作（__forwarding）。 __block:变量变成__block_breaf_val_0结构体，包含实例本身引用__forwarding，通过他访问实例变量val，保证栈复制到堆能正常访问__block，堆block持有堆上__block变量。 当栈block拷贝到堆会将__forwarding的值替换为对上__block变量地址。 当一个__block变量从栈上被复制到堆上时，栈上的那个__Block_byref_i_0结构体中的__forwarding指针也会指向堆上的结构。 __Block_byref_i_0结构体，main函数释放的时候，只是释放了栈上的东西。而所有的对局部变量的修改都已经转移到堆上了。 两个成员：__isa（对象），__forwarding（指向自己活另一个bref结构） KVO，KVCKVC：字符串非访问器访问对象实例变量。isa-swizzling就是类型混合指针机制。方法名-&gt;环境参数-&gt;结合isa找到接口-&gt;再找到实现 KCO：对象属性被修改会通知当前对象。运行期动态创建派生类，重写setter方法（isa指向他） GCDGCD：基于核心XNU内核实现，放在libdispatch库中，queue：管理block操作。source：处理事件（通讯） CGD纯C，NSO基于GCD封装。GCD只支持FIFO，NSO可调整顺序，设置并发数。GCD设置依赖代码复杂，NSO简单设置依赖。NSO支持KVO监听状态。GCD速度要快。 JSPatch：Runtime，使用JS利用OC的动态特性，执行我们想要执行的代码。 Rac：native-js bridge，以 JavaScript 的形式告诉 Objective-C 该执行什么代码。 RuntimeRuntime内存布局对象isa指向真实类型，Class的isa指向metaclass，metaclass的isa指向最上层metaclass（NSObject），最上层指向自己。实例方法-&gt;对象的methodList，类方法-&gt;metaclass的methodList isa：维护分发表的对象的类 SEL：是方法选择器（selector）的类型，根据方法名字生成唯一ID，字符串。 Method：是方法（method）的类型 IMP：函数指针，指向方法的实现（首地址），可跳过消息机制。 MethodMethod=SEL+IMP+method_type。SEL与IMP直线的映射（Dispatch Table：将方法的名字（SEL）跟方法的实现（IMP，指向 C 函数的指针）一一对应。Swizzle 一个方法其实就是在程序运行时在 Dispatch Table 里做点改动，让这个方法的名字（SEL）对应到另个 IMP）。 成员变量与属性的区别成员变量地址可根据实例的内存地址偏移寻址。而属性的读写都需要函数调用，相对更慢。 对于复杂的C++类型，往往设为成员变量更合适，也许这种类型不支持copy，或者完全复制很麻烦。 多线程环境下，为保证数据一致性，在需要同步执行的代码段更应该使用成员变量。如果对需要同步更新的数据用getter/setter 方法，数据更新效率低，会带来更多的获取锁请求失败。 成员变量可以做直观的内存管理。属性可以一层层继承，还可以复写。容易出错。 默认用属性，会生成不必要的getter/setter 方法，程序体积会变大。 权限1.如果只是单纯的private变量，最好声明在implementation里.2.如果是类的public属性，就用property写在.h文件里3.如果自己内部需要setter和getter来实现一些东西，就在.m文件的类目里用property来声明 使用关联对象方法混淆NSCoding(归档和解档, 利用runtime遍历模型对象的所有属性)字典 –&gt; 模型 (利用runtime遍历模型对象的所有属性, 根据属性名从字典中取出对应的值, 设置到模型的属性上)KVO(利用runtime动态产生一个类)用于封装框架(想怎么改就怎么改) 这就是我们runtime机制的只要运用方向 RunLoop（至少一个事件源）简介事件接收和分发机制的一个实现，一种异步执行代码的机制，不能并行执行任务。作用是： 保证程序执行的线程不会被系统终止。 两种源事件:input sources和timer sources。input sources 传递异步事件，通常是来自其他线程和不同的程序中的消息； timer sources(定时器) 传递同步事件（重复执行或者在特定时间上触发）。 原理1&gt;当有时间发生时,Runloop会根据具体的事件类型通知应用程序作出相应; 2&gt;当没有事件发生时,Runloop会进入休眠状态,从而达到省电的目的; 3&gt;当事件再次发生时,Runloop会被重新唤醒,处理事件. 提示:一般在开发中很少会主动创建Runloop,而通常会把事件添加到Runloop中. iOS 开发中能遇到两个线程对象: pthread_t 和 NSThread。过去苹果有份文档标明了 NSThread 只是 pthread_t 的封装，但那份文档已经失效了，现在它们也有可能都是直接包装自最底层的 mach thread RunLoop 的销毁是发生在线程结束时一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。 实现unLoop 的核心是基于 mach port 的，其进入休眠时调用的函数是 mach_msg()，RunLoop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个 iOS 的 App，然后在 App 静止时点击暂停，你会看到主线程调用栈是停留在 mach_msg_trap() 这个地方。 应用：AutoreleasePool，事件响应，手势识别，界面更新，定时器，PerformSelecter，关于GCD，关于网络请求，AFNetworking，AsyncDisplayKit 多线程多线程介绍与底层实现线程：1个进程要想执行任务，必须得有线程.线程是进程的基本执行单元，一个进程（程序）的所有任务都在线程中执行 底层：Mach是第一个以多线程方式处理任务的系统，因此多线程的底层实现机制是基于Mach的线程。 锁synchronized：互斥锁，@synchronized(obj)指令使用的obj为该锁的唯一标识，只有当标识相同时，才为满足互斥 dispatch_semaphore是GCD用来同步的一种方式 NSLock:Cocoa提供最基本的锁对象 NSRecursiveLock:递归锁，这个锁可以被同一线程多次请求，而不会引起死锁 NSCondition:条件锁(NSConditionLock)。手动控制线程wait和signal pthread_mutex/pthread_mutex(recursive) OSSpinLock：自旋锁，性能最高（do while 忙等） OSSpinLock和dispatch_semaphore的效率远远高于其他。@synchronized和NSConditionLock效率较差。鉴于OSSpinLock的不安全，所以我们在开发中如果考虑性能的话，建议使用dispatch_semaphore。如果不考虑性能，只是图个方便的话，那就使用@synchronized。 测试：黑盒：在软件的接口处进行，不考虑程序内部的逻辑结构和内部特性，只依据程序的需求规格 测试：对软件的过程性细节做细致的检查利用程序内部的逻辑结构及有关信息，对程序所有逻辑路径进行测试 测试：介于白黑盒之间，灰盒测试关注输出对于输入的正确性，同时也关注内部表现。 内存相关字段weak与strong：强&amp;弱引用，是否负责销毁（循环引用问题），strong让编译器帮我插入retain，weak相当于assign，对象不再有strong指向会释放，weak就会清除环迅，置nil（weak）。分别对应MRC的retain，assign，避免循环引用使用weak assign与weak：assign指针赋值，不操作引用计数，没有置nil，有野指针。delloc操作使用assign，weak已经找不到了（多了一步nil）。 strong与retain：属性时一样，block时strong=copy，retain==assign。保持与强的区别。不可变对象copy=retain copy与retain：copy（深：内容拷贝），建立相同对象（拷贝），retain（浅：指针拷贝） __weak,__strong:前者打破环（打破环），后者局部变量，栈中（block结束后回收）===不会循环引用 weakify(),strongify():局部strong引用计数+1，pop时不会dealloc，strong持有对象，block结束。局部回收。 autorreleaseautorrelease：建立pool，生成对象，调用autorrelease（标记，提醒后面release），结束pool需要release，每个对象release一次（不能大于1） autorrelease：延迟调用，对象放到当前autorrelease pool中，pool释放时，所持有所有对象release autorrelease：避免频繁申请/释放内存，每个函数自己负责（谁拥有谁释放），不需关系内部管理，使用线程自动维护，主循环结束前释放。 autorrelease：栈中（进出），对象释放，从池中删除自己，池中CCMutableArray（存储结构）。不是根据作用域来决定释放时机是依据runloop，本次runloop迭代结束时清理掉被本次迭代期间被放到autorelease pool中的对象的，发送- autorelease消息，就是将这个对象加入到当前AutoreleasePoolPage的栈顶next指针指向的位置 nonatomicnonatomic:非原子性访问,不加同步,多线程并发访问会提高性能. 网络请求状态码：三个十进制，第一个定义类型，后面才是详细（100信息，200成功，300重定向，400客户端错误如找不到，500服务器错误） 三次握手：客户端发送信号包到服务器，进入send状态，等待确认。服务器收到信号包，确认并发送信号（+确认信号）包给客户端，进入recv状态。客户端收到服务器信号包，发送信号（确认包）给服务器。完成，开始传输数据。 冲突：避免同一文件修改（使用桥接），选择性提交（实时），避免查看Xib，记住备份。project.文件，Nib删除多余，或者重新拉取。 协议相关IP：网络层 TCP（传输控制）：传输层，链接，可靠安全，慢，数据大。传输的是字节流 UDP（用户数据包，广播式）：传输层，不连接（单向），不可靠，快，数据小 HTTP（基于TCP，超文本传输）：应用层，数据如何包装。http协议和基于http协议的Soap协议。传输的是数据包 TCP/IP（传输控制协议/网际协议，一系列）:传输层，数据如何传输 Socket（套接字，网络协议的传输层）：TCP/IP网络的API（包装），不是协议，是接口，通过他才能使用TCP/IP Http&amp;SocketHttp（）：短连接，相应后断开。应用级接口方便，要求不高。但是传输慢，数据大，实时服务器压力大，安全差。 Socket（快，安全，实时）：长连接，不会主动断开（心跳包）。传输字节，可定义，量小，时间段，性能高，适合实时交互，可加密，安全强。但是需要解析传输数据，开发要求高，增加开发量。 XMPP（即时通讯的传输协议）：基于XML的协议，使用TCP传输XML，使用Socket开发，基于TCP/IP协议，核心类XMPPStream，对象GCDAsynSocket封装C中输入流，输出流，基于模块开发。有网关，服务器，客户端。 ReactiveCocoa：函数响应式编程（FRP）框架。以后使用RAC解决问题，就不需要考虑调用顺序，直接考虑结果，把每一次操作都写成一系列嵌套的方法中，使代码高聚合，方便管理。 JSON&amp;XMLJSON（SAX，时间模型：触摸和回调）：轻量级交换，逐行解析（遍历字符，根据规则{}[];）-&gt;编，解，体，交，传。 XML（DOM，树型结构）：可拓展标记，整个文档（父子遍历） 加密：网络（url编码，加密/加盐，post/网络传输,二次验证），本地（H5，js，plist/sqlite/defaults数据,keychain）,代码（方法体/结构/逻辑混淆） 可逆=对称（加密和解密使用同一个算法）：DES,AES。非对称：RSA，DSA。不可逆（消息摘要）：MD5，SHA。电子签名：确认消费发送方身份。 程序启动：main-&gt;UIApplication-&gt;代理-&gt;主循环，监听事件-&gt;调用didFinishLaunching创建Window-&gt;设置根控制-&gt;info.plist中storyboard有就设置根控制器-&gt;初始化自对应的子View显示-&gt;plist文件storyBoard没有就didFinishLaunching设置根控制器didFinishLaunching-&gt;初始化自对应的子View显示 页面执行顺序（View）==加载：alloc-&gt;initXX-&gt;loadView-&gt;viewDidLoad-&gt;viewWillApp-&gt;viewDidiApp-&gt;viewWillLayoutSubviews-&gt;viewDidLayoutSubviews==卸载：viewWillDis-&gt;viewDidDis-&gt;viewDidUnload-&gt;didReceiveMemoryWarning-&gt;dealloc TableView执行顺序：numOfSec-&gt;heightForHeader-&gt;heaghtForFooter-&gt;numOfRow-&gt;heightForHeader-&gt;heaghtForFooter-&gt;numOfRow-&gt;heightForRow-&gt;cellForRow-&gt;WillDisPlayCell tagged Pointer64（13年9-5s-A7）位tagged Pointer（标识+数据）：对象中内存对齐，地址是指针的整数倍（16的倍数），64位的整数，为了对齐，一些为永远为0，tagged Pointer利用这个特性，使得非零位有了特殊含义，64位中，如果对象指针最低有效位为1（奇数），则为tagged Pointer：不是通过isa找类，通过接下来三位的类表索引找对应的类。剩下60位供使用（NSNumber，NSString） load&amp;initilizeload：首次加载（一次），main之前 initilize：首次初始化（一次），init之前，更适合写代码（懒加载） 分类：将category和主（元）类注册到哈希表，如果主（元）类已经实现，重建方法列表。实例方法和属性-&gt;主类，类方法-&gt;元类。分类中协议-&gt;主类/元类 求交集：排序、索引（空间换时间），压缩（减小范围） coreData与多线程（每个线程一个context）：manager context私有，persistent store coordinator私有或者共享。 UIView&amp;CaLayerUIView：UIKit（iOS），集成UIReaponder，多了一个事件处理功能，对CALayer高层封装，需要CALayer支持， CALayer：QuartzCore（OS+iOS），集成NSObject，动画需要加到这里。UIView依靠他才能显示 音视频编解码H264（mov）:编码层视频压缩格式(协议层rtmp与http)，视频编码层(VCL)与网络提取层（NAL）VideoToolbox（AVKit和AVFoudation，Core Me/Vi）ios8-C ACC（wav）:基于MPEG-2的音频编码技术（取代mp3），ADIF（音频数据交换格式）和ADTS（音频数据传输流） M3U8：描述多媒体文件地址的纯文本文件 合并H264+ACC=MP4：FFmpeg推流(LFLiveKit)，使用拉流ijkPlayer，视频和音频数据使用FFmpeg封装为MPEG-TS包和MP4文件。 FLV封装格式是由一个FLV Header文件头和一个一个的Tag组成的。Tag中包含了音频数据以及视频数据 ios10+xcode8:打印，证书管理，各种权限，字体变大，Nib警告，openUrl废弃，插件，导航栏适配，Nib兼容，推送。 图片缓存图片：下载-&gt;处理-&gt;写磁盘-&gt;读到缓冲区-&gt;赋值到用户空间-&gt;解压为位图-&gt;字节对齐-&gt;渲染解压 异步下载，子线程解压，使用缓存（内存/磁盘），存储，减少内存级拷贝与字节对齐，预下载 NSCache：自动删除，减少内存，线程安全，不会被赋值（NSM） 数字签名：指定信息使用哈希算法，得到固定长度的信息摘要，使用私钥对该摘要加密，就得到了数字签名（代码签名） 优化：cell的重用，减少cell中控件的数量，少使用addView ，按需加载cell，缓存行高（属性及内容），使用局部更新（避免cell的重新布局），不要使用ClearColor，加载网络数据，下载图片，使用异步加载，并缓存，不要实现无用的代理方法，避免渐变，图像缩放以及离屏绘制，使用shadowPath来设置阴影，适当的数据结构来保存，恒定高度非delegate，不要使用富文本（缓存），，，， 刷新 layoutSubviews layoutIfNeeded setNeedsLayout setNeedsDisplay drawRect sizeThatFits sizeToFit 大概常用的上面几个 ， 具体的应该还有别的。 layoutSubviews这个方法，默认没有做任何事情，需要子类进行重写 。 系统在很多时候会去调用这个方法： 1.初始化不会触发layoutSubviews，但是如果设置了不为CGRectZero的frame的时候就会触发。 2.addSubview会触发layoutSubviews 3.设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化 4.滚动一个UIScrollView会触发layoutSubviews 5.旋转Screen会触发父UIView上的layoutSubviews事件 6.改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件 在苹果的官方文档中强调: You should override this method only if the autoresizing behaviors of the subviews do not offer the behavior you want.layoutSubviews, 当我们在某个类的内部调整子视图位置时，需要调用。反过来的意思就是说：如果你想要在外部设置subviews的位置，就不要重写。 setNeedsLayout标记为需要重新布局，不立即刷新，但layoutSubviews一定会被调用 配合layoutIfNeeded立即更新 layoutIfNeeded如果，有需要刷新的标记，立即调用layoutSubviews进行布局 所以上面不管写多少约束的改变，只需要在动画里动用 一次self.view.layoutIfNeeded() ,所有的都会已动画的方式 。如果一些变化不想动画 。在动画前执行self.view.layoutIfNeeded() drawRect这个方法是用来重绘的。 drawRect在以下情况下会被调用： 1、如果在UIView初始化时没有设置rect大小，将直接导致drawRect不被自动调用。drawRect调用是在Controller-&gt;loadView, Controller-&gt;viewDidLoad 两方法之后掉用的.所以不用担心在控制器中,这些View的drawRect就开始画了.这样可以在控制器中设置一些值给View(如果这些View draw的时候需要用到某些变量值). 2、该方法在调用sizeToFit后被调用，所以可以先调用sizeToFit计算出size。然后系统自动调用drawRect:方法。3、通过设置contentMode属性值为UIViewContentModeRedraw。那么将在每次设置或更改frame的时候自动调用drawRect:。4、直接调用setNeedsDisplay，或者setNeedsDisplayInRect:触发drawRect:，但是有个前提条件是rect不能为0。以上1,2推荐；而3,4不提倡 drawRect方法使用注意点：1、若使用UIView绘图，只能在drawRect：方法中获取相应的contextRef并绘图。如果在其他方法中获取将获取到一个invalidate的ref并且不能用于画图。drawRect：方法不能手动显示调用，必须通过调用setNeedsDisplay 或者 setNeedsDisplayInRect，让系统自动调该方法。 2、若使用calayer绘图，只能在drawInContext: 中（类似于drawRect）绘制，或者在delegate中的相应方法绘制。同样也是调用setNeedDisplay等间接调用以上方法3、若要实时画图，不能使用gestureRecognizer，只能使用touchbegan等方法来掉用setNeedsDisplay实时刷新屏幕 sizeToFitsizeToFit会自动调用sizeThatFits方法； sizeToFit不应该在子类中被重写，应该重写sizeThatFits sizeThatFits传入的参数是receiver当前的size，返回一个适合的size sizeToFit可以被手动直接调用sizeToFit和sizeThatFits方法都没有递归，对subviews也不负责，只负责自己 内存 Leaked memory: Abandoned memory: Cached memory: Leaked memory 和 Abandoned memory 都属于应该释放而没释放的内存，都是内存泄露，而 Leaks 工具只负责检测 Leaked memory，而不管 Abandoned memory。在 MRC 时代 Leaked memory 很常见，因为很容易忘了调用 release，但在 ARC 时代更常见的内存泄露是循环引用导致的 Abandoned memory，Leaks 工具查不出这类内存泄露，应用有限。 对于 Abandoned memory，可以用 Instrument 的 Allocations 检测出来。检测方法是用 Mark Generation 的方式，当你每次点击 Mark Generation 时，Allocations 会生成当前 App 的内存快照，而且 Allocations 会记录从上回内存快照到这次内存快照这个时间段内，新分配的内存信息 在 GitHub 上有一些内存泄露检测相关的项目，例如 HeapInspector-for-iOS 和 MSLeakHunter。 HeapInspector-for-iOS 可以说是 Allocations 的改进。它通过 hook 掉 alloc，dealloc，retain，release 等方法，来记录对象的生命周期。具体的检测内存泄露的方法和原理，与 Instrument 的 Allocations 一致。然而它跟 Allocations 一样，存在的问题是，你需要一个个场景去重复的操作，还有检测不及时。 MSLeakHunter 就简单得多，它只检测 UIViewController 和 UIView，通过 hook 掉 UIViewController 的 -viewDidDisappear: 方法，并认为 -viewDidDisappear: 后，UIViewController 将很快被释放，如果 UIViewController 没有被释放，则打个建议日志。这种做法其实不是很好，-viewDidDisappear: 被调用可能是因为又 push 进来一个新的 ViewController，把当前的 ViewController 挡住了，所以可能有很多错误的建议，需要结合你实际的操作去具体地分析日志。 MLeaksFinder 提供了内存泄露检测更好的解决方案。只需要引入 MLeaksFinder，就可以自动在 App 运行过程检测到内存泄露的对象并立即提醒，无需打开额外的工具，也无需为了检测内存泄露而一个个场景去重复地操作。MLeaksFinder 目前能自动检测 UIViewController 和 UIView 对象的内存泄露，而且也可以扩展以检测其它类型的对象 原理MLeaksFinder 一开始从 UIViewController 入手。我们知道，当一个 UIViewController 被 pop 或 dismiss 后，该 UIViewController 包括它的 view，view 的 subviews 等等将很快被释放（除非你把它设计成单例，或者持有它的强引用，但一般很少这样做）。于是，我们只需在一个 ViewController 被 pop 或 dismiss 一小段时间后，看看该 UIViewController，它的 view，view 的 subviews 等等是否还存在。 具体的方法是，为基类 NSObject 添加一个方法 -willDealloc 方法，该方法的作用是，先用一个弱指针指向 self，并在一小段时间(3秒)后，通过这个弱指针调用 -assertNotDealloc，而 -assertNotDealloc 主要作用是直接中断言。 这样，当我们认为某个对象应该要被释放了，在释放前调用这个方法，如果3秒后它被释放成功，weakSelf 就指向 nil，不会调用到 -assertNotDealloc 方法，也就不会中断言，如果它没被释放（泄露了），-assertNotDealloc 就会被调用中断言。这样，当一个 UIViewController 被 pop 或 dismiss 时（我们认为它应该要被释放了），我们遍历该 UIViewController 上的所有 view，依次调 -willDealloc，若3秒后没被释放，就会中断言。 设计模式简单工厂，工厂方法，抽象方法都不需要知道具体类，把容易发生改变的地方封装起来，控制变化（哪里变化封装哪里），以适应客户端变动，项目拓展。 简单工厂：一个工厂的各种产品，创建一个类中，客户端无需知道具体产品名称，只要知道对应的参数，但是工厂的责任太重，且类过多时不利于维护与拓展。 一般对各种不同产品的构造函数的封装，需要一个标志产品参数以生产不同的产品。 工厂方法：在简单工厂下增加一个产品就要修改工厂类，不符合开闭，工厂方法下只需要增加具体工厂和产品就可以。 有一个工厂的抽象类，实现不同的具体工厂，每个子类工厂生产不同的产品 抽象工厂：类似一个产品族，一个产品的界面可以通过直接改变具体的工厂实例来改变风格。 类似工厂方法，但是每个子类工厂生产一个产品族，而不是一个产品。 特点简单工厂模式：专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。它又称为静态工厂方法模式。它的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。简单工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实例。在这个模式中，工厂类是整个模式的关键所在。它包含必要的判断逻辑，能够根据外界给定的信息，决定究竟应该创建哪个具体类的对象。用户在使用时可以直接根据工厂类去创建所需的实例，而无需了解这些对象是如何创建以及如何组织的。有利于整个软件体系结构的优化。 工厂方法模式：工厂方法是粒度很小的设计模式，因为模式的表现只是一个抽象的方法。提前定义用于创建对象的接口，让子类决定实例化具体的某一个类，即在工厂和产品中间增加接口，工厂不再负责产品的创建，由接口针对不同条件返回具体的类实例，由具体类实例去实现。工厂方法模式是简单工厂模式的衍生，解决了许多简单工厂模式的问题。首先完全实现‘开－闭 原则’，实现了可扩展。其次实现更复杂的层次结构，可以应用于产品结果复杂的场合。工厂方法模式是对简单工厂模式进行了抽象。有一个抽象的Factory类（可以是抽象类和接口），这个类将不在负责具体的产品生产，而是只制定一些规范，具体的生产工作由其子类去完成。在这个模式中，工厂类和产品类往往可以依次对应。即一个抽象工厂对应一个抽象产品，一个具体工厂对应一个具体产品，这个具体的工厂就负责生产对应的产品。 抽象工厂模式：抽象工厂模式是所有形态的工厂模式中最为抽象和最具一般性的一种形态。抽象工厂模式是指当有多个抽象角色时，使用的一种工厂模式。抽象工厂模式可以向客户端提供一个接口，使客户端在不必指定产品的具体的情况下，创建多个产品族中的产品对象。它有多个抽象产品类，每个抽象产品类可以派生出多个具体产品类，一个抽象工厂类，可以派生出多个具体工厂类，每个具体工厂类可以创建多个具体产品类的实例。每一个模式都是针对一定问题的解决方案，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式针对的是多个产品等级结果。 优点简单工厂模式：工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅&quot;消费&quot;产品。简单工厂模式通过这种做法实现了对责任的分割。简单工厂模式能够根据外界给定的信息，决定究竟应该创建哪个具体类的对象。通过它，外界可以从直接创建具体产品对象的尴尬局面中摆脱出来。外界与具体类隔离开来，偶合性低。明确区分了各自的职责和权力，有利于整个软件体系结构的优化。 工厂方法模式：工厂方法模式是为了克服简单工厂模式的缺点（主要是为了满足OCP）而设计出来的。简单工厂模式的工厂类随着产品类的增加需要增加很多方法（或代码），而工厂方法模式每个具体工厂类只完成单一任务，代码简洁。工厂方法模式完全满足OCP，即它有非常良好的扩展性。 抽象工厂模式：抽象工厂模式主要在于应对“新系列”的需求变化。分离了具体的类，抽象工厂模式帮助你控制一个应用创建的对象的类，因为一个工厂封装创建产品对象的责任和过程。它将客户和类的实现分离，客户通过他们的抽象接口操纵实例，产品的类名也在具体工厂的实现中被分离，它们不出现在客户代码中。它使得易于交换产品系列。一个具体工厂类在一个应用中仅出现一次——即在它初始化的时候。这使得改变一个应用的具体工厂变得很容易。它只需改变具体的工厂即可使用不同的产品配置，这是因为一个抽象工厂创建了一个完整的产品系列，所以整个产品系列会立刻改变。它有利于产品的一致性。当一个系列的产品对象被设计成一起工作时，一个应用一次只能使用同一个系列中的对象，这一点很重要，而抽象工厂很容易实现这一点。抽象工厂模式有助于这样的团队的分工，降低了模块间的耦合性，提高了团队开发效率。 缺点简单工厂模式：当产品有复杂的多层等级结构时，工厂类只有自己，以不变应万变，就是模式的缺点。因为工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，有可能造成工厂逻辑过于复杂,违背了&quot;开放--封闭&quot;原则(OCP).另外，简单工厂模式通常使用静态工厂方法，这使得无法由子类继承，造成工厂角色无法形成基于继承的等级结构。 工厂方法模式：不易于维护，假如某个具体产品类需要进行一定的修改，很可能需要修改对应的工厂类。当同时需要修改多个产品类的时候，对工厂类的修改会变得相当麻烦（对号入座已经是个问题了）。 抽象工厂模式：抽象工厂模式在于难于应付“新对象”的需求变动。难以支持新种类的产品。难以扩展抽象工厂以生产新种类的产品。这是因为抽象工厂几乎确定了可以被创建的产品集合，支持新种类的产品就需要扩展该工厂接口，这将涉及抽象工厂类及其所有子类的改变。 适用范围简单工厂模式：工厂类负责创建的对象比较少，客户只知道传入了工厂类的参数，对于始何创建对象（逻辑）不关心。 工厂方法模式：当一个类不知道它所必须创建对象的类或一个类希望由子类来指定它所创建的对象时，当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候，可以使用工厂方法。 抽象工厂模式：一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有形态的工厂模式都是重要的。这个系统有多于一个的产品族，而系统只消费其中某一产品族。同属于同一个产品族的产品是在一起使用的，这一约束必须在系统的设计中体现出来。系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于实现。 测试白盒测试和黑盒测试是软件测试的两种不同方法，任何工程产品(注意是任何工程产品)都可以使用二者之一进行测试： 白盒测试：是通过程序的源代码进行测试而不使用用户界面。这种类型的测试需要从代码句法发现内部代码在算法，溢出，路径，条件等等中的缺点或者错误，进而加以修正。 黑盒测试：是通过使用整个软件或某种软件功能来严格地测试, 而并没有通过检查程序的源代码或者很清楚地了解该软件的源代码程序具体是怎样设计的。测试人员通过输入他们的数据然后看输出的结果从而了解软件怎样工作。在测试时，把程序看作一个不能打开的黑盆子，在完全不考虑程序内部结构和内部特性的情况下，测试者在程序接口进行测试，它只检查程序功能是否按照需求规格说明书的规定正常使用，程序是否能适当地接收和正确的输出。 二者最大的区别应该就是测试对象不一样，白盒测试主要针对的是程序代码逻辑，黑盒测试主要针对的是程序所展现给用户的功能，简单的说就是前者测试后台程序后者测试前台展示功能。 什么是黑盒测试和白盒测试？任何工程产品（注意是任何工程产品）都可以使用以下两种方法之一进行测试。 黑盒测试：已知产品的功能设计规格，可以进行测试证明每个实现了的功能是否符合要求。 白盒测试：已知产品的内部工作过程，可以通过测试证明每种内部操作是否符合设计规格要求，所有内部成分是否以经过检查。 黑盒测试软件的黑盒测试意味着测试要在软件的接口处进行。这种方法是把测试对象看做一个黑盒子，测试人员完全不考虑程序内部的逻辑结构和内部特性，只依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明。因此黑盒测试又叫功能测试或数据驱动测试。 黑盒测试主要是为了发现以下几类错误：1、是否有不正确或遗漏的功能？ 2、在接口上，输入是否能正确的接受？能否输出正确的结果？ 3、是否有数据结构错误或外部信息（例如数据文件）访问错误？ 4、性能上是否能够满足要求？ 5、是否有初始化或终止性错误？ 白盒测试软件的白盒测试是对软件的过程性细节做细致的检查。这种方法是把测试对象看做一个打开的盒子，它允许测试人员利用程序内部的逻辑结构及有关信息，设计或选择测试用例，对程序所有逻辑路径进行测试。通过在不同点检查程序状态，确定实际状态是否与预期的状态一致。因此白盒测试又称为结构测试或逻辑驱动测试。 白盒测试主要是想对程序模块进行如下检查：1、对程序模块的所有独立的执行路径至少测试一遍。 2、对所有的逻辑判定，取“真”与取“假”的两种情况都能至少测一遍。 3、在循环的边界和运行的界限内执行循环体。 4、测试内部数据结构的有效性，等等。 以上事实说明，软件测试有一个致命的缺陷，即测试的不完全、不彻底性。由于任何程序只能进行少量（相对于穷举的巨大数量而言）的有限的测试，在未发现错误时，不能说明程序中没有错误。 灰盒测试灰盒测试，是介于白盒测试与黑盒测试之间的，可以这样理解，灰盒测试关注输出对于输入的正确性，同时也关注内部表现，但这种关注不象白盒那样详细、完整，只是通过一些表征性的现象、事件、标志来判断内部的运行状态，有时候输出是正确的，但内部其实已经错误了，这种情况非常多，如果每次都通过白盒测试来操作，效率会很低，因此需要采取这样的一种灰盒的方法。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>面试一</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生命之源-RunLoop]]></title>
    <url>%2F2017%2F03%2F10%2F%E7%94%9F%E5%91%BD%E4%B9%8B%E6%BA%90-RunLoop%2F</url>
    <content type="text"><![CDATA[iOS一切的生命之源都需要RunLoop的支持，关于RunLoop的界面和相关知识，网上想你一一搜一天也看不完，所以这里只为总结Runloop相关技术，适用于底层，面试，简单实战了解！ 前言：1+ 一个线程只能执行一个任务，任务执行完之后，线程就会退出，但是主线程不会退出，因为我们需要让主线程等待接收事件 介绍123456+ 运行循环（do-while）：不断处理各种事件+ 一个线程（唯一）对应一个RunLoop（可以嵌套子runloops），主线程默认启动，子线程手动启动（run）：获取RunLoop对象的时候，就会创建RunLoop+ RunLoop有多个Model，Model有多个timer（array）/source（set）/observer（array）。+ 每次启动只能启动一个，切换需要先推出在指定（分隔不同time/source/observer）+ 当前Model没有任何timer/source/observer就会推出（mode只能添加不能删除）+ 第一次获取创建，线程结束销毁 runloop退出的条件：1app退出；线程关闭；设置最大时间到期；modeItem为空； Ref12345+ CFRunLoopTimerRef，基于时间触发（NSTimer），受Model影响，GCD不受Model影响+ CFRunLoopSourceRef，事件源，source0（非Port），source1（Port），跟Port密切联系source0：event事件，只含有回调，需要标记待处理（signal），然后手动将runloop唤醒（wakeup）；source1 ：包含一个 mach_port 和一个回调，被用于通过内核和其他线程发送的消息，能主动唤醒runloop。 Runloop本质：mach port和mach_msg()。123Mach是XNU的内核，进程、线程和虚拟内存等对象通过端口发消息进行通信，Runloop通过mach_msg()函数发送消息，如果没有port 消息，内核会将线程置于等待状态 mach_msg_trap() 。如果有消息，判断消息类型处理事件，并通过modeItem的callback回调(处理事件的具体执行是在DoBlock里还是在回调里目前我还不太明白？？？)。Runloop有两个关键判断点，一个是通过msg决定Runloop是否等待，一个是通过判断退出条件来决定Runloop是否循环 定时源，输入源12+ 定时源，同步消息，特定或者一定时间间隔发生+ 输入源，来自起来线程或者程序 应用1+ NSTimer，ImageView显示，PerformSelector，常驻线程，自动释放池，界面刷新，手势识别，GCD任务，timer：（与CADisplayLink），网络请求： autorrelease释放时机：12+ 手动干预释放：指定autorreleasepool,当前作用域大括号结束立即释放+ 系统自动释放：不指定，aut对象在当前RunLoop迭代结束释放 自动释放池12自动释放池寄生于Runloop：程序启动后，主线程注册了两个Observer监听runloop的进出与睡觉。一个最高优先级OB监测Entry状态；一个最低优先级OB监听BeforeWaiting状态和Exit状态。线程(创建)--&gt;runloop将进入--&gt;最高优先级OB创建释放池--&gt;runloop将睡--&gt;最低优先级OB销毁旧池创建新池--&gt;runloop将退出--&gt;最低优先级OB销毁新池--&gt;线程(销毁) Timer注意121、如果是在主线程中运行timer，想要timer在某界面有视图滚动时，依然能正常运转，那么将timer添加到RunLoop中时，就需要设置mode 为NSRunLoopCommonModes。2、如果是在子线程中运行timer,那么将timer添加到RunLoop中后，Mode设置为NSDefaultRunLoopMode或NSRunLoopCommonModes均可，但是需要保证RunLoop在运行，且其中有任务。 runloop:121、（要让马儿跑）通过do-while死循环让程序持续运行：接收用户输入，调度处理事件时间。2、（要让马儿少吃草）通过mach_msg()让runloop没事时进入trap状态，节省CPU资源。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>RunLoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[想怎么转就怎么转]]></title>
    <url>%2F2017%2F03%2F07%2F%E6%83%B3%E6%80%8E%E4%B9%88%E8%BD%AC%E5%B0%B1%E6%80%8E%E4%B9%88%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[最近在做直播，用的是腾讯云，但是主播界面需要横屏显示，而且只能横屏，整个项目也只有这个界面横屏。发现腾讯云在这一块提供了对流的控制，但是并没有提供对界面的控制，需要自己去实现界面的控制，主要是界面各种交互，各种效果，各种逻辑，所以必须自己控制选择，期间也遇到了不少坑。所以就整理了一下，当然这里同样适合iPad适配，相信以后在屏幕旋转和旋转相关适配这一块应该是没有问题了！ 相关枚举：首先需要知道苹果提供的关于屏幕的一些枚举值UIDeviceOrientation：123456789typedef NS_ENUM(NSInteger, UIDeviceOrientation) &#123;UIDeviceOrientationUnknown,UIDeviceOrientationPortrait, // Device oriented vertically, home button on the bottomUIDeviceOrientationPortraitUpsideDown, // Device oriented vertically, home button on the topUIDeviceOrientationLandscapeLeft, // Device oriented horizontally, home button on the rightUIDeviceOrientationLandscapeRight, // Device oriented horizontally, home button on the leftUIDeviceOrientationFaceUp, // Device oriented flat, face upUIDeviceOrientationFaceDown // Device oriented flat, face down&#125;; UIInterfaceOrientation：1234567typedef NS_ENUM(NSInteger, UIInterfaceOrientation) &#123;UIInterfaceOrientationUnknown = UIDeviceOrientationUnknown,UIInterfaceOrientationPortrait = UIDeviceOrientationPortrait,UIInterfaceOrientationPortraitUpsideDown = UIDeviceOrientationPortraitUpsideDown,UIInterfaceOrientationLandscapeLeft = UIDeviceOrientationLandscapeRight,UIInterfaceOrientationLandscapeRight = UIDeviceOrientationLandscapeLeft&#125;; 从宏定义可知，device方向比interface多了两个定义：UIDeviceOrientationFaceUp和UIDeviceOrientationFaceDown，分别表示手机水平放置，屏幕向上和屏幕向下。 两种orientation：然后就是两种相关的orientationdevice orientation设备的物理方向，由类型UIDeviceOrientation表示，当前设备方向获取方式： 12// return current device orientation. this will return UIDeviceOrientationUnknown unless device orientation notifications are being generated.[UIDevice currentDevice].orientation //该属性的值一般是与当前设备方向保持一致的。 注意点1：推荐方式123456if (![UIDevice currentDevice].generatesDeviceOrientationNotifications) &#123;[[UIDevice currentDevice] beginGeneratingDeviceOrientationNotifications];&#125;NSLog(@"%d",[UIDevice currentDevice].orientation);[[UIDevice currentDevice] endGeneratingDeviceOrientationNotifications]; 注意点2：横竖屏关闭12如果关闭了系统的横竖屏切换开关，即系统层级只允许竖屏时，再通过上述方式获取到的设备方向将永远是UIDeviceOrientationUnknown。可以通过Core Motion中的CMMotionManager来获取当前设备方向。 interface orientation界面显示的方向，由类型UIInterfaceOrientation表示。当前界面显示方向有以下两种方式获取： 设备的物理方向，由类型UIDeviceOrientation表示，当前设备方向获取方式： 12NSLog(@"%d",[UIApplication sharedApplication].statusBarOrientation);NSLog(@"%d",viewController.interfaceOrientation); 即可以通过系统statusBar的方向或者viewController的方向来获取当前界面方向。 区别通过UIDevice获取到的设备方向在手机旋转时是实时的。通过UIApplication的statusBar或者viewController获取到的界面方向在下述方法：调用以后才会被更改成最新的值。 12NSLog(@"%d",[UIApplication sharedApplication].statusBarOrientation);NSLog(@"%d",viewController.interfaceOrientation); 相关方法123456789101112// Applications should use supportedInterfaceOrientations and/or shouldAutorotate..- (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation NS_DEPRECATED_IOS(2_0, 6_0);// New Autorotation support.- (BOOL)shouldAutorotate NS_AVAILABLE_IOS(6_0);- (NSUInteger)supportedInterfaceOrientations NS_AVAILABLE_IOS(6_0);// Returns interface orientation masks.- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation NS_AVAILABLE_IOS(6_0);// call this method when your return value from shouldAutorotateToInterfaceOrientation: changes// if the current interface orientation does not match the current device orientation, a rotation may occur provided all relevant view controllers now return YES from shouldAutorotateToInterfaceOrientation:+ (void)attemptRotationToDeviceOrientation NS_AVAILABLE_IOS(5_0); 如何旋转全局控制Info.plist文件中，有一个Supported interface orientations，可以配置整个应用的屏幕方向，此处为全局控制。 UIWindowiOS6的UIApplicationDelegate提供了下述方法，能够指定 UIWindow 中的界面的屏幕方向： 1- (NSUInteger)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window NS_AVAILABLE_IOS(6_0); 该方法默认值为Info.plist中配置的Supported interface orientations项的值。 iOS中通常只有一个window，所以此处的控制也可以视为全局控制。 controller只有以下两种情况： 当前controller是window的rootViewController当前controller是modal模式的时候，orientations相关方法才会起作用（才会被调用），当前controller及其所有的childViewController都在此作用范围内。 最终支持的屏幕方向前面所述的3种控制规则的交集就是一个controller的最终支持的方向； 如果最终的交集为空，在iOS6以后会抛出UIApplicationInvalidInterfaceOrientationException崩溃异常。 总结来说改变Orientation有三种途径当手机的重力感应打开的时候, 如果用户旋转手机, 系统会抛发UIDeviceOrientationDidChangeNotification 事件. 您可以分别设置Application和UIViewcontroller支持的旋转方向.Application的设置会影响整个App, UIViewcontroller的设置仅仅会影响一个viewController(IOS5和IOS6有所不同,下面会详细解释). 当UIKit收到UIDeviceOrientationDidChangeNotification事件的时候, 会根据Application和UIViewcontroller的设置, 如果双方都支持此方向, 则会自动屏幕旋转到这个方向. 更code的表达就是, 会对两个设置求与,得到可以支持的方向. 如果求与之后,没有任何可支持的方向, 则会抛发UIApplicationInvalidInterfaceOrientationException异常. 当然，你还可以对View进行旋转，但是这样会有一些需求上的问题，比如状态栏，键盘等就没有办法，只能自己通过其他方式控制！1234567891011121314151617UIView.transform//设置statusBar[[UIApplication sharedApplication] setStatusBarOrientation:orientation];//计算旋转角度float arch;if (orientation == UIInterfaceOrientationLandscapeLeft)arch = -M_PI_2;else if (orientation == UIInterfaceOrientationLandscapeRight)arch = M_PI_2;elsearch = 0;//对navigationController.view 进行强制旋转self.navigationController.view.transform = CGAffineTransformMakeRotation(arch);self.navigationController.view.bounds = UIInterfaceOrientationIsLandscape(orientation) ? CGRectMake(0, 0, SCREEN_HEIGHT, SCREEN_WIDTH) : initialBounds; 当然我们可以对当前viewController进行旋转, 对任何view旋转都可以.但是, 你会发现navigationBar还横在那里. 所以, 我们最好对一个占满全屏的view进行旋转. 在这里我们旋转的对象是self.navigationController.view, 当然self.window也可以, help yourself~我们需要显式的设置bounds. UIKit并不知道你偷偷摸摸干了这些事情, 所以没法帮你自动设置. 具体实现借助通知来控制界面的横竖屏切换。还是整个App中大部分界面都是竖屏，某个界面可以横竖屏切换的情况。首选这只plist只支持竖屏：Portrait（Home朝下） 然后在特殊的视图控制器里的ViewDidLoad中注册通知： 123456789101112131415161718192021222324252627282930313233343536[[UIDevice currentDevice] beginGeneratingDeviceOrientationNotifications];[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(deviceOrientationDidChange) name:UIDeviceOrientationDidChangeNotification object:nil];通知方法的实现过程：- (void)deviceOrientationDidChange&#123;NSLog(@"deviceOrientationDidChange:%ld",(long)[UIDevice currentDevice].orientation);if([UIDevice currentDevice].orientation == UIDeviceOrientationPortrait) &#123;[[UIApplication sharedApplication] setStatusBarOrientation:UIInterfaceOrientationPortrait];[self orientationChange:NO];//注意： UIDeviceOrientationLandscapeLeft 与 UIInterfaceOrientationLandscapeRight&#125; else if ([UIDevice currentDevice].orientation == UIDeviceOrientationLandscapeLeft) &#123;[[UIApplication sharedApplication] setStatusBarOrientation:UIInterfaceOrientationLandscapeRight];[self orientationChange:YES];&#125;&#125;- (void)orientationChange:(BOOL)landscapeRight&#123;if (landscapeRight) &#123;[UIView animateWithDuration:0.2f animations:^&#123;self.view.transform = CGAffineTransformMakeRotation(M_PI_2);self.view.bounds = CGRectMake(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);&#125;];&#125; else &#123;[UIView animateWithDuration:0.2f animations:^&#123;self.view.transform = CGAffineTransformMakeRotation(0);self.view.bounds = CGRectMake(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);&#125;];&#125;&#125;// 用到的两个宏：#define SCREEN_WIDTH ([UIScreen mainScreen].bounds.size.width)#define SCREEN_HEIGHT ([UIScreen mainScreen].bounds.size.height) 最重要的一点:需要重写如下方法，并且返回NO。这样，在设备出于横屏时，界面就会变成横屏，设备处于竖屏时，界面就会变成竖屏。 1234- (BOOL)shouldAutorotate&#123;return NO;&#125; 但是这样会遇到两个坑上面方式二，因为【General】–&gt;【Device Orientation】因为只设置了竖屏，所以当横屏时，如果有键盘弹出，键盘是竖屏时的样式。解决办法：在【General】–&gt;【Device Orientation】中加上横屏时的方向。 如果VieController 是放在UINavigationController或者UITabBarController中，需要重写它们的方向控制方法。 123456789101112131415161718192021// UINavigationController：- (BOOL)shouldAutorotate&#123;return [self.topViewController shouldAutorotate];&#125;- (UIInterfaceOrientationMask)supportedInterfaceOrientations&#123;return [self.topViewController supportedInterfaceOrientations];&#125;// UITabBarController:- (BOOL)shouldAutorotate&#123;return [self.selectedViewController shouldAutorotate];&#125;- (UIInterfaceOrientationMask)supportedInterfaceOrientations&#123;return [self.selectedViewController supportedInterfaceOrientations];&#125; 如果想要点击某个按钮之后，强制将竖屏显示的界面变成横屏呢？有人可能会想到这样写: 12345// 横屏- (IBAction)landscapAction:(id)sender &#123;[[UIApplication sharedApplication] setStatusBarOrientation:UIInterfaceOrientationLandscapeRight];[self orientationChange:YES];&#125; 但是按照上面的写法，会导致返回到之前的界面时，视图方向错误，即使返回前执行如下代码： 12[[UIApplication sharedApplication] setStatusBarOrientation:UIInterfaceOrientationPortrait];[self orientationChange:NO]; 结果发现也没有作用，下面是在开源工程中无意看到的写法： 12345678910111213141516171819202122// 横屏- (IBAction)landscapAction:(id)sender &#123;[self interfaceOrientation:UIInterfaceOrientationLandscapeRight];&#125;// 竖屏- (IBAction)portraitAction:(id)sender &#123;[self interfaceOrientation:UIInterfaceOrientationPortrait];&#125;- (void)interfaceOrientation:(UIInterfaceOrientation)orientation&#123;if ([[UIDevice currentDevice] respondsToSelector:@selector(setOrientation:)]) &#123;SEL selector = NSSelectorFromString(@"setOrientation:");NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:[UIDevice instanceMethodSignatureForSelector:selector]];[invocation setSelector:selector];[invocation setTarget:[UIDevice currentDevice]];int val = orientation;[invocation setArgument:&amp;val atIndex:2];[invocation invoke];&#125;&#125; 通过属性控制项目需求（场景）： 整个项目不需要旋转（当然了，所有方向的屏幕适配都做好的情况下是没问题的，但是没有必要这么劳民伤财。）的前提下，播放界面控制器需要支持屏幕的其他方向的旋转。 先设置：targets——&gt;general——&gt;device Orientation——&gt;支持的旋转方向在 AppDelegate.m 里面1234567-(UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window &#123;if (self.allowRotation) &#123;//当允许时，支持所有方向return UIInterfaceOrientationMaskAll;&#125;//否则 就只有竖屏return UIInterfaceOrientationMaskPortrait;&#125; 在你想要支持 旋转的控制器 需要导入#import “AppDelegate.h”12345678910111213141516171819- (void)viewWillAppear:(BOOL)animated &#123;[super viewWillAppear:animated];self.navigationController.navigationBarHidden = YES;//改变AppDelegate的appdelegete.allowRotation属性AppDelegate *appdelegete = (AppDelegate *)[UIApplication sharedApplication].delegate;appdelegete.allowRotation = YES;&#125;- (void)viewWillDisappear:(BOOL)animated&#123;[super viewWillDisappear:animated];self.navigationController.navigationBarHidden = NO;AppDelegate *appdelegete = (AppDelegate *)[UIApplication sharedApplication].delegate;appdelegete.allowRotation = NO;&#125; 当你写完这些的时候发现好像可以了，还有问题。但你横屏播放的状态下 直接返回上个控制器（pop）的时候.发现那个控制器也是横屏的（当你竖屏时，它会转过来，但是再旋转就不行了。问题就是pop回来不能使横屏啊，应该直接竖屏才是啊）比如pop回的那个控制器叫 TextViewController在TextViewController.m里 1234//屏幕方向操作-(UIInterfaceOrientationMask)supportedInterfaceOrientations&#123;return UIInterfaceOrientationMaskPortrait;&#125; 此方法是UIKit框架中UIViewController.h的公布方法，iOS 6.0后加入 总结关于屏幕旋转这一块并不难，苹果提供了很多现成的方式，或者说只需要调用方法，当然还是根据具体需求进行调整。适当的控制对应的控件，调用相应的方法，那么不管是iPhone还是iPad你想怎么转就怎么转！]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>屏幕旋转</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前世-内存管理]]></title>
    <url>%2F2017%2F03%2F03%2F%E5%89%8D%E4%B8%96-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[最近越来越发觉，自己做了这么久iOS开发，似乎都是在瞎玩，回望这一路写的App，写的代码，以及上线的App，又有几个自己真的非常满意的？说道这里，不得不提的是：我相信不止我一个人有这种感触，代码写久了，自己都不知道自己在写撒，就连上线都是个意外。这一路走来我一直在总结，也在回望，到底自己哪里出了问题，终于发现：终究是自己不敢面对而已，底层不了解，只知道敲。 因为换了电脑，换了工作，换了新的环境，也换了一个不一样的心情重新开始探索之路，所以之前的博客地址也停止更新了，如果你对iOS相关知识感兴趣或者有什么疑问和建议可以联系我，或者直接在下面评论， 本来打算这个博客中不会再写iOS的东西，但是最近一直上班，也找了一段时间公司，总之感触不少，现在这个行情，大家都懂的。 前段时间也整理了一些东西，我相信值得一看。 1原则：没有强指针指向对象，对象就会被释放。 MRC-ARC123ARC：LLVM3.0（iOS5，Xcode4）前段编译器：方法内创建对象，末尾自动插入release销毁。类拥有对象，在dealloc内释放。更底层的C语言实现。objc_release,objc_retain优化调用过程ARC优化器：负责移除多余的插入，和一些引用的优化。包括运行期组件。 关于循环12345weak：循环引用，自身强引用，IBOutlet。非拥有，不保留也不释放，置nil，weak必须用于OC对象，assign非OC对象for循环：只有当自动释放器被release，池中的表示autorrelease对象才会被释放===内存耗尽，没有释放-&gt;内存泄露1.i比较大：使用@autorreleasepool&#123;&#125;，在for外面，循环结束，销毁创建对象，解决占据栈内存问题。2.i玩命大：一次循环都会自动释放池满，@autorreleasepool&#123;&#125;放在for里面，每次循环前将上一次对象release。 关于内存12内存布局：没有多继承，所以布局简单最前面isa，指向类。父类实例变量在子类实例变量之前。 关于线程123456789界面线程维护自己的线程池。自己创建的线程数据，需要创建线程的内存池。autorreleasepool实现：objc_autorreleasepool=Push,Pop,objc_autorrelease每次RunLoop完成一个循环的时候，都会检测对象的retainCount，为0则没有使用，释放。内存管理的范围：集成自NSObject对象，基本数据类型无效。因为存储空间不同，基本数据存在栈区。对象在堆中，代码块结束，涉及局部变量弹栈清空，指向对象指针回收，对象没有指针指向，但是还在堆中，所以内存泄露了。unowned（unsafe_unretained）：对象销毁不会为空，但是更快，因为weak需要unwrap。 常见状态管理1234567野指针:指针变量没有初始化，指向的空间被释放。调用方法报异常，崩溃。release后，地址nil，OC中没有空指针异常内存泄露：对象提前赋值nil，导致release不起作用。没有配对释放或者清空。栈区释放了，堆区没有释放。最终导致内存溢出内存溢出：容量超出使用限制僵尸对象：堆中已经被释放的对象count=0空指针：指针赋值为nil判断对象销毁：dealloc（需要super一下），已经释放的对象无法复活 对象关系123集成：组合：（包含关系），确保成员连边不被提前释放，重写set方法，retain一下。成员变量在dealloc中配对释放。内存泄露：1.set没有retain对象，2.没有release旧对象，3.没有判断set方法传入是否是同一对象依赖：（对象作为方法参数传递） autorrelease（pool）/垃圾回收机制1234autorrelease：把该对象放入自动释放池，自动释放池释放时，内部对象引用计数-1。NSAutorreleasePool：通过接受对象向他发送的release消息，记录该对象的release消息，自动释放池销毁时，向池中记录release的对象发送release消息。 垃圾回收机制：autorrelease只是延迟释放，GC是每隔一段时间询问程序，是否有无指针指向的对象，没有就释放 自动释放池123456自动释放池： 1.存储多想对象类型的指针变量（可以嵌套） 2.作用：将对象与自动释放池建议关系，池子内调用autorrelease，在自动释放池销毁时销毁对象，延迟release销毁时间 3.对池内对象作用：存入池中的对象，池销毁，全部对象release一次 4.调用autorrelease将对象加入自动释放池，多次调用导致野指针异常 5.释放时机：简单：autorrelease的&#125;执行完后。实际：Autorrelease对象是在当前RunLoop迭代结束时释放，原因是：系统在每个RunLoop迭代中加入了自动释放池Push，Pop 关键字12345block中多次使用weakSelf（延迟操作，导致取不到弱指针），可以block种先使用strongSelf，防止执行是weakSelf意外释放，对于非ARCweak改为block就可以release和drain：ARC中一样，GC中release无效操作，所以无论是否为GC使用drain没有问题。copy：OC对象类型如果有mutable，深拷贝，新对象为count=1，没有为浅拷贝，count+1. 其他总结1234567891011通过Observer监听RunLoop状态，一旦监听到RunLoop即将进入休眠等状态，就释放自动释放池。FIFO：新访问的数据插入队列尾部，数据在队列中移动，淘汰头部数据。LRU（FIFO相反），LFU循环引用：定时器（timer作为类的成员变量，self-target,不使用记得invalidate），Blcok（block在copy时对内部对象强引用（ARC）或者引用计数+1（MRC）），代理：（assign（MRC），weak（ARC））通知：多对多，主要跨层传值。对象加入到通知中心后，对象被销毁前没有将对象从通知中心移除，当再次发送通知的时候，会崩溃。默认关键字：基本数据类型（atomic，readwrite，assign），OC对象类型（atomic，readwrite，strong）TableView代理用assign：控制器对内部的View进行了一次retain，TableView对代理控制器也retain一次就会循环引用。 其实知道了这个并不证明就能写出好的代码，还需要时间的沉淀，不断的尝试，不断的思考与总结。感谢你能看到最后，希望对你有用，我们下次再见！]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[温馨提示]]></title>
    <url>%2F2017%2F03%2F01%2F%E6%B8%A9%E9%A6%A8%E6%8F%90%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[嗨，欢迎来到梦工厂，我是曹理鹏 (@iCocos)，一名 iOS(+游戏)/ 前端 开发者，后端开发学习中，希望做点有意义的事情。现居广州，正在修行，探求创意之源。。 12345微信：clpaial10201119 / QQ：2211523682博客(前后端)：https://icocos.github.io/博客(iOS)：http://al1020119.github.io/github：https://github.com/al1020119个人网站：http://www.icocos.cn/ 由于学习，技术方向的原因，本人之前github博客将会停止更新，之前所有文章偏向技术，并且主要针对iOS基础，底层，面试与实战，此后将会停止更新此博客，并将所有新发布文章，更新至当前博客地址，届时会不定时在公众号，和微博发布相关动态。 此博客将会保函以下内容： iOS实战经验(+游戏) 前端开发相关技术 后端开发学习 读书笔记与后感 个人业余爱好 其他原创杂文 如果你想了解更多关于作者，或者关于iOS，前后端，和个人关注内容，请关注我的个人公众号，也可以通过微信，QQ，Github联系我，也可以直接在这里评论留言。 同时，如果对我的文章有一些意见或者建议，也欢迎联系我，我们一起共进退！]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>iCocos</tag>
        <tag>提示</tag>
      </tags>
  </entry>
</search>
