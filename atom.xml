<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>iCocos</title>
  
  <subtitle>www.icocos.cn</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://icocos.github.io/"/>
  <updated>2018-08-22T15:37:09.220Z</updated>
  <id>https://icocos.github.io/</id>
  
  <author>
    <name>曹理鹏@iCocos</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS——请求依赖多种解决方案</title>
    <link href="https://icocos.github.io/2018/08/23/iOS%E2%80%94%E2%80%94%E8%AF%B7%E6%B1%82%E4%BE%9D%E8%B5%96%E5%A4%9A%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://icocos.github.io/2018/08/23/iOS——请求依赖多种解决方案/</id>
    <published>2018-08-22T18:39:08.000Z</published>
    <updated>2018-08-22T15:37:09.220Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>iOS开发中如何解决网络请求的依赖关系(同时应用于业务层)</p><ul><li>比如：一个(或多个)接口的请求需要依赖于另一个(或多个)网络请求的结果？</li></ul></li><li><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><ul><li>操作依赖 – NSOperation</li><li>逻辑判断 – if/else</li><li>线程同步 – 组队列</li><li>线程同步 – 阻塞任务</li><li>线程同步 – 信号量机制</li></ul></li></ul><a id="more"></a><h3 id="操作依赖-–-NSOperation"><a href="#操作依赖-–-NSOperation" class="headerlink" title="操作依赖 – NSOperation"></a>操作依赖 – NSOperation</h3><p>NSOperation 操作依赖和优先级（不适用，异步网络请求并不是立刻返回，无法保证回调时再开启下一个网络请求）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// Do any additional setup after loading the view, typically from a nib.</span><br><span class="line">//创建队列</span><br><span class="line">NSOperationQueue *queue=[[NSOperationQueue alloc] init];</span><br><span class="line">//创建操作</span><br><span class="line">NSBlockOperation *operation1=[NSBlockOperation blockOperationWithBlock:^()&#123;</span><br><span class="line">    NSLog(@<span class="string">"执行第1次操作，线程：%@"</span>,[NSThread currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line">NSBlockOperation *operation2=[NSBlockOperation blockOperationWithBlock:^()&#123;</span><br><span class="line">    NSLog(@<span class="string">"执行第2次操作，线程：%@"</span>,[NSThread currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line">NSBlockOperation *operation3=[NSBlockOperation blockOperationWithBlock:^()&#123;</span><br><span class="line">    NSLog(@<span class="string">"执行第3次操作，线程：%@"</span>,[NSThread currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line">//添加依赖</span><br><span class="line">[operation1 addDependency:operation2];</span><br><span class="line">[operation2 addDependency:operation3];</span><br><span class="line">//将操作添加到队列中去</span><br><span class="line">[queue addOperation:operation1];</span><br><span class="line">[queue addOperation:operation2];</span><br><span class="line">[queue addOperation:operation3];</span><br></pre></td></tr></table></figure><h3 id="逻辑判断-–-if-else"><a href="#逻辑判断-–-if-else" class="headerlink" title="逻辑判断 – if/else"></a>逻辑判断 – if/else</h3><p>上一个网络请求的响应回调后，下一网络请求的才开始执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NSString *urlString = @<span class="string">"http://www.icocos.cn"</span>;</span><br><span class="line">    </span><br><span class="line">AFHTTPSessionManager *manger =[AFHTTPSessionManager manager];</span><br><span class="line">    </span><br><span class="line">[manger GET:urlString parameters:nil progress:^(NSProgress * _Nonnull downloadProgress) &#123;</span><br><span class="line">    </span><br><span class="line">&#125; success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</span><br><span class="line">    NSLog(@<span class="string">"成功"</span>);</span><br><span class="line">    /////////////////////////////////////////////</span><br><span class="line">    // TODO： 执行下一个请求</span><br><span class="line">    /////////////////////////////////////////////</span><br><span class="line">&#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class="line">    NSLog(@<span class="string">"%@"</span>,error);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>但是这样会存在一个概率性的问题，就会有可能根本拿不到结果，或者由于网络慢和用户操作之间的关系导致不可预料的问题。</p><h3 id="线程同步-–-组队列（dispatch-group）"><a href="#线程同步-–-组队列（dispatch-group）" class="headerlink" title="线程同步 – 组队列（dispatch_group）"></a>线程同步 – 组队列（dispatch_group）</h3><p>dispatch_group是GCD(Grand Central Dispatch)中的一组方法，他有一个组的概念，可以把相关的任务归并到一个组内来执行，通过监听组内所有任务的执行情况来做相应处理。</p><ul><li>1.dispatch_group_async<ul><li>将代码块dispatch_block_t block放入队列dispatch_queue_t queue中执行；并和调度组dispatch_group_t group相互关联；如果提交到dispatch_queue_t queue中的block全都执行完毕会调用dispatch_group_notify并且dispatch_group_wait会停止等待；</li></ul></li><li>2.dispatch_group_enter(group)、dispatch_group_leave(group)<ul><li>和内存管理的引用计数类似，我们可以认为group也持有一个整形变量(只是假设)，当调用enter时计数加1，调用leave时计数减1，当计数为0时会调用dispatch_group_notify并且dispatch_group_wait会停止等待；</li></ul></li><li>3.dispatch_group_notify<ul><li>当关联到dispatch_group_t上的dispatch_group_async任务执行完毕或者是关联在上面的dispatch_group_enter、dispatch_group_leave成对出现了。参数中的dispatch_block_t block会被提交到dispatch_queue_t queue中执行。 </li></ul></li><li>4.dispatch_group_wait<ul><li>和dispatch_group_notify功能类似(多了一个dispatch_time_t参数可以设置超时时间)，在group上任务完成前，dispatch_group_wait会阻塞当前线程(所以不能放在主线程调用)一直等待；当group上任务完成，或者等待时间超过设置的超时时间会结束等待； </li></ul></li><li>5………..</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">bashdispatch_queue_t dispatchQueue = dispatch_queue_create(&quot;icocos.queue.next&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    dispatch_queue_t globalQueue = dispatch_get_global_queue(0, 0);</span><br><span class="line">    dispatch_group_t dispatchGroup = dispatch_group_create();</span><br><span class="line">    dispatch_group_async(dispatchGroup, dispatchQueue, ^()&#123;</span><br><span class="line">        </span><br><span class="line">        dispatch_async(globalQueue, ^&#123;</span><br><span class="line">           </span><br><span class="line">            sleep(5);</span><br><span class="line">            NSLog(@&quot;请求任务一完成&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_group_async(dispatchGroup, dispatchQueue, ^()&#123;</span><br><span class="line">        </span><br><span class="line">        dispatch_async(globalQueue, ^&#123;</span><br><span class="line">            </span><br><span class="line">            sleep(8);</span><br><span class="line">            NSLog(@&quot;请求任务二完成&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_group_notify(dispatchGroup, dispatch_get_main_queue(), ^()&#123;</span><br><span class="line">        NSLog(@&quot;notify：请求任务都完成了&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程同步-–阻塞任务（dispatch-barrier）："><a href="#线程同步-–阻塞任务（dispatch-barrier）：" class="headerlink" title="线程同步 –阻塞任务（dispatch_barrier）："></a>线程同步 –阻塞任务（dispatch_barrier）：</h3><p>一个dispatch barrier 允许在一个并发队列中创建一个同步点。当在并发队列中遇到一个barrier, 他会延迟执行barrier的block,等待所有在barrier之前提交的blocks执行结束。 这时，barrier block自己开始执行。 之后， 队列继续正常的执行操作。</p><blockquote><p>调用这个函数总是在barrier block被提交之后立即返回，不会等到block被执行。当barrier block到并发队列的最前端，他不会立即执行。相反，队列会等到所有当前正在执行的blocks结束执行。到这时，barrier才开始自己执行。所有在barrier block之后提交的blocks会等到barrier block结束之后才执行。</p></blockquote><ul><li>dispatch_barrier_async函数的作用<ul><li>1.实现高效率的数据库访问和文件访问</li><li>2.避免数据竞争</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/* 创建并发队列 */</span><br><span class="line">dispatch_queue_t concurrentQueue = dispatch_queue_create(<span class="string">"test.concurrent.queue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">/* 添加两个并发操作A和B，即A和B会并发执行 */</span><br><span class="line">dispatch_async(concurrentQueue, ^()&#123;</span><br><span class="line">    NSLog(@<span class="string">"请求OperationA"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(concurrentQueue, ^()&#123;</span><br><span class="line">    NSLog(@<span class="string">"请求OperationB"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">/* 添加barrier障碍操作，会等待前面的并发操作结束，并暂时阻塞后面的并发操作直到其完成 */</span><br><span class="line">dispatch_barrier_async(concurrentQueue, ^()&#123;</span><br><span class="line">    NSLog(@<span class="string">"请求OperationBarrier!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">/* 继续添加并发操作C和D，要等待barrier障碍操作结束才能开始 */</span><br><span class="line">dispatch_async(concurrentQueue, ^()&#123;</span><br><span class="line">    NSLog(@<span class="string">"请求OperationC"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(concurrentQueue, ^()&#123;</span><br><span class="line">    NSLog(@<span class="string">"请求OperationD"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="线程同步-–-信号量机制（dispatch-semaphore）："><a href="#线程同步-–-信号量机制（dispatch-semaphore）：" class="headerlink" title="线程同步 – 信号量机制（dispatch_semaphore）："></a>线程同步 – 信号量机制（dispatch_semaphore）：</h3><ul><li>信号量：<ul><li>就是一种可用来控制访问资源的数量的标识，设定了一个信号量，在线程访问之前，加上信号量的处理，则可告知系统按照我们指定的信号量数量来执行多个线程。</li></ul></li></ul><blockquote><p>其实，这有点类似锁机制了，只不过信号量都是系统帮助我们处理了，我们只需要在执行线程之前，设定一个信号量值，并且在使用时，加上信号量处理方法就行了。</p></blockquote><h5 id="信号量主要有3个函数"><a href="#信号量主要有3个函数" class="headerlink" title="信号量主要有3个函数"></a>信号量主要有3个函数</h5><pre><code>创建信号量，参数：信号量的初值，如果小于0则会返回NULLdispatch_semaphore_create（信号量值）//等待降低信号量dispatch_semaphore_wait（信号量，等待时间）//提高信号量dispatch_semaphore_signal(信号量)</code></pre><p>注意，正常的使用顺序是先降低然后再提高，这两个函数通常成对使用。　</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">- (void)getToken</span><br><span class="line">&#123;</span><br><span class="line">    //以上请求的设置忽略</span><br><span class="line">    NSURLSessionDataTask *task = [mySession dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">            NSLog(@<span class="string">"get Token"</span>);</span><br><span class="line">            //拿到token，传给request请求做参数</span><br><span class="line">            [self request:token];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            NSLog(@<span class="string">"token error:%@"</span>,error.description);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;];</span><br><span class="line">    [task resume];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)request:(NSString *)params</span><br><span class="line">&#123;</span><br><span class="line">    //请求的设置忽略</span><br><span class="line">    NSURLSessionDataTask *task = [mySession dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">            NSLog(@<span class="string">"request success"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            NSLog(@<span class="string">"request error:%@----"</span>,error.description);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [task resume];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 指定调用</span><br><span class="line">- (IBAction)buttonPress:(UIButton *)sender</span><br><span class="line">&#123;</span><br><span class="line">    //创建一个并行队列</span><br><span class="line">    dispatch_queue_t queque = dispatch_queue_create(<span class="string">"GoyakodCreated"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    //异步执行</span><br><span class="line">    dispatch_async(queque, ^&#123;</span><br><span class="line">        dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</span><br><span class="line">        [self getToken:semaphore];</span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        [self request];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    NSLog(@<span class="string">"main thread"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)getToken:(dispatch_semaphore_t)semaphore</span><br><span class="line">&#123;</span><br><span class="line">    //以上请求的设置忽略</span><br><span class="line">    NSURLSessionDataTask *task = [mySession dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">            NSLog(@<span class="string">"get Token"</span>);</span><br><span class="line">           //成功拿到token，发送信号量:</span><br><span class="line">            dispatch_semaphore_signal(semaphore);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            NSLog(@<span class="string">"token error:%@"</span>,error.description);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;];</span><br><span class="line">    [task resume];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;iOS开发中如何解决网络请求的依赖关系(同时应用于业务层)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比如：一个(或多个)接口的请求需要依赖于另一个(或多个)网络请求的结果？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h4 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;操作依赖 – NSOperation&lt;/li&gt;
&lt;li&gt;逻辑判断 – if/else&lt;/li&gt;
&lt;li&gt;线程同步 – 组队列&lt;/li&gt;
&lt;li&gt;线程同步 – 阻塞任务&lt;/li&gt;
&lt;li&gt;线程同步 – 信号量机制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://icocos.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://icocos.github.io/tags/iOS/"/>
    
      <category term="网络层" scheme="https://icocos.github.io/tags/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title> 开发必备理论常识：HTTP-&gt;HTTPS</title>
    <link href="https://icocos.github.io/2018/08/18/%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E7%90%86%E8%AE%BA%E5%B8%B8%E8%AF%86%EF%BC%9AHTTP-HTTPS/"/>
    <id>https://icocos.github.io/2018/08/18/开发必备理论常识：HTTP-HTTPS/</id>
    <published>2018-08-18T05:11:14.000Z</published>
    <updated>2018-08-11T05:17:58.997Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li><p>超文本传输协议（HTTP，HyperText Transfer Protocol)</p><ul><li>是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。</li></ul></li><li><p>HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer）</p><ul><li>是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 </li></ul></li></ul><p>HTTPS句法类同http:体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。</p><a id="more"></a><h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><p>HTTP是一个基于TCP的协议,而TCP是一种可靠的传输层协议.</p><blockquote><p>TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。WEB使用HTTP协议作应用层协议，以封装HTTP 文本信息，然后使用TCP/IP做传输层协议将它发到网络上。</p></blockquote><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><blockquote><p>HTTP+加密+认证+完整性保护=HTTPS</p></blockquote><p>是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p><ul><li>HTTPS协议的主要作用可以分为两种：<ul><li>一种是建立一个信息安全通道，来保证数据传输的安全；</li><li>另一种就是确认网站的真实性。</li></ul></li></ul><p>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。</p><h3 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL/TLS"></a>SSL/TLS</h3><ul><li><p>SSL：（Secure Socket Layer，安全套接字层）</p><ul><li>位于可靠的面向连接的网络层协议和应用层协议之间的一种协议层。SSL通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯。该协议由两层组成：SSL记录协议和SSL握手协议。</li></ul></li><li><p>TLS：（Transport Layer Security，传输层安全协议）</p><ul><li>用于两个应用程序之间提供保密性和数据完整性。该协议由两层组成：TLS记录协议和TLS握手协议。</li></ul></li></ul><p>SSL是Netscape开发的专门用于保护Web通讯的，目前版本为3.0.最新版本的TLS 1.0是IETE（工程任务组）指定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本。两者差别极小，可以理解为SSL 3.1，它是写入了RFC的。　　</p><ul><li><p>SSL的作用</p><ul><li><p>（1）、认证用户和服务器，确保数据发送到正确的客户机和服务器；</p></li><li><p>（2）、加密数据以防止数据中途被窃取；</p></li><li><p>（3）、维护数据的完整性，确保数据在传输过程中不被改变。</p></li></ul></li></ul><p>而SSL证书指的是在SSL通信中验证通信双方身份的数字文件，一般分为服务器证书和客户端证书，我们通常说的SSL证书主要指服务器证书，SSL证书由受信任的数字证书颁发机构CA（如VeriSign，GlobalSign，WoSign等），在验证服务器身份后颁发，具有服务器身份验证和数据传输加密功能，分为扩展验证型(EV)SSL证书、组织验证型(OV)SSL证书、和域名验证型（DV）SSL证书。</p><h3 id="CA证书"><a href="#CA证书" class="headerlink" title="CA证书"></a>CA证书</h3><blockquote><p>CA（Certificate Authority）是负责管理和签发证书的第三方权威机构，是所有行业和公众都信任的、认可的。</p></blockquote><p>CA证书，就是CA颁发的证书，可用于验证网站是否可信（针对HTTPS）、验证某文件是否可信（是否被篡改）等，也可以用一个证书来证明另一个证书是真实可信，最顶级的证书称为根证书。除了根证书（自己证明自己是可靠），其它证书都要依靠上一级的证书，来证明自己。</p><h3 id="HTTP-amp-HTTPS区别："><a href="#HTTP-amp-HTTPS区别：" class="headerlink" title="HTTP&amp;HTTPS区别："></a>HTTP&amp;HTTPS区别：</h3><p>简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</p><ol><li>https协议需要到ca申请证书或自制证书。</li><li>http的信息是明文传输，https则是具有安全性的ssl加密。</li><li>http是直接与TCP进行数据传输，而https是经过一层SSL（OSI表示层），用的端口也不一样，前者是80（需要国内备案），后者是443。</li><li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li></ol><p>HTTP&amp;HTTPS综合区别：<a href="https://blog.csdn.net/hanjianqiang2468/article/details/52605849" target="_blank" rel="noopener">https://blog.csdn.net/hanjianqiang2468/article/details/52605849</a></p><blockquote><p>注意: https加密是在传输层</p></blockquote><p>https报文在被包装成tcp报文的时候完成加密的过程，无论是https的header域也好，body域也罢都是会被加密的。</p><p>当使用tcpdump或者wireshark之类的tcp层工具抓包，获取是加密的内容，而如果用应用层抓包，使用Charels(Mac)、Fildder(Windows)抓包工具，那当然看到是明文的。</p><h3 id="握手过程"><a href="#握手过程" class="headerlink" title="握手过程"></a>握手过程</h3><h5 id="HTTP三次握手"><a href="#HTTP三次握手" class="headerlink" title="HTTP三次握手"></a>HTTP三次握手</h5><p><img src="http://pd1l3bbt7.bkt.clouddn.com/2018/common/http_s/http_https_001.png" alt="曹理鹏(iCocos)-梦工厂"></p><p>HTTP（HyperText Transfer Protocol)超文本传输协议是互联网上应用最为广泛的一种网络协议。由于信息是明文传输，所以被认为是不安全的。而关于HTTP的三次握手，其实就是使用三次TCP握手确认建立一个HTTP连接。</p><blockquote><p>SYN（synchronous）是TCP/IP建立连接时使用的握手信号、Sequence number（序列号）、Acknowledge number（确认号码），三个箭头指向就代表三次握手，完成三次握手，客户端与服务器开始传送数据。</p></blockquote><ul><li><p>第一次握手：</p><ul><li>客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；</li></ul></li><li><p>第二次握手：</p><ul><li>服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li></ul></li><li><p>第三次握手：</p><ul><li>客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</li></ul></li></ul><h6 id="建立TCP连接时会发生-三次握手-three-way-handshake"><a href="#建立TCP连接时会发生-三次握手-three-way-handshake" class="headerlink" title="建立TCP连接时会发生:三次握手(three-way handshake)"></a>建立TCP连接时会发生:三次握手(three-way handshake)</h6><ul><li>firefox &gt; nginx [SYN] 在么</li><li>nginx &gt; firefox [SYN, ACK] 在</li><li>firefox &gt; nginx [ACK] 知道了</li></ul><h5 id="为什么断开需要四次握手"><a href="#为什么断开需要四次握手" class="headerlink" title="为什么断开需要四次握手:"></a>为什么断开需要四次握手:</h5><p>关于四次握手的详细过程这里就不过多介绍，请自行百度，这里简单说一下需要执行的步骤，和为什么连接是三次，二断开时四次</p><h6 id="关闭TCP连接时会发生-四次挥手-four-way-handshake"><a href="#关闭TCP连接时会发生-四次挥手-four-way-handshake" class="headerlink" title="关闭TCP连接时会发生:四次挥手(four-way handshake)"></a>关闭TCP连接时会发生:四次挥手(four-way handshake)</h6><ul><li>firefox &gt; nginx [FIN] 我要关闭连接了</li><li>nginx &gt; firefox [ACK] 知道了,等我发完包先</li><li>nginx &gt; firefox [FIN] 我也关闭连接了</li><li>firefox &gt; nginx [ACK] 好的,知道了</li></ul><h6 id="解释原因："><a href="#解释原因：" class="headerlink" title="解释原因："></a>解释原因：</h6><ul><li>TCP建立连接要进行3次握手,而断开连接要进行4次,这是由于TCP的半关闭造成的,因为TCP连接是全双工的(</li><li>即数据可在两个方向上同时传递)所以进行关闭时每个方向上都要单独进行关闭,这个单方向的关闭就叫半关闭.</li><li>关闭的方法是一方完成它的数据传输后,就发送一个FIN来向另一方通告将要终止这个方向的连接.当一端收到一个FIN,它必须</li><li>通知应用层TCP连接已终止了这个方向的数据传送,发送FIN通常是应用层进行关闭的结果.</li></ul><h6 id="另一种解释："><a href="#另一种解释：" class="headerlink" title="另一种解释："></a>另一种解释：</h6><ul><li>这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。</li></ul><blockquote><p>补充</p></blockquote><blockquote><blockquote><p>SYN: synchronization(同步)</p></blockquote></blockquote><blockquote><blockquote><p>ACK: acknowledgement(确认:告知已收到)</p></blockquote></blockquote><blockquote><blockquote><p>FIN: finish(结束)</p></blockquote></blockquote><h5 id="HTTPS握手："><a href="#HTTPS握手：" class="headerlink" title="HTTPS握手："></a>HTTPS握手：</h5><p><img src="http://pd1l3bbt7.bkt.clouddn.com/2018/common/http_s/http_https_002.png" alt="曹理鹏(iCocos)-梦工厂"></p><p>HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。具体是如何进行加密，解密，验证的，且看下图，下面的称为一次握手。</p><ul><li><p>1.客户端发起HTTPS请求</p></li><li><p>2.服务端的配置</p><ul><li>采用HTTPS协议的服务器必须要有一套数字证书，可以是自己制作或者CA证书。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用CA证书则不会弹出提示页面。这套证书其实就是一对公钥和私钥。公钥给别人加密使用，私钥给自己解密使用。</li></ul></li><li><p>3.传送证书</p><ul><li>这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等。</li></ul></li><li><p>4.客户端解析证书</p><ul><li>这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值，然后用证书对该随机值进行加密。</li></ul></li><li><p>5.传送加密信息</p><ul><li>这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</li></ul></li><li><p>6.服务段解密信息</p><ul><li>服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</li></ul></li><li><p>7.传输加密后的信息</p><ul><li>这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。</li></ul></li><li><p>8.客户端解密信息</p><ul><li>客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。</li></ul></li></ul><blockquote><p>注意: HTTPS中整个握手过程第三方即使监听到了数据，也束手无策。</p></blockquote><h6 id="为什么HTTPS是安全的？"><a href="#为什么HTTPS是安全的？" class="headerlink" title="为什么HTTPS是安全的？"></a>为什么HTTPS是安全的？</h6><blockquote><p>在HTTPS握手的第四步中，如果站点的证书是不受信任的，会显示出现下面确认界面，确认了网站的真实性。另外第六和八步，使用客户端私钥加密解密，保证了数据传输的安全。</p></blockquote><hr><h3 id="app与后台通信完整流程"><a href="#app与后台通信完整流程" class="headerlink" title="app与后台通信完整流程"></a>app与后台通信完整流程</h3><ul><li>1.建立连接：前台后台建立连接。 </li><li>2.发送请求：打开连接后，app向后台发送请求。</li><li>3.发送响应：后台处理完请求后，要向app发送响应消息。 <ul><li>后台通过关键词：路径映射，Dispatcher分发机制等方式处理app的请求</li></ul></li><li>4.断开连接：以上交互完成后可以断开连接了。</li></ul><h3 id="浏览器执行过程"><a href="#浏览器执行过程" class="headerlink" title="浏览器执行过程"></a>浏览器执行过程</h3><ul><li>1.首先嘛，你得在浏览器里输入要网址:</li><li>2.浏览器查找域名的IP地址</li><li>3.浏览器给web服务器发送一个HTTP请求</li><li>4.facebook服务的永久重定向响应.服务器给浏览器响应一个301永久重定向响应，这样浏览器就会问“<a href="http://www.facebook.com/”" target="_blank" rel="noopener">http://www.facebook.com/”</a> 而非“<a href="http://facebook.com/”。" target="_blank" rel="noopener">http://facebook.com/”。</a></li><li>5.浏览器跟踪重定向地址.浏览器知道了“<a href="http://www.facebook.com/”才是要访问的正确地址，所以它会发送另一个获取请求：" target="_blank" rel="noopener">http://www.facebook.com/”才是要访问的正确地址，所以它会发送另一个获取请求：</a></li><li>6.服务器“处理”请求.服务器接收到获取请求，然后处理并返回一个响应。</li><li>7.服务器发回一个HTML响应.</li><li>8.浏览器开始显示HTML.</li><li>9.浏览器发送获取嵌入在HTML中的对象。在浏览器显示HTML时，它会注意到需要获取其他地址内容的标签。这时，浏览器会发送一个获取请求来重新获得这些文件。</li><li>10.浏览器发送异步（AJAX）请求。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;超文本传输协议（HTTP，HyperText Transfer Protocol)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;HTTPS句法类同http:体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。&lt;/p&gt;
    
    </summary>
    
      <category term="Others" scheme="https://icocos.github.io/categories/Others/"/>
    
    
      <category term="开发" scheme="https://icocos.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="HTTP+HTTPS" scheme="https://icocos.github.io/tags/HTTP-HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>iOS(OC+cocos2dx)游戏APP磁盘空间爆增(文稿与数据)</title>
    <link href="https://icocos.github.io/2018/08/16/iOS-OC-cocos2dx-%E6%B8%B8%E6%88%8FAPP%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E7%88%86%E5%A2%9E-%E6%96%87%E7%A8%BF%E4%B8%8E%E6%95%B0%E6%8D%AE/"/>
    <id>https://icocos.github.io/2018/08/16/iOS-OC-cocos2dx-游戏APP磁盘空间爆增-文稿与数据/</id>
    <published>2018-08-16T15:45:06.000Z</published>
    <updated>2018-08-17T01:53:47.674Z</updated>
    
    <content type="html"><![CDATA[<p>这段时间在开发公司的新产品二次元游戏(<a href="https://zhongchou.modian.com/item/26767.html?_ga=2.202445201.1279037149.1534326302-1820221530.1531384229" target="_blank" rel="noopener">零下记忆</a>)，由于接触coco2dx不久，很多东西还在摸索，也没少加班，所以都没有时间整理和发文了。</p><p>但是最近(从周一开始),发现了一个特别其他的Bug，App磁盘数据报增，幸好我手机是64G的，不然估计会爆炸！</p><p>先来张爆图！</p><p><img src="http://pd1l3bbt7.bkt.clouddn.com/cocos2dx/data/cocos2dx_data001.png" alt="曹理鹏(iCocos)-梦工厂"></p><a id="more"></a><p>这个产品是在Objective-C原生架构的基础上接入cocos2dx(C++)，所以导致部分文件或者类需要使用MRC模式。</p><h5 id="我曾尝试过"><a href="#我曾尝试过" class="headerlink" title="我曾尝试过"></a>我曾尝试过</h5><ol><li>使用模拟器针对不同时段操作，计算沙盒文件大小。</li><li>借助部门同事的越狱机导包寻找导致爆增的具体文件。</li><li>多次删除App，关闭可能存在问题原因的代码。</li><li>借助内存泄漏框架自动记录，内存变化与位置。</li><li>借助Xcode自带Instrument定点查找具体位置和代码。</li><li>通过Stack Overflow查询更多可能导致的原因。</li></ol><p>经过一次次排查，和一个个问题的处理，最终通过多次杀进程，和运行测试，终于处理完成，不过还有待优化！ </p><h6 id="下面是具体原因和流程。"><a href="#下面是具体原因和流程。" class="headerlink" title="下面是具体原因和流程。"></a>下面是具体原因和流程。</h6><h3 id="清理缓存："><a href="#清理缓存：" class="headerlink" title="清理缓存："></a>清理缓存：</h3><h5 id="清理cocos2dx缓存："><a href="#清理cocos2dx缓存：" class="headerlink" title="清理cocos2dx缓存："></a>清理cocos2dx缓存：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CCAnimationCache::purgeSharedAnimationCache();</span><br><span class="line">CCSpriteFrameCache::purgeSharedSpriteFrameCache();</span><br><span class="line">CCTextureCache::purgeSharedTextureCache();</span><br><span class="line">    </span><br><span class="line">CCSpriteFrameCache::sharedSpriteFrameCache()-&gt;removeUnusedSpriteFrames();</span><br><span class="line">CCTextureCache::sharedTextureCache()-&gt;removeUnusedTextures();</span><br><span class="line">CCTextureCache::sharedTextureCache()-&gt;removeAllTextures();</span><br><span class="line"></span><br><span class="line">Director::getInstance()-&gt;getTextureCache()-&gt;removeAllTextures();</span><br></pre></td></tr></table></figure><h5 id="清理运行磁盘，内存或者缓存"><a href="#清理运行磁盘，内存或者缓存" class="headerlink" title="清理运行磁盘，内存或者缓存"></a>清理运行磁盘，内存或者缓存</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">+ (void)clearAllCache &#123;</span><br><span class="line">    [[SDImageCache sharedImageCache] clearMemory];</span><br><span class="line">    [[SDImageCache sharedImageCache] clearDiskOnCompletion:nil];</span><br><span class="line">    // 拿到cachePath路径的下一级目录的子文件夹</span><br><span class="line">    // contentsOfDirectoryAtPath:error:递归</span><br><span class="line">    // subpathsAtPath:不递归</span><br><span class="line">    NSArray *subpathArray = [fileManager contentsOfDirectoryAtPath:cachePath error:nil];</span><br><span class="line">    // 如果数组为空，说明没有缓存或者用户已经清理过，此时直接<span class="built_in">return</span></span><br><span class="line">    <span class="keyword">if</span> (subpathArray.count == 0) &#123;</span><br><span class="line"><span class="comment">#ifdef DEBUG</span></span><br><span class="line">        NSLog(@<span class="string">"cachePath缓存清理完成"</span>);</span><br><span class="line"><span class="comment">#else</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">    &#125;</span><br><span class="line">    NSError *error = nil;</span><br><span class="line">    NSString *filePath = nil;</span><br><span class="line">    BOOL flag = NO;</span><br><span class="line">    <span class="keyword">for</span> (NSString *subpath <span class="keyword">in</span> subpathArray) &#123;</span><br><span class="line">        filePath = [cachePath stringByAppendingPathComponent:subpath];</span><br><span class="line">        <span class="keyword">if</span> ([fileManager fileExistsAtPath:cachePath]) &#123;</span><br><span class="line">            // 删除子文件夹</span><br><span class="line">            BOOL isRemoveSuccessed = [fileManager removeItemAtPath:filePath error:&amp;error];</span><br><span class="line">            <span class="keyword">if</span> (isRemoveSuccessed) &#123; // 删除成功</span><br><span class="line">                flag = YES;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (NO == flag) &#123;</span><br><span class="line"><span class="comment">#ifdef DEBUG</span></span><br><span class="line">        NSLog(@<span class="string">"已经清理了所有可以访问的文件,不可访问的文件无法删除"</span>);  // 调试阶段才打印</span><br><span class="line"><span class="comment">#else</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>记忆中此处大概处理了1-3G</p></blockquote><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>通过Stack Overflow和相应代码调试最后发现：</p><blockquote><p>原来是把sprite和控件都retain了，需要手动release，才能释放图片。</p></blockquote><p>所以我得找到对应的cocos2dx项目代码，对创建和操作的对象进行release操作，这里比较蛋疼，得一个个找！</p><ul><li>处理中遇到个问题：<ul><li>removeTexture执行release后，不管有没有被gl释放掉，都从列表里删除。</li></ul></li></ul><p>但是如果load进来的node被addChild到场景中，应该是不需要retain的，addChild会自动retain，这里不清楚，cocos2dx引擎设计者在load里加retain是为了什么，</p><blockquote><p>这里所导致的问题，几乎是使用过程中内存暴涨</p></blockquote><h3 id="环境与配置-主要原因"><a href="#环境与配置-主要原因" class="headerlink" title="环境与配置(主要原因):"></a>环境与配置(主要原因):</h3><p>通过多次测试发现沙盒文件中的temp中有一堆文件stack-logs.xxxxx.index</p><p><img src="http://pd1l3bbt7.bkt.clouddn.com/cocos2dx/data/cocos2dx_data002.png" alt="曹理鹏(iCocos)-梦工厂"></p><ul><li>同时控制台也打印了一大堆看不懂也搜不到的内容</li></ul><p><img src="http://pd1l3bbt7.bkt.clouddn.com/cocos2dx/data/cocos2dx_data003.png" alt="曹理鹏(iCocos)-梦工厂"></p><p>结合以上几点才初步猜测可能是因为配置环境的问题，查阅资料后发现这与Xcode设置有关,具体配置原因我也不记得了，印象中是当时配置接入cocos2dx的时候，遇到了一些问题，点过了一次，但是现在想想好像当时的操作并没有什么卵用！</p><ul><li>Edit Scheme中Diagnostics有个logging分类，下面有个Malloc Stack选项，将勾选取消。</li></ul><p><img src="http://pd1l3bbt7.bkt.clouddn.com/cocos2dx/data/cocos2dx_data004.png" alt="曹理鹏(iCocos)-梦工厂"></p><p>处理完后立刻验证了一下,重装App,多次执行杀进程和实际测试用，在tmp下并没有产生那个文件stack-logs.xxxxx.index,磁盘占用也处于稳定状态,再打开手机设置查看存储空间，也很正常。</p><p><img src="http://pd1l3bbt7.bkt.clouddn.com/cocos2dx/data/cocos2dx_data005.png" alt="曹理鹏(iCocos)-梦工厂"></p><blockquote><p>以上文稿与数据的15.7中有13M多属于App下载的资源文件。</p></blockquote><p>That’s all for today.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这段时间在开发公司的新产品二次元游戏(&lt;a href=&quot;https://zhongchou.modian.com/item/26767.html?_ga=2.202445201.1279037149.1534326302-1820221530.1531384229&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;零下记忆&lt;/a&gt;)，由于接触coco2dx不久，很多东西还在摸索，也没少加班，所以都没有时间整理和发文了。&lt;/p&gt;
&lt;p&gt;但是最近(从周一开始),发现了一个特别其他的Bug，App磁盘数据报增，幸好我手机是64G的，不然估计会爆炸！&lt;/p&gt;
&lt;p&gt;先来张爆图！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pd1l3bbt7.bkt.clouddn.com/cocos2dx/data/cocos2dx_data001.png&quot; alt=&quot;曹理鹏(iCocos)-梦工厂&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS游戏" scheme="https://icocos.github.io/categories/iOS%E6%B8%B8%E6%88%8F/"/>
    
    
      <category term="iOS游戏" scheme="https://icocos.github.io/tags/iOS%E6%B8%B8%E6%88%8F/"/>
    
      <category term="磁盘管理" scheme="https://icocos.github.io/tags/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>游戏引擎——cocos2dx入门</title>
    <link href="https://icocos.github.io/2018/08/09/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94cocos2dx%E5%85%A5%E9%97%A8/"/>
    <id>https://icocos.github.io/2018/08/09/游戏引擎——cocos2dx入门/</id>
    <published>2018-08-09T12:40:17.000Z</published>
    <updated>2018-08-09T12:51:54.030Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><blockquote><p>Cocos2d-x是一个开源的移动2D游戏框架，MIT许可证下发布的。这是一个C++ Cocos2d-iPhone项目的版本。Cocos2d-X发展的重点是围绕Cocos2d跨平台，Cocos2d-x提供的框架。手机游戏，可以写在C++或者Lua中，使用API是Cocos2d-iPhone完全兼容。Cocos2d-x项目可以很容易地建立和运行在iOS，Android，黑莓Blackberry等操作系统中。Cocos2d-x还支持Windows、Mac和Linux等桌面操作系统，因此，开发者编写的源代码很容易在桌面操作系统中编辑和调试。</p></blockquote><h4 id="cocos2dx-与-UNITY3D"><a href="#cocos2dx-与-UNITY3D" class="headerlink" title="cocos2dx 与 UNITY3D"></a>cocos2dx 与 UNITY3D</h4><a id="more"></a><p>一、区别:</p><ul><li>1、COCOS2D开源,有文档支持,论坛资料庞杂博大；UNITY3D闭源,有强大的文档支持,论坛资料一样的庞杂博大。</li><li>2、COCOS2D免费；UNITY3D收费。</li><li>3、COCOS2D的跨平台,需要大量重写代码；UNITY3D的跨平台,程序员只需要选选按钮就淡定许多的搞定了。</li></ul><p>二、拓展:</p><ul><li>1、不同:<ul><li>COCOS2D拥有令人发指的可定制性；UNITY3D有一个专门为订制而写的类库。</li></ul></li><li>2、相同:<ul><li>UNITY3D和 COCOS2D-X都是跨平台的游戏开发引擎。</li></ul></li></ul><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul><li>现代化的 C++ API</li><li>立足于 C++ 同时支持 JavaScript/Lua 作为开发语言</li><li>可以跨平台部署, 支持 iOS、Android、Windows、macOS 和 Linux</li><li>可以在 PC 端完成游戏的测试，最终发布到移动端</li><li>完善的游戏功能支持，包含精灵、动作、动画、粒子特效、场景转换、事件、文件 IO、数据持久化、骨骼动画、3D</li></ul><h4 id="家族成员"><a href="#家族成员" class="headerlink" title="家族成员"></a>家族成员</h4><blockquote><p>cocos2d是一个基于MIT协议的开源框架，用于构建游戏、应用程序和其他图形界面交互应用。可以让你在创建自己的多平台游戏时节省很多的时间。</p></blockquote><h6 id="Cocos2d-html5-："><a href="#Cocos2d-html5-：" class="headerlink" title="Cocos2d-html5 ："></a>Cocos2d-html5 ：</h6><ul><li>Cocos2d-HTML5 是基于 HTML5 规范集的 Cocos2d引擎分支，具有跨平台的能力和强大的性能，是 Cocos2d 系列引擎随着互联网技术演进而产生的一个分支，该分支基于 HTML5 规范集，目标是可对游戏进行跨平台部署，Cocos2d-HTML5 采用 MIT 开源协议，设计上保持Cocos2d家族的传统架构，并可联合 Cocos2d-x JavaScript-binding 接口，最大程度地实现游戏代码在不同平台上的复用。</li></ul><h6 id="JSB-："><a href="#JSB-：" class="headerlink" title="JSB ："></a>JSB ：</h6><ul><li>Cocos2d-x JavaScript-binding 是使用 SpiderMonkey 引擎实现 C++ 接口到 JavaSciprt 的绑定方案，它可以使用 Js 快速开发游戏，以更简单的语法实现功能，并且能与 Cocos2D-HTML5 相互兼容，使同一套代码，运行两个平台，这是相比使用 Lua 实现的一个明显优势。</li></ul><h6 id="Cocos-Studio-："><a href="#Cocos-Studio-：" class="headerlink" title="Cocos Studio ："></a>Cocos Studio ：</h6><ul><li>Cocos Studio 是一套基于 Cocos2d-x 引擎的工具集，包括 UI编辑器，动画编辑器，场景编辑器和数据编辑器。 UI 编辑器和动画编辑器主要面向美术，而场景编辑器和数据编辑器则面向游戏策划，这四个工具合在一起构成了一套完整的游戏开发体系，帮助开发者进一步降低开发难度，提高开发效率，减少开发成本。</li></ul><p>Cocos2d也拥有几个主要版本，包括Cocos2d-iPhone、Cocos2d-X，以及被社区普遍看好的Cocos2d-HTML5和JavaScript bindings for Cocos2d-X。</p><h4 id="关于lua，c-，JS"><a href="#关于lua，c-，JS" class="headerlink" title="关于lua，c++，JS"></a>关于lua，c++，JS</h4><p>允许开发人员使用 C++、Javascript 及 Lua 三种语言来进行游戏开发。</p><blockquote><p>支持所有常见平台，包括 iOS、Android、Windows、macOS、Linux。</p></blockquote><ol><li><p>运行效率：</p><blockquote><p>Lua 的性能在各种测试里都比 JavaScript 快不少。而移动设备上存在不支持 JIT 的情况（未越狱的 iOS 设备），Lua 对比 JavaScript 的性能优势就更明显。</p></blockquote></li><li><p>安全性：</p><blockquote><p>现在 cocos2d-x 使用 LuaJIT 来执行 Lua，所以可以把 Lua 代码编译为字节码再打包到游戏里。由于 LuaJIT 的字节码是高度优化过的，所以目前还没有反编译工具。而 JS 虽然也可以用字节码，但从目前的情况看还达不到 LuaJIT 的安全性。</p></blockquote></li><li><p>与 C/C++ 的交互：</p><blockquote><p>Lua 原本就是作为嵌入式语言来设计的，所以天然和 C/C++ 很容易交互。JS 这方面是个劣势。</p></blockquote></li><li><p>与 Java/Objective-C 的交互：</p><blockquote><p>不管是 quick-cocos2d-x 里提供的 luaoc/luaj 模块，还是 wax, luajava 这些开源项目，都让我们可以绕过 C/C++ 层实现 Lua 和 Java/Objc 的交互。这个优势在游戏发行阶段，集成各种第三方 SDK 时绝对会节约巨量时间！！！</p></blockquote></li></ol><p>游戏是非常消耗资源的每时每刻都要大量的计算，</p><ul><li>假如有个方法 让 C语言来实现 并且把它完成的时间定义为 1个单位 的时间</li><li>那么同样的数据结构的方法在其他语言中     <ul><li>java 需要 8个单位       </li><li>lua需要30个单位       </li><li>python需要200个单位       </li><li>php需要462个单位       </li><li>javascript需要621个单位</li></ul></li></ul><p>所以在需要大量计算的环节，代码的结构时间复杂度比较高的 情况下用 C++（肯没直接用C快，但一定比java快）来写，   现在的CPU计算能力都还是蛮高的，所以没必要完全用C++ ，用一些其他的语言开发速度可以大大加快。 </p><h6 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h6><ul><li>项目不需要热更新的时候用c++</li><li>lua，c++都可以用的时候c++更熟悉的用c++</li><li>c++效率比lua高</li><li>lua项目的底层框架还是要c++搭比较好</li><li>c++老司机转其他语言比较轻松。</li></ul><p>最终使用那种方式还是需要结合个人，语言，需求，性能综合考虑</p><ul><li>当然，cocos2d-x 目前明显是在主推 JS 的解决方案，因为 JS 可以跨越移动设备、桌面的界限，实现一套程序跑任意平台。不过我个人认为以当前 HTML5 的发展情况，对于要强调体验的游戏来说，HTML5 还要一些时间。</li></ul><blockquote><p>网友评价：<br>前面提到 JS 更容易面向对象，我想可能是因为大家对 Lua 还不够了解造成的错觉。实际上，Lua 和 JS 实现面向对象的机制几乎是一样的。JS 基于 prototype，Lua 基于 metatable，在我看来仅仅是名字不同而已。</p></blockquote><p>从目前的市场情况来说，Lua 明显是更理性的选择：成熟、安全性高、众多大作采用。</p><h4 id="跨平台原理"><a href="#跨平台原理" class="headerlink" title="跨平台原理"></a>跨平台原理</h4><blockquote><ol><li>AppDelegate 作为跨平台程序入口，在这之上做了另一层的封装，封装了不同平台的不同实现。比如我们通常认为一个程序是由 main 函数开始运行，那我们就去找寻，我们看到了在 proj.linux 目录下存在 main.cpp 文件。</li></ol></blockquote><blockquote><ol start="2"><li>在main.cpp 中 CCApplication::sharedApplication()–&gt;run(); 这一句看起，这一句标志着， cocos2d-x 程序正式开始运行，现在定位到 sharedApplication() 方法的实现，在CCAplication类中我们可以看到从 sharedApplication() 方法，在调用 run() 方法，在这之前，我们需要调用到它的构造函数，否则不能运行，这就是为什么在 CCApplication::sharedApplication()–&gt;run(); 之前，我们首先有语句 AppDelegate app; 而创建 AppDelegate 变量的原因是 AppDelegate 是 CCApplication 的子类，在创建子类对象的时候，调用其构造函数的同时，父类构造函数也会执行，然后就将 AppDelegate 的对象赋给了 CCApplication 的静态变量，而在 AppDelegate 之中我们实现了 applicationDidFinishLaunching方法，所以在 CCApplication 中 run 方法的开始处调用的就是 AppDelegate 之中的实现。</li></ol></blockquote><blockquote><ol start="3"><li>我们在此方法中我们初始化了一些变量，创建了第一个 CCScene 场景等，之后的控制权，便全权交给了CCDirector::sharedDirector()–&gt;mainLoop(); 方法了。</li></ol></blockquote><ul><li><p>在cocos2d-x的文件夹下，有一个platform文件夹，里面存放了跨平台的封装接口。</p></li><li><p>当前目录下有CCApplicationProtocol.h头文件，子目录有win32,Android,IOS三个文件夹，里面分别存放跨平台需要的函数，其中包括CCApplication。</p></li><li><p>而AppDelegate 类则是继承自CCApplication。CCApplication又继承自CCApplicationProtocol。</p></li><li><p>在CCApplicationProtocol中定义了applicationDidFinishLaunching虚方法,由CCApplication 继承， AppDelegate 实现的。以此实现了跨平台。</p></li></ul><blockquote><p>为了充分发挥硬件性能，手机游戏通常使用Native App开发模式，这就造成开发商要为iOS 和Android平台用户开发不同的应用，无论是产品迭代还是运行维护都非常麻烦。</p></blockquote><p>Cocos2d-x在iOS，Android等移动平台之上，封装了一层C++接口，从而屏蔽了平台的差异性，通过平台宏来控制使用哪个平台的代码，向开发者提供C++接口调用。这些接口主要包括UI、事件和网络，封装UI主要是使用OpenGL ES的接口来写UI，封装事件和网络，均是使用C++接口对原生接口进行一层封装。</p><ul><li>推荐<ul><li>官方文档：<a href="http://www.cocos2d-x.org/docs/cocos2d-x/zh/about/learn.html" target="_blank" rel="noopener">http://www.cocos2d-x.org/docs/cocos2d-x/zh/about/learn.html</a></li><li>OC/Swift - C++交互与混编:<a href="http://edu.51cto.com/center/course/lesson/index?id=57316" target="_blank" rel="noopener">http://edu.51cto.com/center/course/lesson/index?id=57316</a></li><li>入门实战-飞机大战游戏：<a href="http://www.maiziedu.com/course/662-9914/" target="_blank" rel="noopener">http://www.maiziedu.com/course/662-9914/</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Cocos2d-x是一个开源的移动2D游戏框架，MIT许可证下发布的。这是一个C++ Cocos2d-iPhone项目的版本。Cocos2d-X发展的重点是围绕Cocos2d跨平台，Cocos2d-x提供的框架。手机游戏，可以写在C++或者Lua中，使用API是Cocos2d-iPhone完全兼容。Cocos2d-x项目可以很容易地建立和运行在iOS，Android，黑莓Blackberry等操作系统中。Cocos2d-x还支持Windows、Mac和Linux等桌面操作系统，因此，开发者编写的源代码很容易在桌面操作系统中编辑和调试。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;cocos2dx-与-UNITY3D&quot;&gt;&lt;a href=&quot;#cocos2dx-与-UNITY3D&quot; class=&quot;headerlink&quot; title=&quot;cocos2dx 与 UNITY3D&quot;&gt;&lt;/a&gt;cocos2dx 与 UNITY3D&lt;/h4&gt;
    
    </summary>
    
      <category term="cocos2dx" scheme="https://icocos.github.io/categories/cocos2dx/"/>
    
    
      <category term="cocos2dx" scheme="https://icocos.github.io/tags/cocos2dx/"/>
    
      <category term="游戏" scheme="https://icocos.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>初识游戏——cocos2dx初探</title>
    <link href="https://icocos.github.io/2018/06/15/%E5%88%9D%E8%AF%86%E6%B8%B8%E6%88%8F%E2%80%94%E2%80%94cocos2dx%E5%88%9D%E6%8E%A2/"/>
    <id>https://icocos.github.io/2018/06/15/初识游戏——cocos2dx初探/</id>
    <published>2018-06-15T15:49:12.000Z</published>
    <updated>2018-08-06T18:33:42.291Z</updated>
    
    <content type="html"><![CDATA[<p>前端时间一直在忙项目，也提到了关于是一个AVG游戏项目，近期由于最新需求，需要开发iOS 游戏，之前做了这么久一直没有感觉到真正游戏或者游戏开发的存在，这一次，好像真的要步入游戏开发了。</p><p>所以整理了一下。</p><a id="more"></a><blockquote><p>具体概念和基本使用就不做介绍了，因为那些都太枯燥了，这里先说说整个环境搭建（以Mac为例），然后根据实际开发整理一些有意义的东西</p></blockquote><h5 id="先来看看官方"><a href="#先来看看官方" class="headerlink" title="先来看看官方"></a>先来看看官方</h5><p><a href="http://docs.cocos.com/cocos2d-x/manual/zh/" target="_blank" rel="noopener">http://docs.cocos.com/cocos2d-x/manual/zh/</a></p><h2 id="搭建开发环境-iOS"><a href="#搭建开发环境-iOS" class="headerlink" title="搭建开发环境 - iOS"></a>搭建开发环境 - iOS</h2><h4 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h4><pre><code>Cocos2d-x v3.17，下载后解压，下载参见：Cocos官网页面:http://www.cocos.com/downloadXcode 9 下载后安装，下载参见：Apple官网页面;https://developer.apple.com/download/more/或者前往App Store下载</code></pre><h4 id="配置步骤："><a href="#配置步骤：" class="headerlink" title="配置步骤："></a>配置步骤：</h4><ul><li><p>打开 cocos2d-x-3.17/build/cocos2d_tests.xcodeproj</p></li><li><p>在 Xcode 顶部工具栏选择 cpp-tests iOS，iPhone 7 Plus，点击运行，项目将自动编译运行，效果如图：</p></li></ul><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/000001.png" alt="曹理鹏(iCocos)-梦工厂"></p><h4 id="如何调试-Debug"><a href="#如何调试-Debug" class="headerlink" title="如何调试(Debug)"></a>如何调试(Debug)</h4><ul><li>点击代码行左侧的空白，设置断点</li><li>运行 cpp-tests</li></ul><p>操作 App 触发断点，IDE 将卡在断点处，视图会自动变化，左侧导航栏可以查看运行堆栈，底部窗口可以查看变量的值：</p><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/000002.png" alt="曹理鹏(iCocos)-梦工厂"></p><p>这里严格来说，其实不算是环境搭建，而是下载引擎，运行官方demo而已，那么下面我们开始简单的搭建一个实际项目，并后续从零开始做一个真正的游戏</p><h2 id="实际开发配置"><a href="#实际开发配置" class="headerlink" title="实际开发配置"></a>实际开发配置</h2><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><pre><code>登录Cocos2d-x 的官网 http://www.cocos2d-x.org点击download 下载最新的版本</code></pre><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/000003.png" alt="曹理鹏(iCocos)-梦工厂"></p><p>点击超链接，将会下载得到一个Cocos2d-x-3.17.zip 压缩包</p><pre><code>将下载的压缩包进行解压，打开得到的文件夹，其结构目录如下</code></pre><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/000004.png" alt="曹理鹏(iCocos)-梦工厂"></p><ul><li>build :多平台下的架构文件存放的目录</li><li>cocos 框架核心目录 里面存放了Cocos2d-x的核心代码。</li><li>docs：文档目录 可以使用该目录下的doxygen.config 文件创建离线文档</li><li>extensions:扩展目录 存放了一些官方的扩展 包括更多图形用户界面的控制功能 网络访问 CocosBuilder 等</li><li>external：存放扩展需要用到的物理引擎 包括box2d和chipmunk</li><li>licenses: cocos2d依赖很多开源项目，所有的授权许可文件都在这个目录</li><li>plugin:plugin-x 项目目录，plugin -x  是一个可以快速接入第三方idk的框架</li><li>templates：该目录包括在不同集成环境及不同平台中创建Cocos2d-x 新项目的模板</li><li>test：测试项目 这是我们最开始用到的文件 在 cpp-tests 项目中包含所有类的用法 lua 和js 样本也在这个目录</li><li>tools： 需要用到的工具 Cocos2d-console 目录中包含了创建Cocos2d-x项目的脚本 可以针对不同的平台进行开发环境的搭建 同时 还包括将c++绑定至lua 及JavaScript 的脚本文件</li></ul><h4 id="Cocos2d-x的安装和配置"><a href="#Cocos2d-x的安装和配置" class="headerlink" title="Cocos2d-x的安装和配置"></a>Cocos2d-x的安装和配置</h4><p>Cocos2d-x 从2.1.4 版 之后已经不再支持使用模板来生成项目 而是使用官方提供的python 直接创建项目 也就是说Cocos2d-x 不能安装到Xcode上面，不能使用Xcode的Cocos2d-x模板一步一步的生成项目，只能使用Xcode来打开已经创建好的项目</p><h4 id="创建项目的步骤如下："><a href="#创建项目的步骤如下：" class="headerlink" title="创建项目的步骤如下："></a>创建项目的步骤如下：</h4><ul><li>打开终端 进入Cocos2d-x3.14 目录执行./setup.py  运行该文件用来 配置系统的一些环境变量</li></ul><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/000005.png" alt="曹理鹏(iCocos)-梦工厂"></p><ul><li>打开终端 执行Cocos new HelloCpp -p org.cocos2dx -l cpp -d codes</li></ul><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/000006.png" alt="曹理鹏(iCocos)-梦工厂"></p><p>如果一切正常 则项目创建成功 关闭终端 再次进入Cocos2d-3.14目录这时候 会发现新建的codes目录</p><p>进入该目录发现新建的HelloCpp项目 进入proj.ios_mac 双击HelloCPP.xcodeproj 文件 使用快捷键（command+run）运行程序 就可以在iOS模拟器上看到经典的hello world 画面</p><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/000007.png" alt="曹理鹏(iCocos)-梦工厂"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端时间一直在忙项目，也提到了关于是一个AVG游戏项目，近期由于最新需求，需要开发iOS 游戏，之前做了这么久一直没有感觉到真正游戏或者游戏开发的存在，这一次，好像真的要步入游戏开发了。&lt;/p&gt;
&lt;p&gt;所以整理了一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="https://icocos.github.io/categories/Go/"/>
    
    
      <category term="Go基础" scheme="https://icocos.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
      <category term="cocos2dx初探" scheme="https://icocos.github.io/tags/cocos2dx%E5%88%9D%E6%8E%A2/"/>
    
  </entry>
  
  <entry>
    <title>Golang——groutine和channel底层机制</title>
    <link href="https://icocos.github.io/2018/06/12/Golang%E2%80%94%E2%80%94groutine%E5%92%8Cchannel%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6/"/>
    <id>https://icocos.github.io/2018/06/12/Golang——groutine和channel底层机制/</id>
    <published>2018-06-12T15:49:12.000Z</published>
    <updated>2018-08-06T17:26:22.420Z</updated>
    
    <content type="html"><![CDATA[<p>goroutine, channel其实可以认为是golang中runtime的一部分，当然golang的runtime还包含Garbage collection，内存分配，垃圾回收，interfaces, maps,slices等一些高级功能</p><a id="more"></a><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><blockquote><p>我们知道Golang系统默认支持原始并发(加入协程与管道)，不想其他语言一样，需要写一堆的代码，还没有几个能写好的。</p></blockquote><p>Golang使用Groutine和channels实现了CSP(Communicating Sequential Processes)模型，channles负责goroutine通信。</p><h3 id="goroutinue"><a href="#goroutinue" class="headerlink" title="goroutinue"></a>goroutinue</h3><p>goroutine是Golang实现的用户空间的轻量级的线程，有runtime调度器调度，与操作系统的thread有多对一的关系</p><ul><li>goroutinue，本质上就是协程。但有两点不同：<ul><li>1.goroutinue可以实现并行，多个协程可以在多个处理器同时跑。而协程同一时刻只能在一个处理器上跑（把宿主语言想象成单线程的就好了）。</li><li>2.goroutine之间的通信是通过channel，而协程的通信是通过yield和resume()操作。</li></ul></li></ul><h4 id="goroutine-scheduler"><a href="#goroutine-scheduler" class="headerlink" title="goroutine scheduler"></a>goroutine scheduler</h4><p>goroutine scheduler 是Go runtime的一个重要的组成部分。他负责追踪，调度每个goroutine运行，实际上是从应用程序的process所属的thread pool中分配一个thread来执行这个goroutine。因此，和java虚拟机中的Java thread和OS thread映射概念类似，每个goroutine只有分配到一个OS thread才能运行。</p><h3 id="Chanel"><a href="#Chanel" class="headerlink" title="Chanel"></a>Chanel</h3><p>Channel是Go中的一个核心类型，你可以把它看成一个管道，通过它并发核心单元就可以发送或者接收数据进行通讯(communication)</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><ul><li>ch := make(chan Task, 3) // hchan（src/runtime/chan.go）</li></ul><p>创建channel时在该进程的heap申请一块内存，创建一个hchan结构体，返回执行该内存的指针(ch变量本身是一个指针，在函数间传递的时候是同一个channel)</p><p>channel使用一个唤醒队列保存groutine之间传递的数据，使用两个list保存goroutine(向该chan发生数据，从该chan接受数据),还有一个mutex保证操作安全</p><h4 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h4><p>M是操作系统的线程，G是用户启动的goroutine，P是与调度相关的context，每个M都拥有一个P，P维护了一个能够运行的goutine队列，用于该线程执行。</p><h4 id="发生接受数据"><a href="#发生接受数据" class="headerlink" title="发生接受数据"></a>发生接受数据</h4><p>向channel发送和从channel接收数据主要涉及hchan里的四个成员变量</p><pre><code>buf(指向dataqsiz元素的数组)，sendx，recvx，lock(锁定保护HCHA中的所有字段)</code></pre><ul><li>初始化的时候hchan中buf为空，sendx，recvx为0：</li><li>向chan发生数据的时候，会对buf加锁，然后将要发生的数据copy到buf中，并sendx+1，最后释放buf的锁。</li><li>从chan接受数据的时候，会对buf加锁，然后将buf里面的数据copy到变量对应的内存，并recvx+1，最后释放buf的锁。</li></ul><p>底层通过hchan中的buf，使用copy内存的方式通讯，达到共享内存目的</p><h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><ul><li>当想已满的chan发生数据，runtime检测到对应的hchan已经满了，会通知调度器，调度器将发送至置为waiting，移除与线程M的关系，<br>然后从P的runqueue中选择一个goroutine在线程M中执行，此时发送者处于阻塞状态，但是操作系统线程非阻塞，所以只消耗少量资源。</li><li>发送者阻塞后会创建一个自己的结构体sudog，然后放到sendq(发送阻塞列表：保存channel相关变量的指针，如发送或者接收数据的变量的地址&amp;copy)</li><li>从chan接收数据时，会通知调度器，将发送者状态设置为runnable，并且将其加入P的runqueue，等待线程执行</li></ul><blockquote><p>注意：如果接受者先运行，那么他会从一个空的chanl中取数据，这个时候会直接阻塞，通发送者阻塞一样，也会创建一个自己的结构体sudog，保存接收数据的变量的地址，<br>但是该sudog不是放在recvq(接收阻塞列表)，当再想chan发送数据的时候，runtime辟谷没有对hchan中buf加锁，而是直接将发送的数据copy到接收者的结构体sudog对应的elem指向的内存地址</p></blockquote><h3 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h3><p>goroutine, channel其实可以认为是golang中runtime的一部分，当然golang的runtime还包含Garbage collection，内存分配，垃圾回收，interfaces, maps,slices等一些高级功能</p><blockquote><p>1.4之前，runtime还是由C语言所编写的，官方计划，1.5版本将去除C的代码，runtime将完全由Go语言来完成，不论何种方式，runtime和用户编译后的代码被linker静态链接起来，形成一个可执行文件。这个文件从操作系统角度来说是一个user space的独立的可执行文件。</p></blockquote><p>从运行的角度来说，这个文件由2部分组成，一部分是用户的代码，另一部分就是runtime。runtime通过接口函数调用来管理goroutine, channel及其他一些高级的功能。从用户代码发起的调用操作系统API的调用都会被runtime拦截并处理。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><blockquote><p>goroutine的调度器是在线程之上的多路复用。channel的实现是仅仅的关联在调度器之上，compiler也是紧密的和goroutine调度器关联在一起，不仅仅创建goroutine，而且也管理着stack，防止stack溢出。goroutine是一个执行的stack+一个控制的struct。调度器分配goroutine在线程上执行，当一个线程阻塞了或者调用一个非Go的函数(CGO调用)，那么调度器就会开始一个新的线程来运行其他的goroutine.</p></blockquote><ul><li>推荐文章<ul><li><a href="https://blog.csdn.net/whatday/article/details/74453089" target="_blank" rel="noopener">https://blog.csdn.net/whatday/article/details/74453089</a></li><li><a href="https://blog.csdn.net/kongdefei5000/article/details/75209005" target="_blank" rel="noopener">https://blog.csdn.net/kongdefei5000/article/details/75209005</a></li><li><a href="https://www.zhihu.com/question/20862617" target="_blank" rel="noopener">https://www.zhihu.com/question/20862617</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;goroutine, channel其实可以认为是golang中runtime的一部分，当然golang的runtime还包含Garbage collection，内存分配，垃圾回收，interfaces, maps,slices等一些高级功能&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="https://icocos.github.io/categories/Go/"/>
    
    
      <category term="Go基础" scheme="https://icocos.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
      <category term="groutine和channel底层机制" scheme="https://icocos.github.io/tags/groutine%E5%92%8Cchannel%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Golang——Http服务初探</title>
    <link href="https://icocos.github.io/2018/06/07/Golang%E2%80%94%E2%80%94Http%E6%9C%8D%E5%8A%A1%E5%88%9D%E6%8E%A2/"/>
    <id>https://icocos.github.io/2018/06/07/Golang——Http服务初探/</id>
    <published>2018-06-07T15:49:12.000Z</published>
    <updated>2018-08-06T18:33:42.537Z</updated>
    
    <content type="html"><![CDATA[<p>这里开始之前，先来说说golang中http服务的内部机制(所有其他库都是在此基础延伸)</p><a id="more"></a><p>这里开始之前，先来说说golang中http服务中三个重要的方法(所有其他库都是在此基础延伸)</p><ul><li>func Handle<ul><li>func Handle(pattern string, handler Handler)<blockquote><p>Handle registers the handler for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched.</p></blockquote></li></ul></li><li>func HandleFunc<ul><li>func HandleFunc(pattern string, handler func(ResponseWriter, *Request))<blockquote><p>HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched.</p></blockquote></li></ul></li><li>func ListenAndServe<ul><li>func ListenAndServe(addr string, handler Handler) error<blockquote><p>ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Handler is typically nil, in which case the DefaultServeMux is used.</p></blockquote></li></ul></li></ul><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>ListenAndServe是用于在指定的TCP 网络地址addr 进行监听，然后调用服务端处理程序来处理传入的连<br>接请求。该方法有两个参数：第一个参数addr 即监听地址；第二个参数表示服务端处理程序，<br>通常为空，这意味着服务端调用 http.DefaultServeMux 进行处理，而服务端编写的业务逻<br>辑处理程序 http.Handle() 或 http.HandleFunc() 默认注入 http.DefaultServeMux 中</p></blockquote><p>下面以三种不同的方式实现最Golang中基本的Http Server</p><h2 id="默认方式"><a href="#默认方式" class="headerlink" title="默认方式"></a>默认方式</h2><p> 默认handler，处理路由注册</p><pre><code>//===================================Http 1===================================//func Http_Server1() {    http.HandleFunc(&quot;/&quot;, sayServer1)    err := http.ListenAndServe(&quot;:8080&quot;, nil)    if err != nil {        panic(err)    }}func sayServer1(w http.ResponseWriter, r *http.Request) {    io.WriteString(w,&quot;sayServer1 Http Service&quot;)}</code></pre><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/1.png" alt="曹理鹏(iCocos)-梦工厂"></p><h2 id="自定义方式"><a href="#自定义方式" class="headerlink" title="自定义方式"></a>自定义方式</h2><p>自己实现hander，注册到max中，在注册路由</p><pre><code>//===================================Http 2===================================//func Http_Server2() {    mux := http.NewServeMux()    mux.Handle(&quot;/&quot;, &amp;myHanlder{})    mux.HandleFunc(&quot;/hello&quot;, sayServer2)    err := http.ListenAndServe(&quot;:8080&quot;, mux)    if err != nil {        panic(err)    }}type myHanlder struct{}func (*myHanlder) ServeHTTP(w http.ResponseWriter, r *http.Request) {    io.WriteString(w,&quot;Http Service: &quot;+ r.URL.String())}func sayServer2(w http.ResponseWriter, r *http.Request) {    io.WriteString(w,&quot;sayServer2 Http Service&quot;)}</code></pre><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/20.png" alt="曹理鹏(iCocos)-梦工厂"></p><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/21.png" alt="曹理鹏(iCocos)-梦工厂"></p><h2 id="底层拓展方式"><a href="#底层拓展方式" class="headerlink" title="底层拓展方式"></a>底层拓展方式</h2><p>底层实现路由注册，多用户封装</p><pre><code>//===================================Http 3===================================//var mux map[string]func(http.ResponseWriter, *http.Request) // 路由指定func Http_Server3() {    server := http.Server{        Addr:&quot;:8080&quot;,        Handler:&amp;mHandler{},        ReadTimeout:5*time.Second,    }     注册    mux = make(map[string]func(http.ResponseWriter, *http.Request))    mux[&quot;/hello&quot;] = sayServer3    mux[&quot;/golang&quot;] = golang    err := server.ListenAndServe()    if err != nil {        panic(err)    }}type mHandler struct {}func (*mHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {    if h,ok := mux[r.URL.String()]; ok {        h(w,r)        return    }    io.WriteString(w,&quot;Http Service Custome: &quot;+ r.URL.String())}func sayServer3(w http.ResponseWriter, r *http.Request) {    io.WriteString(w,&quot;sayServer3 Http Service&quot;)}func golang(w http.ResponseWriter, r *http.Request) {    io.WriteString(w,&quot;golang Http Service&quot;)}</code></pre><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/30.png" alt="曹理鹏(iCocos)-梦工厂"></p><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/31.png" alt="曹理鹏(iCocos)-梦工厂"></p><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/32.png" alt="曹理鹏(iCocos)-梦工厂"></p><h2 id="Beego你好世界"><a href="#Beego你好世界" class="headerlink" title="Beego你好世界"></a>Beego你好世界</h2><p>其实上面只是作为个简单的入门了解，一般实际开发中，那么做的还是不多，我们大部分都会选择使用第三方，比如PHP中的ThinkPHP，Yii，在Golang中也有几个不错的第三个可以使用，而且目前已经很成熟了，至少可以满足目前几乎大部分公司的业务需求<br>比如beego(国人开发)，gin，dotweb，echo这些都是笔者通过技术群或者网络热门程度了解到在Golang中还不错的的库，而且使用中和非常多。</p><p>这里我简单以beego作为案例尝试下，没有什么技术含量，勿喷</p><h4 id="下载安装-前提：配置GOPATH"><a href="#下载安装-前提：配置GOPATH" class="headerlink" title="下载安装(前提：配置GOPATH)"></a>下载安装(前提：配置GOPATH)</h4><pre><code>go get github.com/astaxie/beego</code></pre><h4 id="创建文件-hello-go"><a href="#创建文件-hello-go" class="headerlink" title="创建文件 hello.go"></a>创建文件 hello.go</h4><pre><code>//================================Hello World!!===============================//package mainimport &quot;github.com/astaxie/beego&quot;type HomeController struct {    beego.Controller}func (this *HomeController) Get() {    this.Ctx.WriteString(&quot;Hello World!!&quot;)}func Http_Hello() {    beego.Router(&quot;/&quot;, &amp;HomeController{})    beego.Run()}</code></pre><h4 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h4><pre><code>go build -o hello hello.go./hello</code></pre><h4 id="浏览效果"><a href="#浏览效果" class="headerlink" title="浏览效果"></a>浏览效果</h4><p>打开浏览器并访问 <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a></p><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/beego.png" alt="曹理鹏(iCocos)-梦工厂"></p><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/0.png" alt="曹理鹏(iCocos)-梦工厂"></p><h2 id="关闭http服务"><a href="#关闭http服务" class="headerlink" title="关闭http服务"></a>关闭http服务</h2><p>在go1.8中新增了一个新特性，利用Shutdown(ctx context.Context) 优雅地关闭http服务。</p><p>Shutdown 将无中断的关闭正在活跃的连接，然后平滑的停止服务。处理流程如下：</p><pre><code>首先关闭所有的监听;然后关闭所有的空闲连接;然后无限期等待连接处理完毕转为空闲，并关闭;如果提供了 带有超时的Context，将在服务关闭前返回 Context的超时错误;</code></pre><p>利用这个特性改造一下v3版本的程序，实现一个关闭http的提示</p><pre><code>// 主动关闭服务器var server *http.Serverfunc main() {    // 一个通知退出的chan    quit := make(chan os.Signal)    signal.Notify(quit, os.Interrupt)    mux := http.NewServeMux()    mux.Handle(&quot;/&quot;, &amp;myHandler{})    mux.HandleFunc(&quot;/bye&quot;, sayBye)    server = &amp;http.Server{        Addr:         &quot;:1210&quot;,        WriteTimeout: time.Second * 4,        Handler:      mux,    }    go func() {        // 接收退出信号        &lt;-quit        if err := server.Close(); err != nil {            log.Fatal(&quot;Close server:&quot;, err)        }    }()    log.Println(&quot;Starting v3 httpserver&quot;)    err := server.ListenAndServe()    if err != nil {        // 正常退出        if err == http.ErrServerClosed {            log.Fatal(&quot;Server closed under request&quot;)        } else {            log.Fatal(&quot;Server closed unexpected&quot;, err)        }    }    log.Fatal(&quot;Server exited&quot;)}type myHandler struct{}func (*myHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {    w.Write([]byte(&quot;this is version 3&quot;))}// 关闭httpfunc sayBye(w http.ResponseWriter, r *http.Request) {    w.Write([]byte(&quot;bye bye ,shutdown the server&quot;))     // 没有输出    err := server.Shutdown(nil)    if err != nil {        log.([]byte(&quot;shutdown the server err&quot;))    }}</code></pre><p>尝试访问<a href="http://localhost:1210/bye" target="_blank" rel="noopener">http://localhost:1210/bye</a> 在控制台会得到以下提示结果，平滑关闭http服务成功:</p><p><a href="https://www.jianshu.com/p/be3d9cdc680b" target="_blank" rel="noopener">https://www.jianshu.com/p/be3d9cdc680b</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里开始之前，先来说说golang中http服务的内部机制(所有其他库都是在此基础延伸)&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="https://icocos.github.io/categories/Go/"/>
    
    
      <category term="Go基础" scheme="https://icocos.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Http服务初探" scheme="https://icocos.github.io/tags/Http%E6%9C%8D%E5%8A%A1%E5%88%9D%E6%8E%A2/"/>
    
  </entry>
  
  <entry>
    <title>Golang——文件IO处理</title>
    <link href="https://icocos.github.io/2018/06/03/Golang%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6IO%E5%A4%84%E7%90%86/"/>
    <id>https://icocos.github.io/2018/06/03/Golang——文件IO处理/</id>
    <published>2018-06-03T15:49:12.000Z</published>
    <updated>2018-08-06T18:33:42.532Z</updated>
    
    <content type="html"><![CDATA[<p>读写文件应该是在开发过程中经常遇到的，今天要跟大家一起分享的就是在golang的世界中，如何读写文件</p><a id="more"></a><p>读写文件应该是在开发过程中经常遇到的，今天简单看看golang的世界中，如何读写文件。</p><h3 id="读取文件方法速度比较"><a href="#读取文件方法速度比较" class="headerlink" title="读取文件方法速度比较"></a>读取文件方法速度比较</h3><pre><code>package mainimport (    &quot;bufio&quot;    &quot;fmt&quot;    &quot;io&quot;    &quot;io/ioutil&quot;    &quot;os&quot;    &quot;time&quot;)func read0(path string) string {    f, err := ioutil.ReadFile(path)    if err != nil {        fmt.Printf(&quot;%s\n&quot;, err)        panic(err)    }    return string(f)}func read1(path string) string {    fi, err := os.Open(path)    if err != nil {        panic(err)    }    defer fi.Close()    chunks := make([]byte, 1024, 1024)    buf := make([]byte, 1024)    for {        n, err := fi.Read(buf)        if err != nil &amp;&amp; err != io.EOF {        panic(err)    }    if 0 == n {        break    }        chunks = append(chunks, buf[:n]...)    }    return string(chunks)}func read2(path string) string {    fi, err := os.Open(path)    if err != nil {        panic(err)    }    defer fi.Close()    r := bufio.NewReader(fi)    chunks := make([]byte, 1024, 1024)    buf := make([]byte, 1024)    for {        n, err := r.Read(buf)        if err != nil &amp;&amp; err != io.EOF {            panic(err)        }        if 0 == n {            break        }        chunks = append(chunks, buf[:n]...)    }    return string(chunks)}func read3(path string) string {    fi, err := os.Open(path)    if err != nil {        panic(err)    }    defer fi.Close()    fd, err := ioutil.ReadAll(fi)    return string(fd)}func main() {    file := &quot;test.log&quot;    start := time.Now()    read0(file)    t0 := time.Now()    fmt.Printf(&quot;Cost time %v\n&quot;, t0.Sub(start))    read1(file)    t1 := time.Now()    fmt.Printf(&quot;Cost time %v\n&quot;, t1.Sub(t0))    read2(file)    t2 := time.Now()    fmt.Printf(&quot;Cost time %v\n&quot;, t2.Sub(t1))    read3(file)    t3 := time.Now()    fmt.Printf(&quot;Cost time %v\n&quot;, t3.Sub(t2))}</code></pre><p>运行结果对比：</p><pre><code>Cost time 4.0105msCost time 11.5043msCost time 7.0042msCost time 2.4983msCost time 4.4925msCost time 11.0053msCost time 5.0082msCost time 2.9992msCost time 3.9866msCost time 15.0085msCost time 7.5054msCost time 2.5035msCost time 4.9989msCost time 14.0112msCost time 7.5045msCost time 3.508msCost time 3.0043msCost time 15.0265msCost time 8.9884msCost time 2.0036ms</code></pre><h3 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h3><pre><code>//=================================== Files ===================================//func File_Server() {    mux := http.NewServeMux()    mux.Handle(&quot;/&quot;, &amp;fileHanlder{})    mux.HandleFunc(&quot;/hello&quot;, sayServer2)    wd, err := os.Getwd()    if err != nil {        panic(err)    }    mux.Handle(&quot;/static/&quot;, http.StripPrefix(&quot;/static/&quot;, http.FileServer(http.Dir(wd))))    err = http.ListenAndServe(&quot;:8080&quot;, mux)    if err != nil {        panic(err)    }}type fileHanlder struct{}func (*fileHanlder) ServeHTTP(w http.ResponseWriter, r *http.Request) {    io.WriteString(w,&quot;Http Service: &quot;+ r.URL.String())}func sayServer2(w http.ResponseWriter, r *http.Request) {    io.WriteString(w,&quot;sayServer2 Http Service&quot;)}</code></pre><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/file.png" alt="曹理鹏(iCocos)-梦工厂"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;读写文件应该是在开发过程中经常遇到的，今天要跟大家一起分享的就是在golang的世界中，如何读写文件&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="https://icocos.github.io/categories/Go/"/>
    
    
      <category term="Go基础" scheme="https://icocos.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
      <category term="文件操作" scheme="https://icocos.github.io/tags/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Go——Golang Response Snippets</title>
    <link href="https://icocos.github.io/2018/06/01/Go%E2%80%94%E2%80%94Golang-Response-Snippets/"/>
    <id>https://icocos.github.io/2018/06/01/Go——Golang-Response-Snippets/</id>
    <published>2018-06-01T15:49:12.000Z</published>
    <updated>2018-08-06T18:33:42.372Z</updated>
    
    <content type="html"><![CDATA[<p>做过后端开发的应该都知道，我们遇到最多的就是返回数据给客户端，就和客户端要搭界面一样，重复操作着，但是却有必不可少，今天我们来简单说说Golang Response Snippets</p><a id="more"></a><h5 id="Golang-Response-Snippets-JSON-XML-and-more"><a href="#Golang-Response-Snippets-JSON-XML-and-more" class="headerlink" title="Golang Response Snippets: JSON, XML and more"></a>Golang Response Snippets: JSON, XML and more</h5><blockquote><p>Taking inspiration from the Rails layouts and rendering guide, I thought it’d be a nice idea to build a snippet collection illustrating some common HTTP responses for Go web applications.</p></blockquote><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/response.png" alt="曹理鹏(iCocos)-梦工厂"></p><p><a href="https://www.alexedwards.net/blog/golang-response-snippets" target="_blank" rel="noopener">Golang Response Snippets</a></p><h2 id="只返回header"><a href="#只返回header" class="headerlink" title="只返回header"></a>只返回header</h2><p>对于一些请求而言，不需要返回任何的数据，只是返回一个header即可，大大提高了返回服务器响应速度。</p><p>先了解一下net/http包中的几个方法：</p><pre><code>//给一个key设定为响应的value.func (h Header) Set(key, value string)// WriteHeader该方法发送HTTP回复的头域和状态码。如果没有被显式调用，第一次调用Write时会触发隐式调用WriteHeader(http.StatusOK)。因此，显示调用WriterHeader主要用于发送错误状态码。WriteHeader(int) </code></pre><p>在使用的时候，我们可以这么做</p><pre><code>package mainimport (    &quot;net/http&quot;)func main() {    http.HandleFunc(&quot;/&quot;, foo)    http.ListenAndServe(&quot;:8080&quot;, nil)}func foo(w http.ResponseWriter, r *http.Request) {    w.Header().Set(&quot;Server&quot;, &quot;A Go Web Server&quot;)    w.WriteHeader(200)} </code></pre><h5 id="通过curl进行请求：curl-i-localhost-8080"><a href="#通过curl进行请求：curl-i-localhost-8080" class="headerlink" title="通过curl进行请求：curl -i localhost:8080"></a>通过curl进行请求：curl -i localhost:8080</h5><pre><code>curl -i localhost:8080HTTP/1.1 200 OKServer: A Go Web ServerDate: Mon, 29 Jan 2018 02:52:41 GMTContent-Length: 0Content-Type: text/plain; charset=utf-8 </code></pre><h2 id="返回文本"><a href="#返回文本" class="headerlink" title="返回文本"></a>返回文本</h2><p>这个不常用，但是也介绍一下而已。</p><p>用到的方法：</p><pre><code>// Write向连接中写入数据，该数据作为HTTP response的一部分。如果被调用时还没有调用WriteHeader，本方法会先调用WriteHeader(http.StatusOK)。//如果Header中没有&quot;Content-Type&quot;键，本方法会使用包函数DetectContentType检查数据的前512字节，将返回值作为该键的值Write([]byte) (int, error) </code></pre><h5 id="返回文本实际使用方法"><a href="#返回文本实际使用方法" class="headerlink" title="返回文本实际使用方法"></a>返回文本实际使用方法</h5><pre><code>package mainimport (    &quot;net/http&quot;)func main() {    http.HandleFunc(&quot;/&quot;, foo)    http.ListenAndServe(&quot;:8080&quot;, nil)}func foo(w http.ResponseWriter, r *http.Request) {    w.Write([]byte(&quot;I am Gopher&quot;))} </code></pre><h5 id="通过curl进行请求：curl-i-localhost-8080-1"><a href="#通过curl进行请求：curl-i-localhost-8080-1" class="headerlink" title="通过curl进行请求：curl -i localhost:8080"></a>通过curl进行请求：curl -i localhost:8080</h5><pre><code>curl -i localhost:8080HTTP/1.1 200 OKDate: Mon, 29 Jan 2018 03:02:00 GMTContent-Length: 11Content-Type: text/plain; charset=utf-8I am Gopher </code></pre><h2 id="返回JSON"><a href="#返回JSON" class="headerlink" title="返回JSON"></a>返回JSON</h2><p>Go语言里的标准库”encoding/json”</p><p>转换对应表：</p><pre><code>bool类型 转换成JSON中的boolean整型，浮点型转换成JSON中的Number字符串转换成JSON中的字符串（&quot;&quot;而不是&apos;&apos;）结构体转换成JSON中的Object[]byte 会先base64然后转换成JSON中的字符串（&quot;&quot;而不是&apos;&apos;）map 转换成JSON中的Objectinterface{} 会按内部的类型进行实际转换nil 会转换成JSON中的Null</code></pre><p>encodeing/json几乎常用的就两个方法：</p><pre><code>func Marshal(v interface{}) ([]byte, error)func Unmarshal(data []byte, v interface{}) error</code></pre><p>顾名思义“Marshal”将Go对象进行转换成JSON，而”Unmarshal”则是将JSON转换成Go对象。</p><pre><code>package mainimport (    &quot;encoding/json&quot;    &quot;net/http&quot;) // 为了对应关系可以一一对应上，我们需要手动的为结构体打上Tag，才能转换到正确的JSON // structTag还有一些其他有用的属性，比如： //     omitempty 如果JSON字段为空则忽略 //     - 直接忽略 type Profile struct {    Name    string   `json:&quot;name&quot;`    Hobbies []string `json:&quot;hobbies&quot;`}func main() {    http.HandleFunc(&quot;/&quot;, foo)    http.ListenAndServe(&quot;:8080&quot;, nil)}func foo(w http.ResponseWriter, r *http.Request) {    profile := Profile{&quot;SuperWang&quot;, []string{&quot;football&quot;, &quot;programming&quot;}}    js, err := json.Marshal(profile)    if err != nil {        http.Error(w, err.Error(), http.StatusInternalServerError)        return    }    w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)    w.Write(js)} </code></pre><p>有时候你想更灵活的使用JSON，这个时候就要用到json.RawMessage，多数情况下，我们不会使用到它。在JSON中，有一个字段的格式是未知的，比如可能是string，也可能是int，那么这个时候就要用到*json.RawMessage了。</p><p>不过在转换的过程中，如果我们定义的是结构体，跟Map会有一些不同，以下几点是要注意的：</p><pre><code>结构体的成员必须是大写开头使用Marshal时会按结构体成员的变量名做为KeyUnmarshal时会自动匹配结构体成员，大小写不敏感，如果JSON中有多余字段，会直接抛弃，如果缺少某个字段，则会忽略对结构体成员赋值</code></pre><h5 id="通过curl进行请求：curl-i-localhost-8080-2"><a href="#通过curl进行请求：curl-i-localhost-8080-2" class="headerlink" title="通过curl进行请求：curl -i localhost:8080"></a>通过curl进行请求：curl -i localhost:8080</h5><pre><code>curl -i localhost:8080HTTP/1.1 200 OKContent-Type: application/jsonDate: Mon, 29 Jan 2018 03:10:52 GMTContent-Length: 57{&quot;name&quot;:&quot;SuperWang&quot;,&quot;hobbies&quot;:[&quot;football&quot;,&quot;programming&quot;]}</code></pre><h2 id="返回XML"><a href="#返回XML" class="headerlink" title="返回XML"></a>返回XML</h2><p>很久之前，很多人讨论xml和json孰是孰非，渐渐地xml越来越被人们遗忘。<br>但是一些接口还是需要使用xml的，比如xmpp协议。</p><pre><code>package mainimport (    &quot;encoding/xml&quot;    &quot;net/http&quot;)type Profile struct {    Name    string    Hobbies []string `xml:&quot;Hobbies&gt;Hobby&quot;`}func main() {    http.HandleFunc(&quot;/&quot;, foo)    http.ListenAndServe(&quot;:8080&quot;, nil)}func foo(w http.ResponseWriter, r *http.Request) {    profile := Profile{&quot;SuperWang&quot;, []string{&quot;football&quot;, &quot;programming&quot;}}    x, err := xml.MarshalIndent(profile, &quot;&quot;, &quot;  &quot;)    if err != nil {        http.Error(w, err.Error(), http.StatusInternalServerError)        return    }    w.Header().Set(&quot;Content-Type&quot;, &quot;application/xml&quot;)    w.Write(x)} </code></pre><p>通过curl进行请求：curl -i localhost:8080</p><pre><code>curl -i localhost:8080HTTP/1.1 200 OKContent-Type: application/xmlDate: Mon, 29 Jan 2018 03:16:00 GMTContent-Length: 129&lt;Profile&gt;  &lt;Name&gt;SuperWang&lt;/Name&gt;  &lt;Hobbies&gt;    &lt;Hobby&gt;football&lt;/Hobby&gt;    &lt;Hobby&gt;programming&lt;/Hobby&gt;  &lt;/Hobbies&gt;&lt;/Profile&gt; </code></pre><h2 id="返回文件"><a href="#返回文件" class="headerlink" title="返回文件"></a>返回文件</h2><p>通过接口，返回一张图片，一个文本文件等等，都是很常见的。</p><pre><code>package mainimport (    &quot;net/http&quot;    &quot;path&quot;)func main() {    http.HandleFunc(&quot;/&quot;, foo)    http.ListenAndServe(&quot;:8080&quot;, nil)}func foo(w http.ResponseWriter, r *http.Request) {    fp := path.Join(&quot;images&quot;, &quot;foo.png&quot;)    http.ServeFile(w, r, fp)} </code></pre><p>建一个images文件夹，放入foo.png文件，运行，</p><h5 id="运行，浏览器输入："><a href="#运行，浏览器输入：" class="headerlink" title="运行，浏览器输入："></a>运行，浏览器输入：</h5><ul><li><a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a></li></ul><h2 id="返回HTML"><a href="#返回HTML" class="headerlink" title="返回HTML"></a>返回HTML</h2><p>下面是返回一个HTML的网页。</p><pre><code>package mainimport (    &quot;html/template&quot;    &quot;net/http&quot;    &quot;path&quot;)type Profile struct {    Name    string    Hobbies []string}func main() {    http.HandleFunc(&quot;/&quot;, foo)    http.ListenAndServe(&quot;:8080&quot;, nil)}func foo(w http.ResponseWriter, r *http.Request) {    profile := Profile{&quot;SpuerWang&quot;, []string{&quot;snowboarding&quot;, &quot;programming&quot;}}    fp := path.Join(&quot;templates&quot;, &quot;index.html&quot;)    tmpl, err := template.ParseFiles(fp)    if err != nil {        http.Error(w, err.Error(), http.StatusInternalServerError)        return    }    if err := tmpl.Execute(w, profile); err != nil {        http.Error(w, err.Error(), http.StatusInternalServerError)    }} </code></pre><p>新建文件夹templates，在里面新建文件inde.html:</p><pre><code>&lt;h1&gt;Title {{ .Name }}&lt;/h1&gt;&lt;p&gt;.....&lt;/p&gt;</code></pre><h5 id="运行，浏览器输入：-1"><a href="#运行，浏览器输入：-1" class="headerlink" title="运行，浏览器输入："></a>运行，浏览器输入：</h5><ul><li><a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做过后端开发的应该都知道，我们遇到最多的就是返回数据给客户端，就和客户端要搭界面一样，重复操作着，但是却有必不可少，今天我们来简单说说Golang Response Snippets&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="https://icocos.github.io/categories/Go/"/>
    
    
      <category term="Go基础" scheme="https://icocos.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Response" scheme="https://icocos.github.io/tags/Response/"/>
    
  </entry>
  
  <entry>
    <title>Go——简单说说goroutine和channel</title>
    <link href="https://icocos.github.io/2018/05/29/Go%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E8%AF%B4%E8%AF%B4goroutine%E5%92%8Cchannel/"/>
    <id>https://icocos.github.io/2018/05/29/Go——简单说说goroutine和channel/</id>
    <published>2018-05-29T15:41:55.000Z</published>
    <updated>2018-08-06T17:26:22.452Z</updated>
    
    <content type="html"><![CDATA[<p>Go 语言中的 channel 是实现  goroutine 间无锁通信的关键机制，他使得写多线程并发程序变得简单、灵活、触手可得，今天我们来简单说说goroutine和channel</p><a id="more"></a><h4 id="引言："><a href="#引言：" class="headerlink" title="引言："></a>引言：</h4><ul><li>Go 语言中的 channel 是实现  goroutine 间无锁通信的关键机制，他使得写多线程并发程序变得简单、灵活、触手可得</li></ul><p>channel是消息传递的机制，用于多线程环境下lock free synchronization.</p><ul><li>它同时具备2个特性：<ol><li>消息传递</li><li>同步</li></ol></li></ul><ul><li>参考文章：<ul><li><a href="https://blog.csdn.net/kongdefei5000/article/details/75209005" target="_blank" rel="noopener">https://blog.csdn.net/kongdefei5000/article/details/75209005</a></li><li><a href="https://blog.csdn.net/nobugtodebug/article/details/45396507" target="_blank" rel="noopener">https://blog.csdn.net/nobugtodebug/article/details/45396507</a></li></ul></li></ul><h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><blockquote><p>channel 分类： 不带缓存 channel， 带缓存 channel</p></blockquote><p>无缓冲的与有缓冲channel有着重大差别，那就是一个是同步的 一个是非同步的。</p><pre><code>c1:=make(chan int)         无缓冲c2:=make(chan int,1)      有缓冲c1&lt;-1</code></pre><ul><li>无缓冲： 不仅仅是向 c1 通道放 1，而是一直要等有别的携程 &lt;-c1 接手了这个参数，那么c1&lt;-1才会继续下去，要不然就一直阻塞着。</li><li>有缓冲： c2&lt;-1 则不会阻塞，因为缓冲大小是1(其实是缓冲大小为0)，只有当放第二个值的时候，第一个还没被人拿走，这时候才会阻塞。</li></ul><h5 id="不带缓存-channel"><a href="#不带缓存-channel" class="headerlink" title="不带缓存 channel"></a>不带缓存 channel</h5><pre><code>（a）创建channel    make(chan type)    e.g.   ch := make(chan int)（b）通信方式(由于chan操作类似于Queue，为便于理解这里用EnQueue,DeQueue来描述通信操作)    EnQueue:    ch &lt;- typevar        DeQueue:   var :=  &lt;- ch    e.g.    ch &lt;- 1    v := &lt;-ch</code></pre><ul><li>关键：<ul><li>调用channel EnQueue 操作之后被阻塞住（不管channel是否为空），直到写的数据被读取掉。</li><li>调用channel DeQueue 操作时，如果channel中有数据则被读出，如果为空则阻塞住，直到有人往里面EnQueue数据。</li></ul></li></ul><h5 id="带缓存-channel"><a href="#带缓存-channel" class="headerlink" title="带缓存 channel"></a>带缓存 channel</h5><pre><code>（a）创建channel    make(chan type, size)    e.g.  ch := make(chan int, 9)（b）通信方式    同不带缓存channel</code></pre><ul><li>关键：<ul><li>当channel中元素小于等于channel size时，调用channel EnQueue 操作后数据被放入到缓存中（非阻塞）；</li><li>当channel满以后，如果再调用EnQueue操作就会被阻塞住直到有元素被DeQueue出来。</li><li>调用channel DeQueue 操作时，如果channel 为空则阻塞住直到有人往里面EnQueue数据，否则直接DeQueue出元素。</li></ul></li></ul><blockquote><p>注意: </p></blockquote><blockquote><p>需要特别注意的是两者对于range操作的区别：</p></blockquote><blockquote><p>无缓存channel是EnQueue一个数据被range读一个；</p></blockquote><blockquote><p>而带缓存channel是EnQueue满之后被range整个一起拿出来用(这个机制对于用户是透明的，用户看到的还是一个一个拿出来)，或者timeout时间到之后即使channel没有满也会被range拿出来。</p></blockquote><blockquote><p>另外，channel 关闭之后，循环读channel操作(e.g. for v:=range channel) 读完channel中剩余数据会自动跳出循环。</p></blockquote><ul><li>参考网络介绍：</li></ul><blockquote><p>顾名思义，就是通道。通道的目的是用来传递数据。在一个通道上我们可以执行数据的发送(Send)和接受(Receive)操作。对于非缓冲的 channel 而言，Receive 方法执行时，会判断该通道上是否有值，如果没有就会等待(阻塞)，直到有一个值为止。同样，在 channel 上有值，而尚未被一个 Receiver 接受的时候，Send 方法也会阻塞，直到 Channel 变空。这样，通过一个简单的机制就可以保证 Send 和 Receive 总是在不同的时间执行的，而且只有 Send 之后才能 Receive. 这样就避免了常规的多线程编程中数据共享的问题。正如 Go 语言的文档一句话所说：</p></blockquote><blockquote><p>Do not communicate by sharing memory; instead, share memory by communicating.</p></blockquote><blockquote><p>不要通过共享内存来沟通;而是通过沟通来共享内存。</p></blockquote><blockquote><p>在常规的多线程编程里，我们总是定义好一些类变量，如果这些变量有可能被多个线程同时访问，那么就需要加锁。这样带来了一定的编程复杂性，如果代码写的稍有bug，则会导致读/写到错误的值。</p></blockquote><blockquote><p>而通过 channel 来沟通，我们得到了一个更为清晰的沟通方式。两个线程(或者 goroutine)要读写相同的数据，则创建一个通道，双方通过对这个通道执行 Send / Receive 的操作来设值或取值即可，相对而言，比较不容易出错。</p></blockquote><h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><ul><li>goroutine的并发模型定义为以下几个要点：<ul><li>基于Thread的轻量级协程</li><li>通过channel来进行协程间的消息传递</li><li>只暴露协程，屏蔽线程操作的接口</li></ul></li></ul><h4 id="goroutine原理"><a href="#goroutine原理" class="headerlink" title="goroutine原理"></a>goroutine原理</h4><blockquote><p>Golang的runtime实现了goroutine和OS thread的M:N模型，因此实际的goroutine是基于线程的更加轻量级的实现，我们便可以在Golang中大量创建goroutine而不用担心昂贵的context swtich所带来的开销。goroutine之间，我们可以通过channel来进行交互。由于go已将将所有system call都wrap到了标准库中，在针对这些systemcall进行调用时会主动标记goroutine为阻塞状态并保存现场，交由scheduler执行。所以在golang中，在大部分情况下我们可以非常安心地在goroutine中使用阻塞操作而不用担心并发性受到影响。</p></blockquote><p>在操作系统的OS Thread和编程语言的User Thread之间，实际上存在3中线程对应模型，也就是：1:1，1:N，M:N。</p><ul><li>N:1是说，多个（N）用户线程始终在一个内核线程上跑，context上下文切换确实很快，但是无法真正的利用多核。</li><li>1:1是说，一个用户线程就只在一个内核线程上跑，这时可以利用多核，但是上下文switch很慢，频繁切换效率很低。</li><li>M:N是说， 多个goroutine在多个内核线程上跑，这个看似可以集齐上面两者的优势，但是无疑增加了调度的难度。</li></ul><p>goroutine google runtime默认的实现为M:N的模型，于是这样可以根据具体的操作类型（操作系统阻塞或非阻塞操作）调整goroutine和OS Thread的映射情况，显得更加的灵活。</p><h5 id="在goroutine实现中，有三个最重要的数据结构，分别为G-M-P："><a href="#在goroutine实现中，有三个最重要的数据结构，分别为G-M-P：" class="headerlink" title="在goroutine实现中，有三个最重要的数据结构，分别为G M P："></a>在goroutine实现中，有三个最重要的数据结构，分别为G M P：</h5><pre><code>G：代表一个goroutineM：代表 一个OS ThreadP：一个P和一个M进行绑定，代表在这个OS Thread上的调度器</code></pre><blockquote><p>goroutine - 可以大致理解为一种轻量级的线程(或微线程)，它是一种“分配在同一个地址空间内的，能够并行执行的函数”。同时，它是轻量级的，不需要像分配线程那样分配独立的栈空间。所以理论上讲，我们可以很容易的分配很多个 goroutine, 让它们并发执行，而其开销则比多线程程序要小得多，从而可以让程序支持比较大的并发性。</p></blockquote><h5 id="goroutinue，本质上就是协程。但有两点不同："><a href="#goroutinue，本质上就是协程。但有两点不同：" class="headerlink" title="goroutinue，本质上就是协程。但有两点不同："></a>goroutinue，本质上就是协程。但有两点不同：</h5><ol><li>goroutinue可以实现并行，也就是说，多个协程可以在多个处理器同时跑。而协程同一时刻只能在一个处理器上跑（把宿主语言想象成单线程的就好了）。</li><li>goroutine之间的通信是通过channel，而协程的通信是通过yield和resume()操作。</li></ol><h5 id="那么如果有两个A-B两个协程-在放入和取出数据时都只能用int类型的数据进行通信"><a href="#那么如果有两个A-B两个协程-在放入和取出数据时都只能用int类型的数据进行通信" class="headerlink" title="那么如果有两个A,B两个协程 在放入和取出数据时都只能用int类型的数据进行通信"></a>那么如果有两个A,B两个协程 在放入和取出数据时都只能用int类型的数据进行通信</h5><ul><li>如 取数据 &lt;- channel 放数据 channel &lt;- 1</li></ul><blockquote><p>协程之间可以通过在通道中放入-取出数据的方式进行通信</p></blockquote><h2 id="3种优雅的Go-channel用法"><a href="#3种优雅的Go-channel用法" class="headerlink" title="3种优雅的Go channel用法"></a>3种优雅的Go channel用法</h2><p>写Go的人应该都听过Rob Pike的这句话</p><pre><code>Do not communicate by sharing memory; instead, share memory by communicating.</code></pre><p>相信很多朋友和我一样，在实际应用中总感觉不到好处，为了用channel而用。但以我的切身体会来说，这是写代码时碰到的场景不复杂、对channel不熟悉导致的，所以希望这篇文章能给大家带来点新思路，对Golang优雅的channel有更深的认识 ：）</p><h3 id="Fan-In-Out"><a href="#Fan-In-Out" class="headerlink" title="Fan In/Out"></a>Fan In/Out</h3><p>数据的输出有时候需要做扇出／入（FanIn／Out），但是在函数中调用常常得修改接口，而且上下游对于数据的依赖程度非常高，所以一般使用通过channel进行Fan In／Out，这样就可以轻易实现类似于shell里的管道。</p><pre><code>func fanIn(input1, input2 &lt;-chan string) &lt;-chan string {    c := make(chan string)    go func() {        for {            select {                case s := &lt;-input1:  c &lt;- s                case s := &lt;-input2:  c &lt;- s            }        }    }()    return c}</code></pre><h3 id="同步Goroutine"><a href="#同步Goroutine" class="headerlink" title="同步Goroutine"></a>同步Goroutine</h3><p>两个goroutine之间同步状态，例如A goroutine需要让B goroutine退出，一般做法如下：</p><pre><code>func main() {    g = make(chan int)    quit = make(chan bool)    go B()    for i := 0; i &lt; 3; i++ {        g &lt;- i    }    quit &lt;- true // 没办法等待B的退出只能Sleep    fmt.Println(&quot;Main quit&quot;)}func B() {    for {        select {            case i := &lt;-g:            fmt.Println(i + 1)            case &lt;-quit:            fmt.Println(&quot;B quit&quot;)            return        }    }}</code></pre><h5 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h5><pre><code>/*Output:123Main quit*/</code></pre><p>可是了main函数没办法等待B合适地退出，所以B quit 没办法打印，程序直接退出了。然而，chan是Go里的第一对象，所以可以把chan传入chan中，所以上面的代码可以把quit 定义为chan chan bool，以此控制两个goroutine的同步</p><pre><code>func main() {    g = make(chan int)    quit = make(chan chan bool)    go B()    for i := 0; i &lt; 5; i++ {        g &lt;- i    }    wait := make(chan bool)    quit &lt;- wait    &lt;-wait //这样就可以等待B的退出了    fmt.Println(&quot;Main Quit&quot;)}func B() {    for {        select {            case i := &lt;-g:            fmt.Println(i + 1)            case c := &lt;-quit:            c &lt;- true            fmt.Println(&quot;B Quit&quot;)            return        }    }}</code></pre><h5 id="Log-1"><a href="#Log-1" class="headerlink" title="Log"></a>Log</h5><pre><code>/* Output123B QuitMain Quit*/</code></pre><h3 id="分布式递归调用"><a href="#分布式递归调用" class="headerlink" title="分布式递归调用"></a>分布式递归调用</h3><p>在现实生活中，如果你要找美国总统聊天，你会怎么做？第一步打电话给在美国的朋友，然后他们也会发动自己的关系网，再找可能认识美国总统的人，以此类推，直到找到为止。这在Kadmelia分布式系统中也是一样的，如果需要获取目标ID信息，那么就不停地查询，被查询节点就算没有相关信息，也会返回它觉得最近节点，直到找到ID或者等待超时。 好了，这个要用Go来实现怎么做呢？</p><pre><code>func recursiveCall(ctx context.Context, id []byte, initialNodes []*node){    seen := map[string]*node{} //已见过的节点记录    request := make(chan *node, 3) //设置请求节点channel    // 输入初始节点    go func() {        for _, n := range initialNodes {            request &lt;- n        }    }()    OUT:    for {        //循环直到找到数据        if data != nil {            return        }        // 在新的请求，超时和上层取消请求中select        select {            case n := &lt;-request:            go func() {                // 发送新的请求                response := s.sendQuery(ctx, n, MethodFindValue, id)                select {                    case &lt;-ctx.Done():                    case msg :=&lt;-response:                    seen[responseToNode(response)] = n //更新已见过的节点信息                    // 加载新的节点                    for _, rn := range LoadNodeInfoFromByte(msg[PayLoadStart:]) {                        mu.Lock()                        _, ok := seen[rn.HexID()]                        mu.Unlock()                        // 见过了，跳过这个节点                        if ok {                            continue                        }                        AddNode(rn)                        // 将新的节点送入channel                        request &lt;- rn                        }                    }                }            }()            case &lt;-time.After(500 * time.Millisecond):            break OUT // break至外层，否则仅仅是跳至loop外            case &lt;-ctx.Done():            break OUT        }    }    return}</code></pre><p>这时的buffered channel类似于一个局部queue，对需要的节点进行处理，但这段代码的精妙之处在于，这里的block操作是select的，随时可以取消，而不是要等待或者对queue的长度有认识。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Go 语言中的 channel 是实现  goroutine 间无锁通信的关键机制，他使得写多线程并发程序变得简单、灵活、触手可得，今天我们来简单说说goroutine和channel&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="https://icocos.github.io/categories/Go/"/>
    
    
      <category term="Go基础" scheme="https://icocos.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
      <category term="goroutine和channel" scheme="https://icocos.github.io/tags/goroutine%E5%92%8Cchannel/"/>
    
  </entry>
  
  <entry>
    <title>Go——函数与方法的奇妙之处</title>
    <link href="https://icocos.github.io/2018/05/25/Go%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E4%B8%8E%E6%96%B9%E6%B3%95%E7%9A%84%E5%A5%87%E5%A6%99%E4%B9%8B%E5%A4%84/"/>
    <id>https://icocos.github.io/2018/05/25/Go——函数与方法的奇妙之处/</id>
    <published>2018-05-25T14:44:39.000Z</published>
    <updated>2018-08-06T17:26:22.335Z</updated>
    
    <content type="html"><![CDATA[<p>有过（面向对象）编程经验的应该都知道方法或者函数，比如在C，PHP，swift，OC，Java，kotlin等都有函数或者方法的存在，或者有二者的存在，只是有些人没有太过留意，比如PHP中就有这样的现象，而iOS中除了存在方法和行数，方法还分类方法和对象方法。</p><a id="more"></a><p>有过（面向对象）编程经验的应该都知道方法或者函数，比如在C，PHP，swift，OC，Java，kotlin等都有函数或者方法的存在，或者有二者的存在，只是有些人没有太过留意，比如PHP中就有这样的现象，而iOS中除了存在方法和行数，方法还分类方法和对象方法。</p><blockquote><p>那么Golang中方法和行数的本质意义其实差不多，只是定义和使用的语法不同而已。</p></blockquote><p>这里我们就来说说Golang中函数与方法，</p><h2 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h2><h5 id="行数定义"><a href="#行数定义" class="headerlink" title="行数定义"></a>行数定义</h5><pre><code>func function_name( [parameter list] ) [return_types]{   body of the function}</code></pre><h5 id="不允许函数内嵌定义"><a href="#不允许函数内嵌定义" class="headerlink" title="不允许函数内嵌定义"></a>不允许函数内嵌定义</h5><pre><code>func main() {    func swap(x, y string) (string, string) {    return y, x    }}</code></pre><h5 id="支持多返回值、支持命名返回值"><a href="#支持多返回值、支持命名返回值" class="headerlink" title="支持多返回值、支持命名返回值"></a>支持多返回值、支持命名返回值</h5><pre><code>func split(sum int) (x, y int) {    return}</code></pre><h5 id="函数只能判断是否为nil"><a href="#函数只能判断是否为nil" class="headerlink" title="函数只能判断是否为nil"></a>函数只能判断是否为nil</h5><pre><code>fmt.Println(add == nil)//fmt.Println(add == 1)  //错误 mismatched types func(int, int) int and int)</code></pre><h5 id="参数视为局部变量，因此不能声明同名变量"><a href="#参数视为局部变量，因此不能声明同名变量" class="headerlink" title="参数视为局部变量，因此不能声明同名变量"></a>参数视为局部变量，因此不能声明同名变量</h5><pre><code>func add(a, b int) int {    a := 2}</code></pre><h5 id="不支持默认参数、已”-”命名的参赛也不能忽略"><a href="#不支持默认参数、已”-”命名的参赛也不能忽略" class="headerlink" title="不支持默认参数、已”_”命名的参赛也不能忽略"></a>不支持默认参数、已”_”命名的参赛也不能忽略</h5><pre><code>func add(a, b int, _ bool) int {    return a + b}func main() {    fmt.Println(add(1,2, true))    //fmt.Println(add(1,2) // 错误：not enough arguments in call to add}</code></pre><h5 id="支持可变参数"><a href="#支持可变参数" class="headerlink" title="支持可变参数"></a>支持可变参数</h5><pre><code>func test(str string, a ...int) {    fmt.Println(&quot;%T, %v\n&quot;, str, a)}func main() {    test(&quot;a&quot;, 1, 2, 3)}</code></pre><h5 id="可以在函数内定义匿名函数"><a href="#可以在函数内定义匿名函数" class="headerlink" title="可以在函数内定义匿名函数"></a>可以在函数内定义匿名函数</h5><pre><code>func main() {    func (s string) {        fmt.Println(s)    } (&quot;hello, go!&quot;)}</code></pre><h5 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h5><pre><code>// This function `intSeq` returns another function, which// we define anonymously in the body of `intSeq`. The// returned function _closes over_ the variable `i` to// form a closure.func intSeq() func() int {    i := 0    return func() int {        i += 1        return i    }}func main() {    // We call `intSeq`, assigning the result (a function)    // to `nextInt`. This function value captures its    // own `i` value, which will be updated each time    // we call `nextInt`.    nextInt := intSeq()    // See the effect of the closure by calling `nextInt`    // a few times.    fmt.Println(nextInt())    fmt.Println(nextInt())    fmt.Println(nextInt())    // To confirm that the state is unique to that    // particular function, create and test a new one.    newInts := intSeq()    fmt.Println(newInts())}</code></pre><ul><li>注意<ul><li>函数的左花括号也不能另起一行</li><li>不支持函数重载</li></ul></li></ul><h2 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h2><h5 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h5><pre><code>func (r Recevier) function_name(){   body of the method}</code></pre><h5 id="定义和使用："><a href="#定义和使用：" class="headerlink" title="定义和使用："></a>定义和使用：</h5><pre><code>type Vertex struct {    X, Y float64}func (v Vertex) Abs() float64 {    return math.Sqrt(v.X*v.X + v.Y*v.Y)}func main() {    v := Vertex{3, 4}    fmt.Println(v.Abs())}</code></pre><h5 id="下面来仔细看看官方对方法给出的一个例子"><a href="#下面来仔细看看官方对方法给出的一个例子" class="headerlink" title="下面来仔细看看官方对方法给出的一个例子"></a>下面来仔细看看官方对方法给出的一个例子</h5><pre><code>package mainimport &quot;fmt&quot;type rect struct {    width, height int}// This `area` method has a _receiver type_ of `*rect`.func (r *rect) area() int {    return r.width * r.height}// Methods can be defined for either pointer or value// receiver types. Here&apos;s an example of a value receiver.func (r rect) perim() int {    return 2*r.width + 2*r.height}func main() {    r := rect{width: 10, height: 5}    // Here we call the 2 methods defined for our struct.    fmt.Println(&quot;area: &quot;, r.area())    fmt.Println(&quot;perim:&quot;, r.perim())    // Go automatically handles conversion between values    // and pointers for method calls. You may want to use    // a pointer receiver type to avoid copying on method    // calls or to allow the method to mutate the    // receiving struct.    rp := &amp;r    fmt.Println(&quot;area: &quot;, rp.area())    fmt.Println(&quot;perim:&quot;, rp.perim())}</code></pre><blockquote><p>其实是利用方法求长方形的周长和面积，其中也给出了receiver作为指针和值的区别</p></blockquote><ul><li>这里也简单说下：什么时候receiver用指针<ul><li>1 改变receiver的值</li><li>2 struct本身非常的大，这样拷贝的代价是很昂贵的</li><li>3 如果struct的一个method中receiver为指针，那么其他的method的receiver最好也要用指针。</li></ul></li></ul><h2 id="方法与函数的区别"><a href="#方法与函数的区别" class="headerlink" title="方法与函数的区别"></a>方法与函数的区别</h2><p>在golang的世界中，一定要区分 方法和函数。</p><p>Go中没有类的概念，但是我们可以在一些类型上定义一些方法，也就是所谓的方法，跟函数不同。</p><ul><li>方法和函数定义语法区别在于：<ul><li>方法是针对对象的（有些是针对类）</li><li>函数是针对全局的（Golang中指包），</li><li>方法前置实例接受参数，这个receiver可以是基础类型也可以是指针。</li></ul></li></ul><blockquote><p>虽然Go语言没有类的概念，但它支持的数据类型可以定义对应的method(s)。本质上说，所谓的method(s)其实就是函数，只不过与普通函数相比，这类函数是作用在某个数据类型上的，所以在函数签名中，会有个receiver(接收器)来表明当前定义的函数会作用在该receiver上。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有过（面向对象）编程经验的应该都知道方法或者函数，比如在C，PHP，swift，OC，Java，kotlin等都有函数或者方法的存在，或者有二者的存在，只是有些人没有太过留意，比如PHP中就有这样的现象，而iOS中除了存在方法和行数，方法还分类方法和对象方法。&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="https://icocos.github.io/categories/Go/"/>
    
    
      <category term="Go基础" scheme="https://icocos.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
      <category term="函数与方法" scheme="https://icocos.github.io/tags/%E5%87%BD%E6%95%B0%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Go语言中的Array、Slice、Map和Set</title>
    <link href="https://icocos.github.io/2018/05/22/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84Array%E3%80%81Slice%E3%80%81Map%E5%92%8CSet/"/>
    <id>https://icocos.github.io/2018/05/22/Go语言中的Array、Slice、Map和Set/</id>
    <published>2018-05-22T15:01:33.000Z</published>
    <updated>2018-08-09T09:08:36.310Z</updated>
    
    <content type="html"><![CDATA[<p>Go语言中和其他语言一样，存在数组，Map(iOS中的字典)，但是还有一个比较特殊的Slice，他其实底层还是数组，今天我们来简单说说Go语言中的Array、Slice、Map和Set</p><a id="more"></a><h2 id="Array-数组"><a href="#Array-数组" class="headerlink" title="Array(数组)"></a>Array(数组)</h2><h5 id="内部机制"><a href="#内部机制" class="headerlink" title="内部机制"></a>内部机制</h5><blockquote><p>在 Go 语言中数组是固定长度的数据类型，它包含相同类型的连续的元素，这些元素可以是内建类型，像数字和字符串，也可以是结构类型，元素可以通过唯一的索引值访问，从 0 开始。</p></blockquote><p>数组是很有价值的数据结构，因为它的内存分配是连续的，内存连续意味着可是让它在 CPU 缓存中待更久，所以迭代数组和移动元素都会非常迅速。</p><h5 id="数组声明和初始化"><a href="#数组声明和初始化" class="headerlink" title="数组声明和初始化"></a>数组声明和初始化</h5><p>通过指定数据类型和元素个数(数组长度)来声明数组。</p><pre><code>// 声明一个长度为5的整数数组var array [5]int</code></pre><p>一旦数组被声明了，那么它的数据类型跟长度都不能再被改变。如果你需要更多的元素，那么只能创建一个你想要长度的新的数组，然后把原有数组的元素拷贝过去。</p><blockquote><p>Go 语言中任何变量被声明时，都会被默认初始化为各自类型对应的 0 值，数组当然也不例外。当一个数组被声明时，它里面包含的每个元素都会被初始化为 0 值。</p></blockquote><p>一种快速创建和初始化数组的方法是使用数组字面值。数组字面值允许我们声明我们需要的元素个数并指定数据类型：</p><pre><code>// 声明一个长度为5的整数数组// 初始化每个元素array := [5]int{7, 77, 777, 7777, 77777}</code></pre><p>如果你把长度写成 …，Go 编译器将会根据你的元素来推导出长度：</p><pre><code>// 通过初始化值的个数来推导出数组容量array := [...]int{7, 77, 777, 7777, 77777}</code></pre><p>如果我们知道想要数组的长度，但是希望对指定位置元素初始化，可以这样：</p><pre><code>// 声明一个长度为5的整数数组// 为索引为1和2的位置指定元素初始化// 剩余元素为0值array := [5]int{1: 77, 2: 777}</code></pre><h5 id="使用数组"><a href="#使用数组" class="headerlink" title="使用数组"></a>使用数组</h5><p>使用 [] 操作符来访问数组元素：</p><pre><code>array := [5]int{7, 77, 777, 7777, 77777}// 改变索引为2的元素的值array[2] = 1</code></pre><p>我们可以定义一个指针数组：</p><pre><code>array := [5]*int{0: new(int), 1: new(int)}// 为索引为0和1的元素赋值*array[0] = 7*array[1] = 77</code></pre><p>在 Go 语言中数组是一个值，所以可以用它来进行赋值操作。一个数组可以被赋值给任意相同类型的数组：</p><pre><code>var array1 [5]stringarray2 := [5]string{&quot;Red&quot;, &quot;Blue&quot;, &quot;Green&quot;, &quot;Yellow&quot;, &quot;Pink&quot;}array1 = array2</code></pre><p>注意数组的类型同时包括数组的长度和可以被存储的元素类型，数组类型完全相同才可以互相赋值，比如下面这样就不可以：</p><pre><code>var array1 [4]stringarray2 := [5]string{&quot;Red&quot;, &quot;Blue&quot;, &quot;Green&quot;, &quot;Yellow&quot;, &quot;Pink&quot;}array1 = array2// 编译器会报错Compiler Error:cannot use array2 (type [5]string) as type [4]string in assignment</code></pre><p>拷贝一个指针数组实际上是拷贝指针值，而不是指针指向的值：</p><pre><code>var array1 [3]*stringarray2 := [3]*string{new(string), new(string), new(string)}*array2[0] = &quot;Red&quot;*array2[1] = &quot;Blue&quot;*array2[2] = &quot;Green&quot;array1 = array2// 赋值完成后，两组指针数组指向同一字符串</code></pre><h5 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h5><p>数组总是一维的，但是可以组合成多维的。多维数组通常用于有父子关系的数据或者是坐标系数据：</p><pre><code>// 声明一个二维数组var array [4][2]int// 使用数组字面值声明并初始化array := [4][2]int{{10, 11}, {20, 21}, {30, 31}, {40, 41}}// 指定外部数组索引位置初始化array := [4][2]int{1: {20, 21}, 3: {40, 41}}// 同时指定内外部数组索引位置初始化array := [4][2]int{1: {0: 20}, 3: {1: 41}}</code></pre><p>同样通过 [] 操作符来访问数组元素：</p><pre><code>var array [2][2]intarray[0][0] = 0array[0][1] = 1array[1][0] = 2array[1][1] = 3</code></pre><p>也同样的相同类型的多维数组可以相互赋值：</p><pre><code>var array1 = [2][2]intvar array2 = [2][2]intarray[0][0] = 0array[0][1] = 1array[1][0] = 2array[1][1] = 3array1 = array2</code></pre><p>因为数组是值，我们可以拷贝单独的维：</p><pre><code>var array3 [2]int = array1[1]var value int = array1[1][0]</code></pre><h5 id="在函数中传递数组"><a href="#在函数中传递数组" class="headerlink" title="在函数中传递数组"></a>在函数中传递数组</h5><p>在函数中传递数组是非常昂贵的行为，因为在函数之间传递变量永远是传递值，所以如果变量是数组，那么意味着传递整个数组，即使它很大很大很大。。。</p><p>举个栗子，创建一个有百万元素的整形数组，在64位的机器上它需要8兆的内存空间，来看看我们声明它和传递它时发生了什么：</p><pre><code>var array [1e6]intfoo(array)func foo(array [1e6]int) {  ...}</code></pre><p>每一次 foo 被调用，8兆内存将会被分配在栈上。一旦函数返回，会弹栈并释放内存，每次都需要8兆空间。</p><p>Go 语言当然不会这么傻，有更好的方法来在函数中传递数组，那就是传递指向数组的指针，这样每次只需要分配8字节内存：</p><pre><code>var array [1e6]intfoo(&amp;array)func foo(array *[1e6]int){  ...}</code></pre><p>但是注意如果你在函数中改变指针指向的值，那么原始数组的值也会被改变。幸运的是 slice(切片)可以帮我们处理好这些问题，来一起看看。</p><h2 id="Slice-切片"><a href="#Slice-切片" class="headerlink" title="Slice(切片)"></a>Slice(切片)</h2><h5 id="内部机制和基础"><a href="#内部机制和基础" class="headerlink" title="内部机制和基础"></a>内部机制和基础</h5><p>slice 是一种可以动态数组，可以按我们的希望增长和收缩。它的增长操作很容易使用，因为有内建的 append 方法。我们也可以通过 relice 操作化简 slice。因为 slice 的底层内存是连续分配的，所以 slice 的索引，迭代和垃圾回收性能都很好。</p><p>slice 是对底层数组的抽象和控制。它包含 Go 需要对底层数组管理的三种元数据，分别是：</p><ol><li>指向底层数组的指针</li><li>slice 中元素的长度</li><li>slice 的容量(可供增长的最大值)</li></ol><h5 id="创建和初始化"><a href="#创建和初始化" class="headerlink" title="创建和初始化"></a>创建和初始化</h5><p>Go 中创建 slice 有很多种方法，我们一个一个来看。</p><p>第一个方法是使用内建的函数 make。当我们使用 make 创建时，一个选项是可以指定 slice 的长度：</p><pre><code>slice := make([]string, 5)</code></pre><p>如果只指定了长度，那么容量默认等于长度。我们可以分别指定长度和容量：</p><pre><code>slice := make([]int, 3, 5)</code></pre><p>当我们分别指定了长度和容量，我们创建的 slice 就可以拥有一开始并没有访问的底层数组的容量。上面代码的 slice 中，可以访问3个元素，但是底层数组有5个元素。两个与长度不相干的元素可以被 slice 来用。新创建的 slice 同样可以共享底层数组和已存在的容量。</p><p>不允许创建长度大于容量的 slice：</p><pre><code>slice := make([]int, 5, 3)Compiler Error:len larger than cap in make([]int)</code></pre><p>惯用的创建 slice 的方法是使用 slice 字面量。跟创建数组很类似，不过不用指定 []里的值。初始的长度和容量依赖于元素的个数：</p><pre><code>// 创建一个字符串 slice// 长度和容量都是 5slice := []string{&quot;Red&quot;, &quot;Blue&quot;, &quot;Green&quot;, &quot;Yellow&quot;, &quot;Pink&quot;}</code></pre><p>在使用 slice 字面量创建 slice 时有一种方法可以初始化长度和容量，那就是初始化索引。下面是个例子：</p><pre><code>// 创建一个字符串 slice// 初始化一个有100个元素的空的字符串 sliceslice := []string{99: &quot;&quot;}nil 和 empty slice</code></pre><p>有的时候我们需要创建一个 nil slice，创建一个 nil slice 的方法是声明它但不初始化它：</p><pre><code>var slice []int</code></pre><p>创建一个 nil slice 是创建 slice 最基本的方法，很多标准库和内建函数都可以使用它。当我们想要表示一个并不存在的 slice 时它变得非常有用，比如一个返回 slice 的函数中发生异常的时候。</p><p>创建 empty slice 的方法就是声明并初始化一下：</p><pre><code>// 使用 make 创建silce := make([]int, 0)// 使用 slice 字面值创建slice := []int{}</code></pre><p>empty slice 包含0个元素并且底层数组没有分配存储空间。当我们想要表示一个空集合时它很有用处，比如一个数据库查询返回0个结果。</p><blockquote><p>不管我们用 nil slice 还是 empty slice，内建函数 append，len和cap的工作方式完全相同。</p></blockquote><h5 id="使用-slice"><a href="#使用-slice" class="headerlink" title="使用 slice"></a>使用 slice</h5><p>为一个指定索引值的 slice 赋值跟之前数组赋值的做法完全相同。改变单个元素的值使用 [] 操作符：</p><pre><code>slice := []int{10, 20, 30, 40, 50}slice[1] = 25</code></pre><p>我们可以在底层数组上对一部分数据进行 slice 操作，来创建一个新的 slice：</p><pre><code>// 长度为5，容量为5slice := []int{10, 20, 30, 40, 50}// 长度为2，容量为4newSlice := slice[1:3]</code></pre><p>在 slice 操作之后我们得到了两个 slice，它们共享底层数组。但是它们能访问底层数组的范围却不同，newSlice 不能访问它头指针前面的值。</p><p>计算任意 new slice 的长度和容量可以使用下面的公式：</p><pre><code>对于 slice[i:j] 和底层容量为 k 的数组长度：j - i容量：k - i</code></pre><p>必须再次明确一下现在是两个 slice 共享底层数组，因此只要有一个 slice 改变了底层数组的值，那么另一个也会随之改变：</p><pre><code>slice := []int{10, 20, 30, 40, 50}newSlice := slice[1:3]newSlice[1] = 35</code></pre><p>改变 newSlice 的第二个元素的值，也会同样改变 slice 的第三个元素的值。</p><p>一个 slice 只能访问它长度范围内的索引，试图访问超出长度范围的索引会产生一个运行时错误。容量只可以用来增长，它只有被合并到长度才可以被访问：</p><pre><code>slice := []int{10, 20, 30, 40, 50}newSlice := slice[1:3]newSlice[3] = 45Runtime Exception:panic: runtime error: index out of range</code></pre><p>容量可以被合并到长度里，通过内建的 append 函数。</p><h5 id="slice-增长"><a href="#slice-增长" class="headerlink" title="slice 增长"></a>slice 增长</h5><p>slice 比 数组的优势就在于它可以按照我们的需要增长，我们只需要使用 append 方法，然后 Go 会为我们做好一切。</p><p>使用 append 方法时我们需要一个源 slice 和需要附加到它里面的值。当 append 方法返回时，它返回一个新的 slice，append 方法总是增长 slice 的长度，另一方面，如果源 slice 的容量足够，那么底层数组不会发生改变，否则会重新分配内存空间。</p><pre><code>// 创建一个长度和容量都为5的 sliceslice := []int{10, 20, 30, 40, 50}// 创建一个新的 slicenewSlice := slice[1:3]// 为新的 slice append 一个值newSlice = append(newSlice, 60)</code></pre><p>因为 newSlice 有可用的容量，所以在 append 操作之后 slice 索引为 3 的值也变成了 60，之前说过这是因为 slice 和 newSlice 共享同样的底层数组。</p><p>如果没有足够可用的容量，append 函数会创建一个新的底层数组，拷贝已存在的值和将要被附加的新值：</p><pre><code>// 创建长度和容量都为4的 sliceslice := []int{10, 20, 30, 40}// 附加一个新值到 slice，因为超出了容量，所以会创建新的底层数组newSlice := append(slice, 50)</code></pre><p>append 函数重新创建底层数组时，容量会是现有元素的两倍(前提是元素个数小于1000)，如果元素个数超过1000，那么容量会以 1.25 倍来增长。</p><h5 id="slice-的第三个索引参数"><a href="#slice-的第三个索引参数" class="headerlink" title="slice 的第三个索引参数"></a>slice 的第三个索引参数</h5><p>slice 还可以有第三个索引参数来限定容量，它的目的不是为了增加容量，而是提供了对底层数组的一个保护机制，以方便我们更好的控制 append 操作，举个栗子：</p><pre><code>source := []string{&quot;apple&quot;, &quot;orange&quot;, &quot;plum&quot;, &quot;banana&quot;, &quot;grape&quot;}// 接着我们在源 slice 之上创建一个新的 sliceslice := source[2:3:4]</code></pre><p>新创建的 slice 长度为 1，容量为 2，可以看出长度和容量的计算公式也很简单：</p><pre><code>对于 slice[i:j:k]  或者 [2:3:4]长度： j - i       或者   3 - 2容量： k - i       或者   4 - 2</code></pre><p>如果我们试图设置比可用容量更大的容量，会得到一个运行时错误：</p><pre><code>slice := source[2:3:6]Runtime Error:panic: runtime error: slice bounds out of range</code></pre><p>限定容量最大的用处是我们在创建新的 slice 时候限定容量与长度相同，这样以后再给新的 slice 增加元素时就会分配新的底层数组，而不会影响原有 slice 的值：</p><pre><code>source := []string{&quot;apple&quot;, &quot;orange&quot;, &quot;plum&quot;, &quot;banana&quot;, &quot;grape&quot;}// 接着我们在源 slice 之上创建一个新的 slice// 并且设置长度和容量相同slice := source[2:3:3]// 添加一个新元素slice = append(slice, &quot;kiwi&quot;)</code></pre><p>如果没有第三个索引参数限定，添加 kiwi 这个元素时就会覆盖掉 banana。</p><p>内建函数 append 是一个变参函数，意思就是你可以一次添加多个元素，比如：</p><pre><code>s1 := []int{1, 2}s2 := []int{3, 4}fmt.Printf(&quot;%v\n&quot;, append(s1, s2...))Output:[1 2 3 4]</code></pre><h5 id="迭代-slice"><a href="#迭代-slice" class="headerlink" title="迭代 slice"></a>迭代 slice</h5><p>slice 也是一种集合，所以可以被迭代，用 for 配合 range 来迭代：</p><pre><code>slice := []int{10, 20, 30, 40, 50}for index, value := range slice {  fmt.Printf(&quot;Index: %d  Value: %d\n&quot;, index, value)}Output:Index: 0  Value: 10Index: 1  Value: 20Index: 2  Value: 30Index: 3  Value: 40Index: 4  Value: 50</code></pre><p>当迭代时 range 关键字会返回两个值，第一个是索引值，第二个是索引位置值的拷贝。注意：返回的是值的拷贝而不是引用，如果我们把值的地址作为指针使用，会得到一个错误，来看看为啥：</p><pre><code>slice := []int{10, 20, 30 ,40}for index, value := range slice {  fmt.Printf(&quot;Value: %d  Value-Addr: %X  ElemAddr: %X\n&quot;, value, &amp;value, &amp;slice[index])}Output:Value: 10  Value-Addr: 10500168  ElemAddr: 1052E100Value: 20  Value-Addr: 10500168  ElemAddr: 1052E104Value: 30  Value-Addr: 10500168  ElemAddr: 1052E108Value: 40  Value-Addr: 10500168  ElemAddr: 1052E10C</code></pre><p>value 变量的地址总是相同的因为它只是包含一个拷贝。如果想得到每个元素的真是地址可以使用 &amp;slice[index]。</p><p>如果不需要索引值，可以使用 _ 操作符来忽略它：</p><pre><code>slice := []int{10, 20, 30, 40}for _, value := range slice {  fmt.Printf(&quot;Value: %d\n&quot;, value)}Output:Value: 10Value: 20Value: 30Value: 40</code></pre><p>range 总是从开始一次遍历，如果你想控制遍历的step，就用传统的 for 循环：</p><pre><code>slice := []int{10, 20, 30, 40}for index := 2; index &lt; len(slice); index++ {  fmt.Printf(&quot;Index: %d  Value: %d\n&quot;, index, slice[index])}Output:Index: 2  Value: 30Index: 3  Value: 40</code></pre><p>同数组一样，另外两个内建函数 len 和 cap 分别返回 slice 的长度和容量。</p><h5 id="多维-slice"><a href="#多维-slice" class="headerlink" title="多维 slice"></a>多维 slice</h5><p>也是同数组一样，slice 可以组合为多维的 slice：</p><pre><code>slice := [][]int{{10}, {20, 30}}</code></pre><p>需要注意的是使用 append 方法时的行为，比如我们现在对 slice[0] 增加一个元素：</p><pre><code>slice := [][]int{{10}, {20, 30}}slice[0] = append(slice[0], 20)</code></pre><p>那么只有 slice[0] 会重新创建底层数组，slice[1] 则不会。</p><h5 id="在函数间传递-slice"><a href="#在函数间传递-slice" class="headerlink" title="在函数间传递 slice"></a>在函数间传递 slice</h5><p>在函数间传递 slice 是很廉价的，因为 slice 相当于是指向底层数组的指针，让我们创建一个很大的 slice 然后传递给函数调用它：</p><pre><code>slice := make([]int, 1e6)slice = foo(slice)func foo(slice []int) []int {    ...    return slice}</code></pre><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h5 id="内部机制-1"><a href="#内部机制-1" class="headerlink" title="内部机制"></a>内部机制</h5><ul><li><p>map 是一种无序的键值对的集合。map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。</p></li><li><p>map 是一种集合，所以我们可以像迭代数组和 slice 那样迭代它。不过，map 是无序的，我们无法决定它的返回顺序，这是因为 map 是使用 hash 表来实现的。</p></li></ul><p>map 的 hash 表包含了一个桶集合(collection of buckets)。当我们存储，移除或者查找键值对(key/value pair)时，都会从选择一个桶开始。在映射(map)操作过程中，我们会把指定的键值(key)传递给 hash 函数(又称散列函数)。hash 函数的作用是生成索引，索引均匀的分布在所有可用的桶上。hash 表算法详见：July的博客—从头到尾彻底解析 hash 表算法</p><h5 id="创建和初始化-1"><a href="#创建和初始化-1" class="headerlink" title="创建和初始化"></a>创建和初始化</h5><p>Go 语言中有多种方法创建和初始化 map。我们可以使用内建函数 make 也可以使用 map 字面值：</p><pre><code>// 通过 make 来创建dict := make(map[string]int)// 通过字面值创建dict := map[string]string{&quot;Red&quot;: &quot;#da1337&quot;, &quot;Orange&quot;: &quot;#e95a22&quot;}</code></pre><p>使用字面值是创建 map 惯用的方法(为什么不使用make)。初始化 map 的长度依赖于键值对的数量。</p><p>map 的键可以是任意内建类型或者是 struct 类型，map 的值可以是使用 ==操作符的表达式。slice，function 和 包含 slice 的 struct 类型不可以作为 map 的键，否则会编译错误：</p><pre><code>dict := map[[]string]int{}Compiler Exception:invalid map key type []string</code></pre><h5 id="使用-map"><a href="#使用-map" class="headerlink" title="使用 map"></a>使用 map</h5><p>给 map 赋值就是指定合法类型的键，然后把值赋给键：</p><pre><code>colors := map[string]string{}colors[&quot;Red&quot;] = &quot;#da1337&quot;</code></pre><p>如果不初始化 map，那么就会创建一个 nil map。nil map 不能用来存放键值对，否则会报运行时错误：</p><pre><code>var colors map[string]stringcolors[&quot;Red&quot;] = &quot;#da1337&quot;Runtime Error:panic: runtime error: assignment to entry in nil map</code></pre><p>测试 map 的键是否存在是 map 操作的重要部分，因为它可以让我们判断是否可以执行一个操作，或者是往 map 里缓存一个值。它也可以被用来比较两个 map 的键值对是否匹配或者缺失。</p><p>从 map 里检索一个值有两种选择，我们可以同时检索值并且判断键是否存在：</p><pre><code>value, exists := colors[&quot;Blue&quot;]if exists {  fmt.Println(value)}</code></pre><p>另一种选择是只返回值，然后判断是否是零值来确定键是否存在。但是只有你确定零值是非法值的时候这招才管用：</p><pre><code>value := colors[&quot;Blue&quot;]if value != &quot;&quot; {  fmt.Println(value)}</code></pre><p>当索引一个 map 取值时它总是会返回一个值，即使键不存在。上面的例子就返回了对应类型的零值。</p><p>迭代一个 map 和迭代数组和 slice 是一样的，使用 range 关键字，不过在迭代 map 时我们不使用 index/value 而使用 key/value 结构：</p><pre><code>colors := map[string]string{    &quot;AliceBlue&quot;:   &quot;#f0f8ff&quot;,    &quot;Coral&quot;:       &quot;#ff7F50&quot;,    &quot;DarkGray&quot;:    &quot;#a9a9a9&quot;,    &quot;ForestGreen&quot;: &quot;#228b22&quot;,}for key, value := range colors {  fmt.Printf(&quot;Key: %s  Value: %s\n&quot;, key, value)}</code></pre><p>如果我们想要从 map 中移除一个键值对，使用内建函数 delete(要是也能返回移除是否成功就好了，哎。。。)：</p><pre><code>delete(colors, &quot;Coral&quot;)for key, value := range colors {  fmt.Println(&quot;Key: %s  Value: %s\n&quot;, key, value)}</code></pre><h5 id="在函数间传递-map"><a href="#在函数间传递-map" class="headerlink" title="在函数间传递 map"></a>在函数间传递 map</h5><p>在函数间传递 map 不是传递 map 的拷贝。所以如果我们在函数中改变了 map，那么所有引用 map 的地方都会改变：</p><pre><code>func main() {  colors := map[string]string{     &quot;AliceBlue&quot;:   &quot;#f0f8ff&quot;,     &quot;Coral&quot;:       &quot;#ff7F50&quot;,     &quot;DarkGray&quot;:    &quot;#a9a9a9&quot;,     &quot;ForestGreen&quot;: &quot;#228b22&quot;,  }  for key, value := range colors {      fmt.Printf(&quot;Key: %s  Value: %s\n&quot;, key, value)  }  removeColor(colors, &quot;Coral&quot;)  for key, value := range colors {      fmt.Printf(&quot;Key: %s  Value: %s\n&quot;, key, value)  }}func removeColor(colors map[string]string, key string) {    delete(colors, key)}</code></pre><p>执行会得到以下结果：</p><pre><code>Key: AliceBlue Value: #F0F8FFKey: Coral Value: #FF7F50Key: DarkGray Value: #A9A9A9Key: ForestGreen Value: #228B22Key: AliceBlue Value: #F0F8FFKey: DarkGray Value: #A9A9A9Key: ForestGreen Value: #228B22</code></pre><p>可以看出来传递 map 也是十分廉价的，类似 slice。</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Go 语言本身是不提供 set 的，但是我们可以自己实现它，下面就来试试：</p><pre><code>package mainimport(  &quot;fmt&quot;  &quot;sync&quot;)type Set struct {  m map[int]bool  sync.RWMutex}func New() *Set {  return &amp;Set{    m: map[int]bool{},  }}func (s *Set) Add(item int) {  s.Lock()  defer s.Unlock()  s.m[item] = true}func (s *Set) Remove(item int) {  s.Lock()  s.Unlock()  delete(s.m, item)}func (s *Set) Has(item int) bool {  s.RLock()  defer s.RUnlock()  _, ok := s.m[item]  return ok}func (s *Set) Len() int {  return len(s.List())}func (s *Set) Clear() {  s.Lock  defer s.Unlock()  s.m = map[int]bool{}}func (s *Set) IsEmpty() bool {  if s.Len() == 0 {    return true  }  return false}func (s *Set) List() []int {  s.RLock()  defer s.RUnlock()  list := []int{}  for item := range s.m {    list = append(list, item)  }  return list}func main() {  // 初始化  s := New()  s.Add(1)  s.Add(1)  s.Add(2)  s.Clear()  if s.IsEmpty() {    fmt.Println(&quot;0 item&quot;)  }  s.Add(1)  s.Add(2)  s.Add(3)  if s.Has(2) {    fmt.Println(&quot;2 does exist&quot;)  }  s.Remove(2)  s.Remove(3)  fmt.Println(&quot;list of all items&quot;, S.List())}</code></pre><ul><li>注意我们只是使用了 int 作为键，你可以自己实现用 interface{} 作为键，做成更通用的 Set，另外，这个实现是线程安全的。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>数组是 slice 和 map 的底层结构。</li><li>slice 是 Go 里面惯用的集合数据的方法，map 则是用来存储键值对。</li><li>内建函数 make 用来创建 slice 和 map，并且为它们指定长度和容量等等。slice 和 map 字面值也可以做同样的事。</li><li>slice 有容量的约束，不过可以通过内建函数 append 来增加元素。</li><li>map 没有容量一说，所以也没有任何增长限制。</li><li>内建函数 len 可以用来获得 slice 和 map 的长度。</li><li>内建函数 cap 只能作用在 slice 上。</li><li>可以通过组合方式来创建多维数组和 slice。map 的值可以是 slice 或者另一个 map。slice 不能作为 map 的键。</li><li>在函数之间传递 slice 和 map 是相当廉价的，因为他们不会传递底层数组的拷贝。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Go语言中和其他语言一样，存在数组，Map(iOS中的字典)，但是还有一个比较特殊的Slice，他其实底层还是数组，今天我们来简单说说Go语言中的Array、Slice、Map和Set&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="https://icocos.github.io/categories/Go/"/>
    
    
      <category term="Go基础" scheme="https://icocos.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Array、Slice、Map、Set" scheme="https://icocos.github.io/tags/Array%E3%80%81Slice%E3%80%81Map%E3%80%81Set/"/>
    
  </entry>
  
  <entry>
    <title>Golang知识图谱</title>
    <link href="https://icocos.github.io/2018/05/10/Golang%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    <id>https://icocos.github.io/2018/05/10/Golang知识图谱/</id>
    <published>2018-05-10T02:49:12.000Z</published>
    <updated>2018-08-06T18:33:42.390Z</updated>
    
    <content type="html"><![CDATA[<p>一张图介绍Golang知识图谱，查漏补缺，还能装逼</p><a id="more"></a><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/golangallstudydata.png" alt="曹理鹏(iCocos)-梦工厂"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一张图介绍Golang知识图谱，查漏补缺，还能装逼&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="https://icocos.github.io/categories/Go/"/>
    
    
      <category term="Go基础" scheme="https://icocos.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Golang知识图谱" scheme="https://icocos.github.io/tags/Golang%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    
  </entry>
  
  <entry>
    <title>Go——基础学习笔记</title>
    <link href="https://icocos.github.io/2018/05/09/Go%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://icocos.github.io/2018/05/09/Go——基础学习笔记/</id>
    <published>2018-05-09T02:07:21.000Z</published>
    <updated>2018-08-06T17:26:22.436Z</updated>
    
    <content type="html"><![CDATA[<p>iOS开发中有一个方向叫，你想工程开发，曾经也试着话时间去研究过相关的技术，熟悉使用那些相关的工具，但是毕竟没有专门实战过项目，也就只能简单的入门一下。而随着iOS开发年限的增长，和所了解到的东西，发现有不少公司或者朋友都在关注安全这一块，虽然Apple已经把安全做得很到位了，但是还是有这一块的问题存在，所以我根据个人的能力并结合网上的相关资料，简单的整理了一下，不管是作为了解，还是项目实战，或者为了面试，我都希望能有所帮助……</p><a id="more"></a><blockquote><p>07年由RRK三人主持开发，09年11月开源，12年1.0稳定版</p></blockquote><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul><li>语言简单</li><li>实用，有效，高效</li><li>静态类型</li><li>编译型</li><li>开源</li><li>脚本化语法</li><li>函数式</li><li>面向对象</li><li>原始并发</li><li>协程（并发编程的管道）</li><li>垃圾回收</li><li>类型安全</li><li>内存安全</li><li>UTF8编码</li><li>移除或异常无用包</li><li>内置高性能http server</li><li>完善简便的各种库(package)</li><li>调用C很简便</li><li>跨平台</li><li>作者之一是c的作者</li></ul><h5 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h5><ul><li>脚本化</li><li>静态+编译-&gt;速度(相比：动态+解释)</li><li>并发(运行时系统调度和算法)</li></ul><h5 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h5><ul><li>语法糖少</li><li>速度不及C</li><li>第三方库较少</li></ul><h5 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h5><ul><li>GOROOT：Go语言的当前安装目录</li><li>GOPATH：Go语言工作区的结合（工作目录）</li><li>GOBIN：可执行文件目录</li><li>PATH：Go语言本身目录和Go程序生成可执行文件命令</li></ul><blockquote><p>(~/.bash_profile(单一用户),/etc/profile(全局用户)</p></blockquote><ul><li>相关目录$GOOS_$GOARCH： GOOS-操作系统，GOARCH-计算架构</li></ul><h5 id="工作区"><a href="#工作区" class="headerlink" title="工作区"></a>工作区</h5><ul><li>src：源码文件（代码包）</li><li>pkg：存放归档文件（代码包，库）</li><li>bin：Go程序可执行文件</li></ul><h5 id="源码文件"><a href="#源码文件" class="headerlink" title="源码文件"></a>源码文件</h5><ul><li>命令源码文件（功能）：Go语言入口，声明自己属于main代码包，包含无参数声明和结果声明的main函数</li><li>库源码文件（功能）：不具备命令源码文件的两个特征</li><li>测试源码文件（辅助）：同上，但是名称为：_test.go后缀</li></ul><blockquote><p>测试函数（至少一个）：Test(功能)或Benchmark(基准或性能)前缀，参数<em>testing.T或</em>testing.B</p></blockquote><h5 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h5><ul><li>go run： 编译-临时-运行-可执行，归档文件<ul><li>a：强制编译，不管是不是最新</li><li>n：打印编译需要的命令，不执行</li><li>p n：并行编译，n为并行数</li><li>a：列出被编译代码包名称（-a -v：所有涉及）</li><li>work：临时工作目录路径，且不删除</li><li>x：打印编译需要的命令，执行</li></ul></li><li>go build：编译代码包（库：不产生结果文件，只检查有效性。命令：生成可执行文件，结果文件）<ul><li>a：加入-编译所有涉及，不加入-只编译最新的</li></ul></li><li>go install：编译并安装代码包或源码文件</li><li>go get：从远程代码仓库下载并安装代码包（git，Mercurial，svn，Bazaar）<ul><li>d：只下载不安装</li><li>fix：下载后，先执行修正动作，在安装</li><li>u：更新代码包</li></ul></li></ul><blockquote><p>ds(显示指定目录的目录结构)/pds命令(显示指定代码包的以来关系)</p></blockquote><h5 id="DOC"><a href="#DOC" class="headerlink" title="DOC"></a>DOC</h5><ul><li>godoc -http=:8800</li></ul><h5 id="基础总结"><a href="#基础总结" class="headerlink" title="基础总结"></a>基础总结</h5><ul><li>只有package为main的包可以包含main函数</li><li>一个可执行文件有且仅有一个main函数</li><li>import导入非main包</li><li>函数外包使用var申明和赋值全局变量</li><li>type进行结构体和接口的声明</li></ul><h4 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h4><pre><code>// 当前程序的包名（package：非注释的第一行）package main// 导入其他包import &quot;fmt&quot; // 格式import . &quot;os&quot; // 省略import io &quot;io&quot; // 别名import _ &quot;time&quot; // 忽略import (    &quot;strings&quot; )// 常量定义const PI = 3.14// 全局变量声明与赋值var name = &quot;iCocos&quot;// 一般类型的声明type newtype int// 结构体的声明type gostruct = struct{}// 接口的声明type gointerface interface{} // 以上三种都可以使用组 type (    byte int8    rune int 32    文本 string )// 由main函数作为程序入口和启动func main() {    Printf(&quot;Hello World!&quot;)}</code></pre><h5 id="可见性规则"><a href="#可见性规则" class="headerlink" title="可见性规则"></a>可见性规则</h5><p>常量，变量，类型，接口，结构体，函数</p><ul><li>大小写区分：<ul><li>小写为private</li><li>大写为public</li></ul></li></ul><hr><ul><li>陆续更新<ul><li>01基础学习笔记</li><li>02Go语法初识</li><li>03类型与变量</li><li>04常量与运算符</li><li>05控制语句</li><li>06数组array</li><li>07切片slice</li><li>08map</li><li>09函数function</li><li>10结构struct</li><li>11方法method</li><li>12接口interface</li><li>13反射reflection</li><li>14并发concurrency</li><li>15项目与坑</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS开发中有一个方向叫，你想工程开发，曾经也试着话时间去研究过相关的技术，熟悉使用那些相关的工具，但是毕竟没有专门实战过项目，也就只能简单的入门一下。而随着iOS开发年限的增长，和所了解到的东西，发现有不少公司或者朋友都在关注安全这一块，虽然Apple已经把安全做得很到位了，但是还是有这一块的问题存在，所以我根据个人的能力并结合网上的相关资料，简单的整理了一下，不管是作为了解，还是项目实战，或者为了面试，我都希望能有所帮助……&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="https://icocos.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="https://icocos.github.io/tags/Go/"/>
    
      <category term="基础学习笔记" scheme="https://icocos.github.io/tags/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>服务器配置——实战验证与补充</title>
    <link href="https://icocos.github.io/2018/05/05/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94%E5%AE%9E%E6%88%98%E9%AA%8C%E8%AF%81%E4%B8%8E%E8%A1%A5%E5%85%85/"/>
    <id>https://icocos.github.io/2018/05/05/服务器配置——实战验证与补充/</id>
    <published>2018-05-05T10:07:54.000Z</published>
    <updated>2018-08-06T17:26:24.394Z</updated>
    
    <content type="html"><![CDATA[<p> 下面关于之前一些流程（Ngnix，Php，Go，Mysql）安装配置与使用的一些总结，和遇到的一个坑，其中也有关于服务器配置与部署，代码上传与发布相关内容，主要是为了熟悉整个流程……</p><a id="more"></a><blockquote><p>这里补充一下前面没有提到，但是实际操作会用到或者能提升效率的东西</p></blockquote><h2 id="安装ftp"><a href="#安装ftp" class="headerlink" title="安装ftp"></a>安装ftp</h2><p>大家看到了，所有的文件操作在ssh中可以通过vim方法来实现，但是，你知道在windows中用惯了，还是喜欢看图形界面，所以在这里我安装了ftp可以远程来上传修改文件</p><pre><code>软件：winscp（百度下载就好了）</code></pre><h3 id="安装vsftpd"><a href="#安装vsftpd" class="headerlink" title="安装vsftpd"></a>安装vsftpd</h3><pre><code>yum install vsftpd</code></pre><h3 id="启动-重启-关闭vsftpd服务器"><a href="#启动-重启-关闭vsftpd服务器" class="headerlink" title="启动/重启/关闭vsftpd服务器"></a>启动/重启/关闭vsftpd服务器</h3><pre><code>[root@localhost ftp]# /sbin/service vsftpd restartShutting down vsftpd: [ OK ]Starting vsftpd for vsftpd: [ OK ] </code></pre><p>OK表示重启成功了.</p><p>这里现在就可以直接使用root及你的密码来查看了，当然这样的是超级用户，留给自己用的，要配置指定要文件夹的用户，我就在不在这里写了，大家继续百度下吧</p><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><pre><code>sudo apt-get updatesudo apt-get install git</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 下面关于之前一些流程（Ngnix，Php，Go，Mysql）安装配置与使用的一些总结，和遇到的一个坑，其中也有关于服务器配置与部署，代码上传与发布相关内容，主要是为了熟悉整个流程……&lt;/p&gt;
    
    </summary>
    
      <category term="Server" scheme="https://icocos.github.io/categories/Server/"/>
    
    
      <category term="Server" scheme="https://icocos.github.io/tags/Server/"/>
    
      <category term="实战验证与补充" scheme="https://icocos.github.io/tags/%E5%AE%9E%E6%88%98%E9%AA%8C%E8%AF%81%E4%B8%8E%E8%A1%A5%E5%85%85/"/>
    
  </entry>
  
  <entry>
    <title>服务器配置——Go安装与配置</title>
    <link href="https://icocos.github.io/2018/05/04/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94Go%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <id>https://icocos.github.io/2018/05/04/服务器配置——Go安装与配置/</id>
    <published>2018-05-04T10:06:17.000Z</published>
    <updated>2018-08-06T18:33:42.386Z</updated>
    
    <content type="html"><![CDATA[<p> 这里应该说是我此次的最初目的，当然后面接触了不少服务器配置与部署后，我发现重点不是学习Go，而且这整个过程中学到的一切，好了，其实我突然重新开始整服务器和博客，是因为想要开始好好，认认真真的学习一下Go，并将其应用到实战中……</p><a id="more"></a><h2 id="go下载安装后上传到服务器"><a href="#go下载安装后上传到服务器" class="headerlink" title="go下载安装后上传到服务器"></a>go下载安装后上传到服务器</h2><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/servers/go000.jpeg" alt="HYMBA"></p><p>这里之前是可以直接使用wget安装的，但是大部分的wget地址所下载的gz包都无法解压</p><pre><code>#解压tar -zxvf go1.8.4.linux-amd64.tar.gz</code></pre><p>所以一般都是选择官网的</p><h2 id="HOME-下面创建了一个-export-文件"><a href="#HOME-下面创建了一个-export-文件" class="headerlink" title="$HOME 下面创建了一个 .export 文件"></a>$HOME 下面创建了一个 .export 文件</h2><p>写的 这些环境变量</p><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/servers/go001.jpeg" alt="HYMBA"></p><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/servers/go002.jpeg" alt="HYMBA"></p><p>要想立即生效的话 要么退出从新连接 要么执行下 source ~/.bashrc</p><h4 id="执行-go-env"><a href="#执行-go-env" class="headerlink" title="执行 go env"></a>执行 go env</h4><blockquote><p>看看 GOPATH GOROOT GOBIN 是不是自己设置的</p></blockquote><h2 id="在-HOME-GoWorkSpec-创建了这文件目录-下面有"><a href="#在-HOME-GoWorkSpec-创建了这文件目录-下面有" class="headerlink" title="在 $HOME/GoWorkSpec 创建了这文件目录 下面有"></a>在 $HOME/GoWorkSpec 创建了这文件目录 下面有</h2><ul><li>bin </li><li>pkg </li><li>src </li></ul><p>三个子目录  src 放源码</p><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/servers/go003.jpeg" alt="HYMBA"></p><h2 id="go-http-server"><a href="#go-http-server" class="headerlink" title="go http server"></a>go http server</h2><p>如果你配置好了所有需要的服务与配置，并且对Go语言已经足够熟悉了，那么你一定会想用Go语言来干点撒。</p><p>没错，就是我们一开始的目的，实现服务器开发，和Php一样接收前端或者移动端的请求，进行数据的处理与返回</p><blockquote><p>但是由于时间原因，而且关于go http server目前还有点早，后面会用专门的文章来说明具体的配置与实战。</p></blockquote><p>感兴趣的可以看看下面的文章：</p><ul><li><a href="https://blog.csdn.net/chenxun_2010/article/details/73862810" target="_blank" rel="noopener">https://blog.csdn.net/chenxun_2010/article/details/73862810</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 这里应该说是我此次的最初目的，当然后面接触了不少服务器配置与部署后，我发现重点不是学习Go，而且这整个过程中学到的一切，好了，其实我突然重新开始整服务器和博客，是因为想要开始好好，认认真真的学习一下Go，并将其应用到实战中……&lt;/p&gt;
    
    </summary>
    
      <category term="Server" scheme="https://icocos.github.io/categories/Server/"/>
    
    
      <category term="Server" scheme="https://icocos.github.io/tags/Server/"/>
    
      <category term="Go安装与配置" scheme="https://icocos.github.io/tags/Go%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>服务器配置——MySql安装与配置</title>
    <link href="https://icocos.github.io/2018/05/04/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94MySql%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <id>https://icocos.github.io/2018/05/04/服务器配置——MySql安装与配置/</id>
    <published>2018-05-04T10:05:26.000Z</published>
    <updated>2018-08-06T17:26:22.858Z</updated>
    
    <content type="html"><![CDATA[<p>服务器好了之后，首先我们应该从数据库入手，因为一切没有数据交互与存储的服务器和客户端都只是娱乐，这里我们选择大部分人都熟知而且与PHP成为天和之作的Mysql，当然他和Go也一样兼容……</p><a id="more"></a><h2 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h2><p>mysql 可以管理网站用到的数据库，WordPress 和 Drupal 也都支持 mysql 数据库。所以我们的 Web 运行环境里，需要安装一个 mysql 。之前我们已经添加了资源库，所以可以直接使用 yum 命令去安装  mysql ：</p><pre><code>yum install mysql-server</code></pre><p>安装完成后，使用 service 命令启动 mysql 服务：</p><pre><code>service mysqld start</code></pre><p>然后我们需要简单配置一下 mysql ，默认安装以后 mysql 的 root 用户是没有密码的，对于生产环境来说，这肯定是不行的.</p><p>另外还有一些安全相关的设置，可以使用下面这行命令去配置一下，它是一个向导，问你一些问题，你要给出答案，比如是否要设置 root 用户的密码， 密码是什么等等。</p><pre><code>mysql_secure_installation</code></pre><p>然后根据实际情况进行配置，也可以看看下面比较常用的配置方案</p><pre><code>Enter current password for root (enter for none):解释：输入当前 root 用户密码，默认为空，直接回车。Set root password? [Y/n]  y解释：要设置 root 密码吗？输入 y 表示愿意。Remove anonymous users? [Y/n]  y解释：要移除掉匿名用户吗？输入 y 表示愿意。Disallow root login remotely? [Y/n]  n解释：不想让 root 远程登陆吗？输入 y 表示愿意。Remove test database and access to it? [Y/n]  y解释：要去掉 test 数据库吗？输入 y 表示愿意。Reload privilege tables now? [Y/n]  y解释：想要重新加载权限吗？输入 y 表示愿意。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;服务器好了之后，首先我们应该从数据库入手，因为一切没有数据交互与存储的服务器和客户端都只是娱乐，这里我们选择大部分人都熟知而且与PHP成为天和之作的Mysql，当然他和Go也一样兼容……&lt;/p&gt;
    
    </summary>
    
      <category term="Server" scheme="https://icocos.github.io/categories/Server/"/>
    
    
      <category term="Server" scheme="https://icocos.github.io/tags/Server/"/>
    
      <category term="MySql安装与配置" scheme="https://icocos.github.io/tags/MySql%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>服务器配置——Php安装与配置</title>
    <link href="https://icocos.github.io/2018/05/03/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94Php%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <id>https://icocos.github.io/2018/05/03/服务器配置——Php安装与配置/</id>
    <published>2018-05-03T10:06:09.000Z</published>
    <updated>2018-08-06T17:26:22.357Z</updated>
    
    <content type="html"><![CDATA[<p> 由于之前学过一段时间的Php，偶尔看到一个不错的东西也会尝试一下，虽然可能最终结果和意义并不大，但是此次我还是觉决定让服务器支持Php，同时也会适当的更新一些Php的内容（能力有限，都是比较基础的内容）……</p> <a id="more"></a><blockquote><p>说了服务器第一步Ngnix安装与配置之后，就要开始说说关于PHP和Go的安装与配置</p></blockquote><h2 id="配置php-fpm部分"><a href="#配置php-fpm部分" class="headerlink" title="配置php-fpm部分"></a>配置php-fpm部分</h2><p>要让 nginx 能够执行 php 文件，需要去安装一下 php-fpm，它直接包含在了 CentOS 资源库里，所以直接使用 yum 命令可以安装它：</p><pre><code>yum install php-fpm</code></pre><p>完成以后，可以检查一下 php-fpm 的运行状态，使用 service 命令：</p><pre><code>service php-fpm status</code></pre><p>返回：</p><pre><code>php-fpm is stopped（php-fpm 已停止）</code></pre><p>启动 php-fpm 同样可以使用 service 命令：</p><pre><code>service php-fpm start</code></pre><h2 id="让-nginx-可以执行-php"><a href="#让-nginx-可以执行-php" class="headerlink" title="让 nginx 可以执行 php"></a>让 nginx 可以执行 php</h2><p>现在我们应该就可以让 nginx 去执行 php 了。不过你需要修改一下 nginx 的配置文件，之前我们在配置虚拟主机的时候，创建了一个 nginx.ninghao.net.conf 的配置文件，需要去修改下 nginx 的这个配置文件，才能去执行 php 。使用 vim 命令去编辑它：</p><pre><code>vim /etc/nginx/conf.d/nginx.ninghao.net.conf</code></pre><p>注意你的配置文件不一定叫 nginx.ninghao.net.conf，应该是你自己命名的配置文件。打开以后，找到下面这段字样的代码：</p><pre><code># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000##location ~ \.php$ {#    root           html;#    fastcgi_pass   127.0.0.1:9000;#    fastcgi_index  index.php;#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;#    include        fastcgi_params;#}</code></pre><p>这是 nginx 默认给我们的用来执行 php 的配置，从 location 开始取消注释，会让这个配置生效，然后我们还得简单去修改一下：</p><pre><code># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000#location ~ \.php$ {#   root           html;    fastcgi_pass   127.0.0.1:9000;    fastcgi_index  index.php;    fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;    include        fastcgi_params;}</code></pre><p>注意 root 那里仍然是被注释掉的，还有 SCRIPT_FILENAME 后面修改了一下，把 /scripts 换成了 $document_root 。保存并退出。然后重新启动 nginx：</p><pre><code>service nginx restart</code></pre><h2 id="测试是否可以执行-php"><a href="#测试是否可以执行-php" class="headerlink" title="测试是否可以执行 php"></a>测试是否可以执行 php</h2><p>现在，我们已经安装了 php-fpm，并修改了 nginx 的配置文件让它可以去执行 php，下面，我们得去测试一下，可以使用 php 的 phpinfo(); 函数，方法是在你的虚拟主机根目录下面，创建一个 php 文件，命名为 phpinfo.php，然后在这个文件里输入：</p><pre><code>&lt;?php phpinfo(); ?&gt;</code></pre><p>保存文件并退出。在浏览器里打开刚才创建的这个 php 文件。我这里应该是 <code>http://nginx.ninghao.net/phpinfo.php</code>。打开以后，你应该能看到像下面这样的界面，如果能，说明 nginx 已经可以执行 php 了。</p><h2 id="配置扩展"><a href="#配置扩展" class="headerlink" title="配置扩展"></a>配置扩展</h2><blockquote><p>现在，我们有了可以提供 web 服务的 nginx ，并且安装了 php-fpm ，配置了 nginx 可以让它去执行 php ，也安装了数据库管理系统。</p></blockquote><p>不过在运行真正的网站的时候，我们还需要为 php 安装一些额外的扩展，比如 处理 mysql 数据库的 mysql 扩展，缓存功能的 apc 扩展，处理图像的 gd 扩展等等。安装它们同样可以使用 yum 命令。</p><pre><code>yum install php-pecl-apc php-mysql php-gd php-mcrypt php-pear php-mbstring php-xmlrpc php-dom</code></pre><p>上面安装了一些 php 的扩展，如果你发现在安装网站的时候提示需要安装其它的扩展，同样可以使用 yum 命令去安装。安装完成以后，需要重启一下 php-fpm ：</p><pre><code>service php-fpm restart</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 由于之前学过一段时间的Php，偶尔看到一个不错的东西也会尝试一下，虽然可能最终结果和意义并不大，但是此次我还是觉决定让服务器支持Php，同时也会适当的更新一些Php的内容（能力有限，都是比较基础的内容）……&lt;/p&gt;
    
    </summary>
    
      <category term="Server" scheme="https://icocos.github.io/categories/Server/"/>
    
    
      <category term="Server" scheme="https://icocos.github.io/tags/Server/"/>
    
      <category term="Php安装与配置" scheme="https://icocos.github.io/tags/Php%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>服务器配置——Nginx安装与配置</title>
    <link href="https://icocos.github.io/2018/05/03/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94Nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <id>https://icocos.github.io/2018/05/03/服务器配置——Nginx安装与配置/</id>
    <published>2018-05-03T10:04:52.000Z</published>
    <updated>2018-08-06T18:33:42.317Z</updated>
    
    <content type="html"><![CDATA[<p> 配置完阿里控制台之后，首先我们开始配置服务器，我的服务器各种配置都需要自己重新配，这里我现在Ngnix，不要问我为什么选择他，可能是之前用过Apache，对他印象不好吧……</p> <a id="more"></a><p>前面说了关于阿里云主机操作，这里打算开始一步一步搭建和配置服务器，并且开始Go语言和后台学习，并且徐后续更新，直到后面的后台实战开发</p><blockquote><p>关于域名解析，实例，和安全组相关请自行参考阿里官方教程</p></blockquote><h2 id="如何连接服务器执行环境配置"><a href="#如何连接服务器执行环境配置" class="headerlink" title="如何连接服务器执行环境配置"></a>如何连接服务器执行环境配置</h2><blockquote><p>我使用的是centos6.8 64位版本，如果您不是第一次接触linux那一定知道，linux不是一个可视化界面的系统，所以要摒弃windows的操作习惯，我使用的xshell这个软件链接的服务器，连接语句是 ssh root@ip地址</p></blockquote><p>地址处就是写入你的ip地址，然后回车鞋面就会自动连接，弹框提示输入密码</p><ul><li>输入服务器的密码，点击确定即链接上了</li></ul><p>ok，下面就可以开始配置环境了，第一步我们先配置nginx</p><h2 id="nginx安装部分"><a href="#nginx安装部分" class="headerlink" title="nginx安装部分"></a>nginx安装部分</h2><p>想在 CentOS 系统上安装 Nginx ，你得先去添加一个资源库，像这样：</p><pre><code>vim /etc/yum.repos.d/nginx.repo</code></pre><p>使用 vim 命令去打开 <code>/etc/yum.repos.d/nginx.repo</code> ，如果 nginx.repo 不存在，就会去创建一个这样的文件，打开以后按一下小 i 键，进入编辑模式，然后复制粘贴下面这几行代码，完成以后按 esc 键退出，再输入 :wq （保存并退出）</p><pre><code>[nginx]name=nginx repobaseurl=http://nginx.org/packages/centos/$releasever/$basearch/gpgcheck=0enabled=1</code></pre><p>完成以后，我们就可以使用 yum 命令去安装 nginx 了，像这样：</p><pre><code>yum install nginx</code></pre><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/servers/ngnix0001.png" alt="HYMBA"></p><p>安装好以后测试一下 nginx 服务：</p><pre><code>service nginx status</code></pre><p>应该会返回：</p><pre><code>nginx is stopped （nginx 已停止）</code></pre><p>再测试一下 nginx 的配置文件：</p><pre><code>nginx -t</code></pre><p>应该会返回：</p><pre><code>nginx: the configuration file /etc/nginx/nginx.conf syntax is oknginx: configuration file /etc/nginx/nginx.conf test is successful</code></pre><p>… syntax is ok，… test is successful，说明配置文件没问题，同时这个结果里你可以找到 nginx 的配置文件 nginx.conf 所在的位置。</p><h2 id="操纵-nginx-服务"><a href="#操纵-nginx-服务" class="headerlink" title="操纵 nginx 服务"></a>操纵 nginx 服务</h2><p>操纵服务，可以使用使用 service 命令，它可以启动（start），重启（restart），或停止服务（stop），比如要启动 nginx 服务：</p><pre><code>service nginx start</code></pre><p>服务启动以后，你就可以在浏览器上使用服务器的 IP 地址，或者指向这个地址的域名访问服务器指定的目录了。你会看到类似下面的这些文字。</p><pre><code>Welcome to nginx! If you see this page, the nginx web server is successfully installed and working. Further configuration is required. For online documentation and support please refer to nginx.org. Commercial support is available at nginx.com. Thank you for using nginx.</code></pre><h2 id="nginx配置部分"><a href="#nginx配置部分" class="headerlink" title="nginx配置部分"></a>nginx配置部分</h2><p>下面来看一下为 nginx 配置虚拟主机。先进入到 nginx 配置文件目录：</p><pre><code>cd /etc/nginx/conf.d</code></pre><p>复制这个目录里的 default.conf ，复制以后的名字可以使用你的虚拟主机名字。比如创建一个 nginx.ninghao.net 的虚拟主机。复制文件可以使用 cp 命令，像这样：</p><pre><code>cp default.conf nginx.ninghao.net.conf</code></pre><p>再去编辑一下这个复制以后的配置文件，可以使用 vim 命令：</p><pre><code>vim nginx.ninghao.net.conf</code></pre><p>你会看到像这样的代码：</p><pre><code>server { listen 80; server_name localhost; #charset koi8-r; #access_log   /var/log/nginx/log/host.access.log main; location / { root /usr/share/nginx/html; index index.html index.htm;}...}</code></pre><blockquote><p>server_name 就是主机名，也就是跟这个虚拟主机绑定在一块儿的域名，我事先把 nginx.ninghao.net 指向了服务器，这个虚拟主机就是为它准备的，所以，server_name 后面的东西就是 nginx.ninghao.net 。</p><p>紧接着 server_name 下面可以是一个root，就是这个虚拟主机的根目录，也就是网站所在的目录。比如我们要把 nginx.ninghao.net 这个网站的文件放在/home/www/nginx.ninghao.net 下面，那么这个 root 就是这个路径。</p></blockquote><p>然后去掉 location / 里面的 root 这行代码。再在 index 后面加上一种索引文件名，也就是默认打开的文件，这里要加上一个 index.php ，这样访问 nginx.ninghao.net 就可以直接打开 root 目录下面的 index.php 了。稍后我们再去安装 php 。修改之后，看起来像这样：</p><pre><code>server { listen 80; server_name nginx.ninghao.net; root /home/www/nginx.ninghao.net; #charset koi8-r; #access_log /var/log/nginx/log/host.access.log main; location / { index index.php index.html index.htm; }...}</code></pre><p>这个配置文件先修改到这，稍后，我们再回来继续修改一下它。保存一下，按 esc ，输入 :wp（保存并退出）。现在虚拟主机应该就可以使用了。主机的域名是 nginx.ninghao.net，访问它的时候，打开的是 /home/www/nginx.ninghao.net 这个目录里面的东西，你可以在这个目录下放点东西。</p><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/servers/ngnix0003.png" alt="HYMBA"></p><p>重启 nginx 或者重新加载 nginx 可以让配置文件生效。</p><pre><code>service nginx reload</code></pre><p>现在，打开浏览器，输入你为虚拟主机设置的域名，看看是否能打开你指定的目录里的东西。</p><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/servers/ngnix0002.png" alt="HYMBA"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 配置完阿里控制台之后，首先我们开始配置服务器，我的服务器各种配置都需要自己重新配，这里我现在Ngnix，不要问我为什么选择他，可能是之前用过Apache，对他印象不好吧……&lt;/p&gt;
    
    </summary>
    
      <category term="Server" scheme="https://icocos.github.io/categories/Server/"/>
    
    
      <category term="Server" scheme="https://icocos.github.io/tags/Server/"/>
    
      <category term="Nginx安装与配置" scheme="https://icocos.github.io/tags/Nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>服务器配置——阿里云主机配置与操作</title>
    <link href="https://icocos.github.io/2018/05/01/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94%E9%98%BF%E9%87%8C%E4%BA%91%E4%B8%BB%E6%9C%BA/"/>
    <id>https://icocos.github.io/2018/05/01/服务器配置——阿里云主机/</id>
    <published>2018-05-01T10:00:54.000Z</published>
    <updated>2018-08-06T17:26:24.290Z</updated>
    
    <content type="html"><![CDATA[<p> 去年中旬在阿里买了一个属于自己的个性域名(笔者英文)：<a href="http://www.icocos.cn，虽然是CN，但是这都不是重点，重点是为了更全面的接触后台，更好的学习与实战后台开发与PHP，前天又在阿里买了个主机，打算开发玩弄一番，毕竟第一次，期间可能会遇到不少坑和不对的地方，望谅解与指出一起交流，谢谢....." target="_blank" rel="noopener">www.icocos.cn，虽然是CN，但是这都不是重点，重点是为了更全面的接触后台，更好的学习与实战后台开发与PHP，前天又在阿里买了个主机，打算开发玩弄一番，毕竟第一次，期间可能会遇到不少坑和不对的地方，望谅解与指出一起交流，谢谢.....</a>.</p><a id="more"></a><h2 id="阿里云（先声明我不是来给阿里大广告的，😂😂😂😂😂😂）"><a href="#阿里云（先声明我不是来给阿里大广告的，😂😂😂😂😂😂）" class="headerlink" title="阿里云（先声明我不是来给阿里大广告的，😂😂😂😂😂😂）"></a>阿里云（先声明我不是来给阿里大广告的，😂😂😂😂😂😂）</h2><ol><li>阿里云主机</li><li>域名：<a href="http://www.icocos.cn" target="_blank" rel="noopener">www.icocos.cn</a></li></ol><p>这里关于阿里云主机和域名的购买很简单，准备钱，一路点下去就可以了,具体操作强查看阿里文档……</p><h2 id="备案"><a href="#备案" class="headerlink" title="备案"></a>备案</h2><p>关于备案确实是不少人蛋疼的事情，说麻烦也没有多麻烦，说不麻烦但是搞起来又不是点几下就可以的，所以也有不少人选择了不需要备案的或者国外的主机，我当时也有这种想法，但是后来放弃了，投资嘛，自己都不舍得投资还怎么学东西，怎么提升呢！</p><pre><code>本案分个人备案和企业备案，具体详情阿里也有教程，或者网上也有相关教程</code></pre><h2 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h2><p>在链接之前可能需要做一些配置，但是有些事必须的有些可以后面备案成功之后再做，我就是第一次弄所以一直不懂，以为需要备案以后才能操作的。</p><h3 id="添加安全组织，允许22端口访问"><a href="#添加安全组织，允许22端口访问" class="headerlink" title="添加安全组织，允许22端口访问"></a>添加安全组织，允许22端口访问</h3><p>这里其实就是进入阿里控制台的云服务ECS，找到安全组，添加安全组，配置规则就可以.</p><p>这里只要注意</p><pre><code>端口:22/22授权对象：0.0.0.0/0</code></pre><p>初步的这样就可以了，我是为了方便链接访问</p><blockquote><p>然后就可以链接了</p></blockquote><h2 id="连接，并操作"><a href="#连接，并操作" class="headerlink" title="连接，并操作"></a>连接，并操作</h2><p>连接的话当然首选ssh，不要问我为什么，我也不知道，大家都用它，哈哈！</p><h3 id="关于SSH"><a href="#关于SSH" class="headerlink" title="关于SSH"></a>关于SSH</h3><p>SSH是每一台Linux电脑的标准配置。</p><pre><code>简单说，SSH是一种网络协议，用于计算机之间的加密登录。如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。</code></pre><h3 id="最基本的用法"><a href="#最基本的用法" class="headerlink" title="最基本的用法"></a>最基本的用法</h3><p>SSH主要用于远程登录。假定你要以用户名user，登录远程主机host，只要一条简单命令就可以了。</p><p>　　$ ssh user@host</p><p>如果本地用户名与远程用户名一致，登录时可以省略用户名。</p><p>　　$ ssh host</p><p>SSH的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口。</p><p>　　$ ssh -p 2222 user@host</p><p>上面这条命令表示，ssh直接连接远程主机的2222端口。</p><h3 id="这里我使用的是SSH-shell这个工具，Windows用什么不知道，网上应该一大堆"><a href="#这里我使用的是SSH-shell这个工具，Windows用什么不知道，网上应该一大堆" class="headerlink" title="这里我使用的是SSH shell这个工具，Windows用什么不知道，网上应该一大堆"></a>这里我使用的是SSH shell这个工具，Windows用什么不知道，网上应该一大堆</h3><p>命令行步骤</p><pre><code>输入 ssh root@ip地址输入yes输入密码</code></pre><p>就可以看到显示</p><pre><code>[root@iZwz92qgus0ln1nx5dftjd2rZ ~]#</code></pre><p>SSH工具使用也很简单，进后点击Add Server输入ip，端口是默认22，输入root用户名，输入后台配置的密码，对了这里的密码是需要在控制台配置的</p><p>一切顺利的话可以看到一个和terminal一样的终端界面，并且已经连接成功的显示</p><pre><code>[root@iZwz92qgus0ln1nx5dftjd2rZ ~]#</code></pre><p>然后就可以使用命令操作主机文件了。</p><h2 id="密码登录：Mac-客户端"><a href="#密码登录：Mac-客户端" class="headerlink" title="密码登录：Mac 客户端"></a>密码登录：Mac 客户端</h2><h3 id="进入-ssh-文件夹，如果没有就创建一个-ssh文件夹"><a href="#进入-ssh-文件夹，如果没有就创建一个-ssh文件夹" class="headerlink" title="进入.ssh 文件夹，如果没有就创建一个.ssh文件夹"></a>进入.ssh 文件夹，如果没有就创建一个.ssh文件夹</h3><pre><code>mkdir ~/.sshcd ~/.ssh/</code></pre><h3 id="生成rsa秘钥：这个相信大部分人都弄过，github就需要"><a href="#生成rsa秘钥：这个相信大部分人都弄过，github就需要" class="headerlink" title="生成rsa秘钥：这个相信大部分人都弄过，github就需要"></a>生成rsa秘钥：这个相信大部分人都弄过，github就需要</h3><pre><code>ssh-keygen -t rsa</code></pre><h3 id="在该文件夹下就会产生三个文件夹：id-rsa-id-rsa-pub-know-hosts。"><a href="#在该文件夹下就会产生三个文件夹：id-rsa-id-rsa-pub-know-hosts。" class="headerlink" title="在该文件夹下就会产生三个文件夹：id_rsa,id_rsa.pub,know_hosts。"></a>在该文件夹下就会产生三个文件夹：id_rsa,id_rsa.pub,know_hosts。</h3><pre><code>id_rsa：存储私钥，记得只能自己看哦。别人那到这个文件就完蛋蛋咯。id_rsa.pub:存储公钥，用来通信加密使用，有了这个人家才能确定这是你。</code></pre><h3 id="公钥拷贝到云主机"><a href="#公钥拷贝到云主机" class="headerlink" title="公钥拷贝到云主机"></a>公钥拷贝到云主机</h3><pre><code>scp id_rsa.pub  root@78.129.23.45:/root/.ssh/id_rsa.pub</code></pre><h3 id="Note-云主机上没有-ssh-文件时，你要自己建立一个。"><a href="#Note-云主机上没有-ssh-文件时，你要自己建立一个。" class="headerlink" title="Note:云主机上没有.ssh/文件时，你要自己建立一个。"></a>Note:云主机上没有.ssh/文件时，你要自己建立一个。</h3><p>终端连接后输入ls只能看到default.pass文件，ls -a发现也是没有.ssh文件夹的，所以需要输入下面命令创建.ssh文件夹</p><pre><code>mkdir .ssh #回车没有提示就成功再次ls -a就可以看到一个蓝色的隐藏文件夹</code></pre><h2 id="登录到云主机"><a href="#登录到云主机" class="headerlink" title="登录到云主机"></a>登录到云主机</h2><h3 id="进入-ssh-文件夹"><a href="#进入-ssh-文件夹" class="headerlink" title="进入.ssh/文件夹"></a>进入.ssh/文件夹</h3><pre><code>cd  /root/.ssh/</code></pre><h3 id="将客户端公钥放入云主机识别keys文件夹中"><a href="#将客户端公钥放入云主机识别keys文件夹中" class="headerlink" title="将客户端公钥放入云主机识别keys文件夹中"></a>将客户端公钥放入云主机识别keys文件夹中</h3><pre><code>cat id_rsa.pub &gt;&gt; authorized_keys</code></pre><h3 id="销毁公钥"><a href="#销毁公钥" class="headerlink" title="销毁公钥"></a>销毁公钥</h3><pre><code>rm id_rsa.pub</code></pre><p>再次输入ssh root@ip地址就可以直接连接了，当然如果你使用工具的话就不用这么麻烦。</p><blockquote><p>到这里就基本上初步，而且是很简单的实现的主机的查看与操作，具体更多操作和命令请查看相关资料，后期也会有一些配置，操作与实战，请期待</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 去年中旬在阿里买了一个属于自己的个性域名(笔者英文)：&lt;a href=&quot;http://www.icocos.cn，虽然是CN，但是这都不是重点，重点是为了更全面的接触后台，更好的学习与实战后台开发与PHP，前天又在阿里买了个主机，打算开发玩弄一番，毕竟第一次，期间可能会遇到不少坑和不对的地方，望谅解与指出一起交流，谢谢.....&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.icocos.cn，虽然是CN，但是这都不是重点，重点是为了更全面的接触后台，更好的学习与实战后台开发与PHP，前天又在阿里买了个主机，打算开发玩弄一番，毕竟第一次，期间可能会遇到不少坑和不对的地方，望谅解与指出一起交流，谢谢.....&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="Server" scheme="https://icocos.github.io/categories/Server/"/>
    
    
      <category term="Server" scheme="https://icocos.github.io/tags/Server/"/>
    
      <category term="阿里云主机配置与操作" scheme="https://icocos.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
</feed>
